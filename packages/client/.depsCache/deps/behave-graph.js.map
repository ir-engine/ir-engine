{
  "version": 3,
  "sources": ["../../../../node_modules/behave-graph/src/lib/Events/EventEmitter.ts", "../../../../node_modules/behave-graph/src/lib/Diagnostics/Logger.ts", "../../../../node_modules/behave-graph/src/lib/Diagnostics/Assert.ts", "../../../../node_modules/behave-graph/src/lib/generateUuid.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Registry/NodeTypeRegistry.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Node.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/EventNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Registry/NodeDescription.ts", "../../../../node_modules/behave-graph/src/lib/Sockets/Socket.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/CustomEvents/OnCustomEvent.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/FlowNode.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/CustomEvents/TriggerCustomEvent.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/ImmediateNode.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Variables/VariableGet.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Variables/VariableSet.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/Graph.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/AsyncNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Link.ts", "../../../../node_modules/behave-graph/src/lib/Values/ValueType.ts", "../../../../node_modules/behave-graph/src/lib/Events/CustomEvent.ts", "../../../../node_modules/behave-graph/src/lib/Variables/Variable.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Templates/In4Out1FuncNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Templates/In3Out1FuncNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Templates/In2Out1FuncNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Templates/In1Out1FuncNode.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Templates/In0Out1FuncNode.ts", "../../../../node_modules/behave-graph/src/lib/sleep.ts", "../../../../node_modules/behave-graph/src/lib/Execution/Fiber.ts", "../../../../node_modules/behave-graph/src/lib/Execution/Engine.ts", "../../../../node_modules/behave-graph/src/lib/Execution/traceToLogger.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/IO/readGraphFromJSON.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/IO/writeGraphToJSON.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/IO/writeNodeSpecsToJSON.ts", "../../../../node_modules/behave-graph/src/lib/Values/ValueTypeRegistry.ts", "../../../../node_modules/behave-graph/src/lib/Registry.ts", "../../../../node_modules/behave-graph/src/lib/Nodes/Validation/validateNodeRegistry.ts", "../../../../node_modules/behave-graph/src/lib/Values/Validation/validateValueRegistry.ts", "../../../../node_modules/behave-graph/src/lib/validateRegistry.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/Validation/validateGraphAcyclic.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/Validation/validateGraphLinks.ts", "../../../../node_modules/behave-graph/src/lib/Graphs/Validation/validateGraph.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Abstractions/Drivers/DefaultLogger.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Debug/AssertExpectTrue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Debug/DebugLog.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Branch.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Debounce.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Delay.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/FlipFlop.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/ForLoop.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Sequence.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Lifecycle/LifecycleOnEnd.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Lifecycle/LifecycleOnStart.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Lifecycle/LifecycleOnTick.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/BooleanNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/BooleanValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/FloatNodes.ts", "../../../../node_modules/behave-graph/src/lib/parseFloats.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/FloatValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/IntegerNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/IntegerValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/StringNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Values/StringValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/DoN.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/DoOnce.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Gate.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/MultieGate.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/Flow/Throttle.ts", "../../../../node_modules/behave-graph/src/lib/toCamelCase.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/registerSerializersForValueType.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Core/registerCoreProfile.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Internal/Vec3.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/ColorValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/EulerValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Internal/Vec4.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/QuatValue.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Internal/Vec2.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec2Value.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec3Value.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec4Value.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Abstractions/Drivers/DummyScene.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Actions/SetSceneProperty.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Events/OnSceneNodeClick.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Logic/VecElements.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Queries/GetSceneProperty.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/ColorNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/EulerNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec2Nodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec3Nodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/Vec4Nodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/Values/QuatNodes.ts", "../../../../node_modules/behave-graph/src/lib/Profiles/Scene/registerSceneProfile.ts"],
  "sourcesContent": ["export class EventEmitter<T> {\n  private readonly listeners: ((t: T) => void)[] = [];\n\n  addListener(listener: (t: T) => void) {\n    this.listeners.push(listener);\n  }\n\n  removeListener(listener: (t: T) => void) {\n    this.listeners.splice(this.listeners.indexOf(listener), 1);\n  }\n\n  clear() {\n    this.listeners.splice(0, this.listeners.length);\n  }\n\n  emit(event: T) {\n    if (this.listeners.length === 0) return;\n    // copy array before emitting event to ensure even if listener array is modified, everyone listening initially gets the event.\n    // inspired by mrdoob's EventDispatcher\n    this.listeners.slice(0).forEach((listener) => {\n      listener(event);\n    });\n  }\n\n  get listenerCount(): number {\n    return this.listeners.length;\n  }\n}\n", "/* eslint-disable no-console */\n\nimport { EventEmitter } from '../Events/EventEmitter.js';\n\nexport class Logger {\n  public static readonly onVerbose = new EventEmitter<string>();\n  public static readonly onInfo = new EventEmitter<string>();\n  public static readonly onWarn = new EventEmitter<string>();\n  public static readonly onError = new EventEmitter<string>();\n\n  static {\n    const prefix = () => {\n      return new Date().toLocaleTimeString().padStart(11, '0');\n    };\n    Logger.onVerbose.addListener((text: string) => {\n      console.log(prefix() + ` VERB:  ${text}`);\n    });\n    Logger.onInfo.addListener((text: string) => {\n      console.log(prefix() + ` INFO:  ${text}`);\n    });\n    Logger.onWarn.addListener((text: string) => {\n      console.warn(prefix() + ` WARN:  ${text}`);\n    });\n    Logger.onError.addListener((text: string) => {\n      console.error(prefix() + ` ERR:  ${text}`);\n    });\n  }\n\n  static verbose(text: string) {\n    this.onVerbose.emit(text);\n  }\n\n  static info(text: string) {\n    this.onInfo.emit(text);\n  }\n\n  static warn(text: string) {\n    this.onWarn.emit(text);\n  }\n\n  static error(text: string) {\n    this.onError.emit(text);\n  }\n}\n", "export class Assert {\n  static mustBeTrue(condition: boolean, msg = '') {\n    if (!condition) {\n      throw new Error(`failed assertion: ${msg}`);\n    }\n  }\n}\n", "/* eslint-disable no-mixed-operators */\n/* eslint-disable no-bitwise */\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nconst lut: string[] = [];\nfor (let i = 0; i < 256; i++) {\n  lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nexport function generateUuid() {\n  const d0 = (Math.random() * 0xffffffff) | 0;\n  const d1 = (Math.random() * 0xffffffff) | 0;\n  const d2 = (Math.random() * 0xffffffff) | 0;\n  const d3 = (Math.random() * 0xffffffff) | 0;\n  const uuid = `${\n    lut[d0 & 0xff] +\n    lut[(d0 >> 8) & 0xff] +\n    lut[(d0 >> 16) & 0xff] +\n    lut[(d0 >> 24) & 0xff]\n  }-${lut[d1 & 0xff]}${lut[(d1 >> 8) & 0xff]}-${\n    lut[((d1 >> 16) & 0x0f) | 0x40]\n  }${lut[(d1 >> 24) & 0xff]}-${lut[(d2 & 0x3f) | 0x80]}${\n    lut[(d2 >> 8) & 0xff]\n  }-${lut[(d2 >> 16) & 0xff]}${lut[(d2 >> 24) & 0xff]}${lut[d3 & 0xff]}${\n    lut[(d3 >> 8) & 0xff]\n  }${lut[(d3 >> 16) & 0xff]}${lut[(d3 >> 24) & 0xff]}`;\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase();\n}\n", "import { NodeDescription } from './NodeDescription.js';\n\nexport class NodeTypeRegistry {\n  private readonly typeNameToNodeDescriptions: {\n    [type: string]: NodeDescription;\n  } = {};\n\n  clear() {\n    for (const nodeTypeName in this.typeNameToNodeDescriptions) {\n      delete this.typeNameToNodeDescriptions[nodeTypeName];\n    }\n  }\n  register(...descriptions: Array<NodeDescription>) {\n    descriptions.forEach((description) => {\n      if (description.typeName in this.typeNameToNodeDescriptions) {\n        throw new Error(\n          `already registered node type ${description.typeName} (string)`\n        );\n      }\n      this.typeNameToNodeDescriptions[description.typeName] = description;\n    });\n  }\n\n  contains(typeName: string): boolean {\n    return typeName in this.typeNameToNodeDescriptions;\n  }\n  get(typeName: string): NodeDescription {\n    if (!(typeName in this.typeNameToNodeDescriptions)) {\n      throw new Error(`no registered node with type name ${typeName}`);\n    }\n    return this.typeNameToNodeDescriptions[typeName];\n  }\n\n  getAllNames(): string[] {\n    return Object.keys(this.typeNameToNodeDescriptions);\n  }\n\n  getAllDescriptions(): NodeDescription[] {\n    return Object.values(this.typeNameToNodeDescriptions);\n  }\n}\n", "import { Graph } from '../Graphs/Graph.js';\nimport { Metadata } from '../Metadata.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { NodeDescription } from './Registry/NodeDescription.js';\n\nexport class Node {\n  public id = '';\n  public label = '';\n  public metadata: Metadata = {};\n\n  constructor(\n    public readonly description: NodeDescription,\n    public readonly graph: Graph,\n    public readonly inputSockets: Socket[] = [],\n    public readonly outputSockets: Socket[] = []\n  ) {}\n\n  // TODO: this may want to cache the values on the creation of the NodeEvalContext\n  // for re-entrant async operations, otherwise the inputs may change during operation.\n  readInput<T>(inputName: string): T {\n    const inputSocket = this.inputSockets.find(\n      (socket) => socket.name === inputName\n    );\n    if (inputSocket === undefined) {\n      throw new Error(\n        `can not find input socket with name ${inputName} on node of type ${this.description.typeName}`\n      );\n    }\n    return inputSocket.value as T;\n  }\n\n  writeOutput<T>(outputName: string, value: T) {\n    const outputSocket = this.outputSockets.find(\n      (socket) => socket.name === outputName\n    );\n    if (outputSocket === undefined) {\n      throw new Error(\n        `can not find output socket with name ${outputSocket} on node of type ${this.description.typeName}`\n      );\n    }\n    if (outputSocket.valueTypeName === 'flow') {\n      throw new Error(\n        `can not set the value of Flow output socket ${outputName}, use commit() instead`\n      );\n    }\n    outputSocket.value = value;\n  }\n}\n", "import { Assert } from '../Diagnostics/Assert.js';\nimport { Engine } from '../Execution/Engine.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { Node } from './Node.js';\nimport { NodeDescription } from './Registry/NodeDescription.js';\n\n// no flow inputs, always evaluated on startup\nexport class EventNode extends Node {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputSockets: Socket[],\n    outputSockets: Socket[]\n  ) {\n    super(description, graph, inputSockets, outputSockets);\n    // no input flow sockets allowed.\n    Assert.mustBeTrue(\n      !this.inputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n\n    // must have at least one output flow socket\n    Assert.mustBeTrue(\n      this.outputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n  }\n\n  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars\n  init(engine: Engine) {\n    throw new Error('not implemented');\n  }\n\n  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars\n  dispose(engine: Engine) {\n    throw new Error('not implemented');\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Node } from './../Node.js';\nimport { NodeCategory } from './NodeCategory.js';\n\nexport type NodeFactory = (entry: NodeDescription, graph: Graph) => Node;\n\nexport function getNodeDescriptions(importWildcard: any) {\n  return Object.keys(importWildcard)\n    .map((key) => (importWildcard as { [key: string]: any })[key])\n    .filter((value) => value instanceof NodeDescription) as NodeDescription[];\n}\n\nexport class NodeDescription {\n  constructor(\n    public readonly typeName: string,\n    public readonly category: NodeCategory,\n    public readonly label: string,\n    public readonly factory: NodeFactory\n  ) {}\n}\n", "import { Link } from '../Nodes/Link.js';\n\nexport class Socket {\n  public readonly links: Link[] = [];\n\n  constructor(\n    public readonly valueTypeName: string,\n    public readonly name: string,\n    public value: any | undefined = undefined,\n    public readonly label: string | undefined = undefined\n  ) {}\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { CustomEvent } from '../../../Events/CustomEvent.js';\nimport { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { EventNode } from '../../../Nodes/EventNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class OnCustomEvent extends EventNode {\n  public static GetDescription(graph: Graph, customEventId: string) {\n    const customEvent = graph.customEvents[customEventId];\n    return new NodeDescription(\n      `customEvent/onTriggered/${customEvent.id}`,\n      'Event',\n      `On ${customEvent.name}`,\n      (description, graph) => new OnCustomEvent(description, graph, customEvent)\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly customEvent: CustomEvent\n  ) {\n    super(\n      description,\n      graph,\n      [],\n      [\n        new Socket('flow', 'flow'),\n        ...customEvent.parameters.map(\n          (parameter) =>\n            new Socket(\n              parameter.valueTypeName,\n              parameter.name,\n              parameter.value,\n              parameter.label\n            )\n        )\n      ]\n    );\n  }\n  private onCustomEvent:\n    | ((parameters: { [parameter: string]: any }) => void)\n    | undefined = undefined;\n\n  init(engine: Engine) {\n    Assert.mustBeTrue(this.onCustomEvent === undefined);\n\n    this.onCustomEvent = (parameters) => {\n      this.customEvent.parameters.forEach((parameterSocket) => {\n        if (!(parameterSocket.name in parameters)) {\n          throw new Error(\n            `parameters of custom event do not align with parameters of custom event node, missing ${parameterSocket.name}`\n          );\n        }\n        this.writeOutput(\n          parameterSocket.name,\n          parameters[parameterSocket.name]\n        );\n      });\n      engine.commitToNewFiber(this, 'flow');\n    };\n    this.customEvent.eventEmitter.addListener(this.onCustomEvent);\n  }\n\n  dispose(engine: Engine) {\n    Assert.mustBeTrue(this.onCustomEvent !== undefined);\n    if (this.onCustomEvent !== undefined) {\n      this.customEvent.eventEmitter.removeListener(this.onCustomEvent);\n    }\n  }\n}\n", "import { Assert } from '../Diagnostics/Assert.js';\nimport { Fiber } from '../Execution/Fiber.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { Node } from './Node.js';\nimport { NodeDescription } from './Registry/NodeDescription.js';\n\nexport class FlowNode extends Node {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputSockets: Socket[],\n    outputSockets: Socket[]\n  ) {\n    // determine if this is an eval node\n    super(description, graph, inputSockets, outputSockets);\n\n    // must have at least one input flow socket\n    Assert.mustBeTrue(\n      this.inputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n  }\n\n  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    throw new Error('not implemented');\n  }\n}\n", "import { CustomEvent } from '../../../Events/CustomEvent.js';\nimport { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class TriggerCustomEvent extends FlowNode {\n  public static GetDescription(graph: Graph, customEventId: string) {\n    const customEvent = graph.customEvents[customEventId];\n    return new NodeDescription(\n      `customEvent/trigger/${customEvent.id}`,\n      'Action',\n      `Trigger ${customEvent.name}`,\n      (description, graph) =>\n        new TriggerCustomEvent(description, graph, customEvent)\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly customEvent: CustomEvent\n  ) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        ...customEvent.parameters.map(\n          (parameter) =>\n            new Socket(\n              parameter.valueTypeName,\n              parameter.name,\n              parameter.value,\n              parameter.label\n            )\n        )\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    const parameters: { [parameterName: string]: any } = {};\n    this.customEvent.parameters.forEach((parameterSocket) => {\n      parameters[parameterSocket.name] = this.readInput(parameterSocket.name);\n    });\n    this.customEvent.eventEmitter.emit(parameters);\n  }\n}\n", "import { Assert } from '../Diagnostics/Assert.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { Node } from './Node.js';\nimport { NodeDescription } from './Registry/NodeDescription.js';\n\nexport class ImmediateNode extends Node {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputSockets: Socket[],\n    outputSockets: Socket[],\n    public readonly exec: () => void\n  ) {\n    super(description, graph, inputSockets, outputSockets);\n\n    // must have no input flow sockets\n    Assert.mustBeTrue(\n      !this.inputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n\n    // must have no output flow sockets\n    Assert.mustBeTrue(\n      !this.outputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n  }\n}\n", "import { Graph } from '../../../Graphs/Graph.js';\nimport { ImmediateNode } from '../../../Nodes/ImmediateNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { Variable } from '../../../Variables/Variable.js';\n\nexport class VariableGet extends ImmediateNode {\n  public static GetDescription(graph: Graph, variableId: string) {\n    const variable = graph.variables[variableId];\n    return new NodeDescription(\n      `variable/get/${variable.id}`,\n      'Query',\n      '', // these nodes have no name in Unreal Engine Blueprints\n      (description, graph) => new VariableGet(description, graph, variable)\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly variable: Variable\n  ) {\n    super(\n      description,\n      graph,\n      [],\n      [new Socket(variable.valueTypeName, 'value', undefined, variable.name)], // output socket label uses variable name like UE4, but name is value to avoid breaking graph when variable is renamed\n      () => {\n        this.writeOutput('value', variable.get());\n      }\n    );\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { Variable } from '../../../Variables/Variable.js';\n\nexport class VariableSet extends FlowNode {\n  public static GetDescription(graph: Graph, variableId: string) {\n    const variable = graph.variables[variableId];\n    return new NodeDescription(\n      `variable/set/${variable.id}`,\n      'Action',\n      `Set`,\n      (description, graph) => new VariableSet(description, graph, variable)\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly variable: Variable\n  ) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket(variable.valueTypeName, 'value', undefined, variable.name) // variable name is a label so variable can be renamed without breaking graph.\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeredSocketName: string) {\n    this.variable.set(this.readInput('value'));\n    fiber.commit(this, 'flow');\n  }\n}\n", "import { CustomEvent } from '../Events/CustomEvent.js';\nimport { generateUuid } from '../generateUuid.js';\nimport { Metadata } from '../Metadata.js';\nimport { Node } from '../Nodes/Node.js';\nimport { NodeTypeRegistry } from '../Nodes/Registry/NodeTypeRegistry.js';\nimport { OnCustomEvent } from '../Profiles/Core/CustomEvents/OnCustomEvent.js';\nimport { TriggerCustomEvent } from '../Profiles/Core/CustomEvents/TriggerCustomEvent.js';\nimport { VariableGet } from '../Profiles/Core/Variables/VariableGet.js';\nimport { VariableSet } from '../Profiles/Core/Variables/VariableSet.js';\nimport { Registry } from '../Registry.js';\nimport { Variable } from '../Variables/Variable.js';\n// Purpose:\n//  - stores the node graph\n\nexport class Graph {\n  public name = '';\n  // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?\n  public readonly nodes: { [id: string]: Node } = {};\n  // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?\n  public readonly variables: { [id: string]: Variable } = {};\n  // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?\n  public readonly customEvents: { [id: string]: CustomEvent } = {};\n  public metadata: Metadata = {};\n  public readonly dynamicNodeRegistry = new NodeTypeRegistry();\n  public version = 0;\n\n  constructor(public readonly registry: Registry) {}\n\n  updateDynamicNodeDescriptions() {\n    // delete existing nodes\n    this.dynamicNodeRegistry.clear();\n    // re-add variable nodes\n    for (const variableId in this.variables) {\n      this.dynamicNodeRegistry.register(\n        VariableGet.GetDescription(this, variableId),\n        VariableSet.GetDescription(this, variableId)\n      );\n    }\n    // re-add custom event nodes\n    for (const customEventId in this.customEvents) {\n      this.dynamicNodeRegistry.register(\n        OnCustomEvent.GetDescription(this, customEventId),\n        TriggerCustomEvent.GetDescription(this, customEventId)\n      );\n    }\n  }\n  createNode(nodeTypeName: string, nodeId: string = generateUuid()): Node {\n    if (nodeId in this.nodes) {\n      throw new Error(\n        `can not create new node of type ${nodeTypeName} with id ${nodeId} as one with that id already exists.`\n      );\n    }\n    let nodeDescription = undefined;\n    if (this.registry.nodes.contains(nodeTypeName)) {\n      nodeDescription = this.registry.nodes.get(nodeTypeName);\n    }\n    if (this.dynamicNodeRegistry.contains(nodeTypeName)) {\n      nodeDescription = this.dynamicNodeRegistry.get(nodeTypeName);\n    }\n    if (nodeDescription === undefined) {\n      throw new Error(\n        `no registered node descriptions with the typeName ${nodeTypeName}`\n      );\n    }\n    const node = nodeDescription.factory(nodeDescription, this);\n    node.id = nodeId;\n    this.nodes[nodeId] = node;\n    node.inputSockets.forEach((socket) => {\n      if (socket.valueTypeName !== 'flow' && socket.value === undefined) {\n        socket.value = this.registry.values.get(socket.valueTypeName).creator();\n      }\n    });\n\n    return node;\n  }\n}\n", "import { Assert } from '../Diagnostics/Assert.js';\nimport { Engine } from '../Execution/Engine.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { Node } from './Node.js';\nimport { NodeDescription } from './Registry/NodeDescription.js';\n\n// async flow node with only a single flow input\nexport class AsyncNode extends Node {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputSockets: Socket[],\n    outputSockets: Socket[]\n  ) {\n    super(description, graph, inputSockets, outputSockets);\n    // must have at least one input flow socket\n    Assert.mustBeTrue(\n      this.inputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n\n    // must have at least one output flow socket\n    Assert.mustBeTrue(\n      this.outputSockets.some((socket) => socket.valueTypeName === 'flow')\n    );\n  }\n\n  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars\n  triggered(\n    engine: Engine,\n    triggeringSocketName: string,\n    finished: () => void\n  ) {\n    throw new Error('not implemented');\n  }\n\n  dispose() {\n    throw new Error('not implemented');\n  }\n}\n", "import { Socket } from '../Sockets/Socket.js';\nimport { Node } from './Node.js';\n\nexport class Link {\n  public _targetNode: Node | undefined = undefined;\n  public _targetSocket: Socket | undefined = undefined;\n\n  constructor(public nodeId: string = '', public socketName: string = '') {}\n}\n", "export class ValueType<TValue = any, TJson = any> {\n  constructor(\n    public readonly name: string,\n    public readonly creator: () => TValue,\n    public readonly deserialize: (value: TJson) => TValue,\n    public readonly serialize: (value: TValue) => TJson\n  ) {}\n}\n", "import { Metadata } from '../Metadata.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { EventEmitter } from './EventEmitter.js';\n\nexport class CustomEvent {\n  public label = '';\n  public metadata: Metadata = {};\n  public readonly eventEmitter = new EventEmitter<{\n    [parameterName: string]: any;\n  }>();\n\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly parameters: Socket[] = []\n  ) {}\n}\n", "import { EventEmitter } from '../Events/EventEmitter.js';\nimport { Metadata } from '../Metadata.js';\n\nexport class Variable {\n  private value: any;\n  public label = '';\n  public metadata: Metadata = {};\n  public version = 0; // this is updated on each change to the variable state.\n  public readonly onChanged = new EventEmitter<Variable>();\n\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly valueTypeName: string,\n    public initialValue: any // this is assumed to be properly deseriealized from a string.\n  ) {\n    this.value = this.initialValue;\n  }\n\n  get(): any {\n    return this.value;\n  }\n\n  set(newValue: any) {\n    if (newValue !== this.value) {\n      this.value = newValue;\n      this.version++;\n      this.onChanged.emit(this);\n    }\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { ImmediateNode } from '../ImmediateNode.js';\nimport { NodeDescription } from '../Registry/NodeDescription.js';\n\nexport class In4Out1FuncNode<In1, In2, In3, In4, Out1> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputValueTypes: string[],\n    outputValueType: string,\n    public readonly binaryEvalFunc: (a: In1, b: In2, c: In3, d: In4) => Out1,\n    public readonly inputNames: string[] = ['a', 'b', 'c', 'd']\n  ) {\n    if (inputValueTypes.length !== 4) {\n      throw new Error(\n        `inputValueTypes must have a length of 4, it is instead ${inputValueTypes.length}`\n      );\n    }\n    if (inputNames.length !== 4) {\n      throw new Error(\n        `inputNames must have a length of 4, it is instead ${inputNames.length}`\n      );\n    }\n    super(\n      description,\n      graph,\n      [\n        new Socket(inputValueTypes[0], inputNames[0]),\n        new Socket(inputValueTypes[1], inputNames[1]),\n        new Socket(inputValueTypes[2], inputNames[2]),\n        new Socket(inputValueTypes[3], inputNames[3])\n      ],\n      [new Socket(outputValueType, 'result')],\n      () => {\n        this.writeOutput(\n          'result',\n          this.binaryEvalFunc(\n            this.readInput(inputNames[0]),\n            this.readInput(inputNames[1]),\n            this.readInput(inputNames[2]),\n            this.readInput(inputNames[3])\n          )\n        );\n      }\n    );\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { ImmediateNode } from '../ImmediateNode.js';\nimport { NodeDescription } from '../Registry/NodeDescription.js';\n\nexport class In3Out1FuncNode<In1, In2, In3, Out1> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputValueTypes: string[],\n    outputValueType: string,\n    public readonly binaryEvalFunc: (a: In1, b: In2, c: In3) => Out1,\n    public readonly inputNames: string[] = ['a', 'b', 'c']\n  ) {\n    if (inputValueTypes.length !== 3) {\n      throw new Error(\n        `inputValueTypes must have a length of 3, it is instead ${inputValueTypes.length}`\n      );\n    }\n    if (inputNames.length !== 3) {\n      throw new Error(\n        `inputNames must have a length of 3, it is instead ${inputNames.length}`\n      );\n    }\n    super(\n      description,\n      graph,\n      [\n        new Socket(inputValueTypes[0], inputNames[0]),\n        new Socket(inputValueTypes[1], inputNames[1]),\n        new Socket(inputValueTypes[2], inputNames[2])\n      ],\n      [new Socket(outputValueType, 'result')],\n      () => {\n        this.writeOutput(\n          'result',\n          this.binaryEvalFunc(\n            this.readInput(inputNames[0]),\n            this.readInput(inputNames[1]),\n            this.readInput(inputNames[2])\n          )\n        );\n      }\n    );\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { ImmediateNode } from '../ImmediateNode.js';\nimport { NodeDescription } from '../Registry/NodeDescription.js';\n\nexport class In2Out1FuncNode<In1, In2, Out1> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputValueTypes: string[],\n    outputValueType: string,\n    public readonly binaryEvalFunc: (a: In1, b: In2) => Out1,\n    public readonly inputNames: string[] = ['a', 'b']\n  ) {\n    if (inputValueTypes.length !== 2) {\n      throw new Error(\n        `inputValueTypes must have a length of 2, it is instead ${inputValueTypes.length}`\n      );\n    }\n    if (inputNames.length !== 2) {\n      throw new Error(\n        `inputNames must have a length of 2, it is instead ${inputNames.length}`\n      );\n    }\n    super(\n      description,\n      graph,\n      [\n        new Socket(inputValueTypes[0], inputNames[0]),\n        new Socket(inputValueTypes[1], inputNames[1])\n      ],\n      [new Socket(outputValueType, 'result')],\n      () => {\n        this.writeOutput(\n          'result',\n          this.binaryEvalFunc(\n            this.readInput(inputNames[0]),\n            this.readInput(inputNames[1])\n          )\n        );\n      }\n    );\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { ImmediateNode } from '../ImmediateNode.js';\nimport { NodeDescription } from '../Registry/NodeDescription.js';\n\nexport class In1Out1FuncNode<In1, Out1> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    inputValueTypes: string[],\n    outputValueType: string,\n    public readonly unaryEvalFunc: (a: In1) => Out1,\n    public readonly inputNames: string[] = ['a']\n  ) {\n    if (inputValueTypes.length !== 1) {\n      throw new Error(\n        `inputValueTypes must have a length of 1, it is instead ${inputValueTypes.length}`\n      );\n    }\n    if (inputNames.length !== 1) {\n      throw new Error(\n        `inputNames must have a length of 1, it is instead ${inputNames.length}`\n      );\n    }\n    super(\n      description,\n      graph,\n      [new Socket(inputValueTypes[0], inputNames[0])],\n      [new Socket(outputValueType, 'result')],\n      () => {\n        this.writeOutput(\n          'result',\n          this.unaryEvalFunc(this.readInput(inputNames[0]))\n        );\n      }\n    );\n  }\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { ImmediateNode } from '../ImmediateNode.js';\nimport { NodeDescription } from '../Registry/NodeDescription.js';\n\nexport class In0Out1FuncNode<Out1> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    outputValueType: string,\n    public readonly nullaryEvalFunc: () => Out1\n  ) {\n    super(\n      description,\n      graph,\n      [],\n      [new Socket(outputValueType, 'result')],\n      () => {\n        this.writeOutput('result', this.nullaryEvalFunc());\n      }\n    );\n  }\n}\n", "/* eslint-disable no-promise-executor-return */\nexport function sleep(durationInSeconds: number) {\n  return new Promise((resolve) =>\n    setTimeout(resolve, Math.round(durationInSeconds * 1000))\n  );\n}\n", "import { Assert } from '../Diagnostics/Assert.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { AsyncNode } from '../Nodes/AsyncNode.js';\nimport { EventNode } from '../Nodes/EventNode.js';\nimport { FlowNode } from '../Nodes/FlowNode.js';\nimport { ImmediateNode } from '../Nodes/ImmediateNode.js';\nimport { Link } from '../Nodes/Link.js';\nimport { Node } from '../Nodes/Node.js';\nimport { Socket } from '../Sockets/Socket.js';\nimport { Engine } from './Engine.js';\n\nexport class Fiber {\n  private readonly fiberCompletedListenerStack: (() => void)[] = [];\n  private readonly graph: Graph;\n  public executionSteps = 0;\n\n  constructor(\n    public engine: Engine,\n    public nextEval: Link | null,\n    fiberCompletedListener: (() => void) | undefined = undefined\n  ) {\n    this.graph = engine.graph;\n    if (fiberCompletedListener !== undefined) {\n      this.fiberCompletedListenerStack.push(fiberCompletedListener);\n    }\n  }\n\n  // NOTE: This is a simplistic recursive and wasteful approach.\n  // Is is optimal for a tree, but can do a lot of duplicate evaluations in dense graphs.\n  // It will also get stuck in a recursive loop when there are loops in the graph.\n  // TODO: Replace with initial traversal to extract sub DAG, order it, and evaluate each node once.\n  resolveInputValueFromSocket(inputSocket: Socket) {\n    // if it has no links, leave value on input socket alone.\n    if (inputSocket.links.length === 0) {\n      return;\n    }\n\n    const upstreamLink = inputSocket.links[0];\n    // caching the target node + socket here increases engine performance by 8% on average.  This is a hotspot.\n    if (\n      upstreamLink._targetNode === undefined ||\n      upstreamLink._targetSocket === undefined\n    ) {\n      Assert.mustBeTrue(inputSocket.links.length === 1);\n\n      // if upstream node is an eval, we just return its last value.\n      upstreamLink._targetNode = this.graph.nodes[upstreamLink.nodeId];\n      // what is inputSocket connected to?\n      upstreamLink._targetSocket = upstreamLink._targetNode.outputSockets.find(\n        (socket) => socket.name === upstreamLink.socketName\n      );\n      if (upstreamLink._targetSocket === undefined) {\n        throw new Error(\n          `can not find socket with the name ${upstreamLink.socketName}`\n        );\n      }\n    }\n\n    const upstreamNode = upstreamLink._targetNode;\n    const upstreamOutputSocket = upstreamLink._targetSocket;\n\n    if (upstreamNode instanceof ImmediateNode) {\n      // resolve all inputs for the upstream node (this is where the recursion happens)\n      // TODO: This is a bit dangerous as if there are loops in the graph, this will blow up the stack\n      for (const upstreamInputSocket of upstreamNode.inputSockets) {\n        this.resolveInputValueFromSocket(upstreamInputSocket);\n      }\n\n      this.engine.onNodeExecution.emit(upstreamNode);\n      upstreamNode.exec();\n      this.executionSteps++;\n\n      // get the output value we wanted.\n      inputSocket.value = upstreamOutputSocket.value;\n      return;\n    }\n\n    // if upstream is a flow/event/async node, do not evaluate it rather just use its existing output socket values\n    if (\n      upstreamNode instanceof FlowNode ||\n      upstreamNode instanceof EventNode ||\n      upstreamNode instanceof AsyncNode\n    ) {\n      inputSocket.value = upstreamOutputSocket.value;\n      return;\n    }\n\n    throw new TypeError(\n      `node, ${upstreamNode.description.typeName}, must be an instance of ImmediateNode`\n    );\n  }\n\n  // this is syncCommit.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars\n  commit(\n    node: Node,\n    outputSocketName: string,\n    fiberCompletedListener: (() => void) | undefined = undefined\n  ) {\n    Assert.mustBeTrue(node instanceof FlowNode);\n    Assert.mustBeTrue(this.nextEval === null);\n\n    const outputSocket = node.outputSockets.find(\n      (socket) => socket.name === outputSocketName\n    );\n    if (outputSocket === undefined) {\n      throw new Error(`can not find socket with the name ${outputSocketName}`);\n    }\n\n    if (outputSocket.links.length > 1) {\n      throw new Error(\n        'invalid for an output flow socket to have multiple downstream links:' +\n          `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`\n      );\n    }\n    if (outputSocket.links.length === 1) {\n      const link = outputSocket.links[0];\n      if (link === undefined) {\n        throw new Error('link must be defined');\n      }\n      this.nextEval = link;\n    }\n\n    if (fiberCompletedListener !== undefined) {\n      this.fiberCompletedListenerStack.push(fiberCompletedListener);\n    }\n  }\n\n  // returns the number of new execution steps created as a result of this one step\n  executeStep() {\n    // pop the next node off the queue\n    const link = this.nextEval;\n    this.nextEval = null;\n\n    // nothing waiting, thus go back and start to evaluate any callbacks, in stack order.\n    if (link === null) {\n      if (this.fiberCompletedListenerStack.length === 0) {\n        return;\n      }\n      const awaitingCallback = this.fiberCompletedListenerStack.pop();\n      if (awaitingCallback === undefined) {\n        throw new Error('awaitingCallback is empty');\n      }\n      awaitingCallback();\n      return;\n    }\n\n    const node = this.graph.nodes[link.nodeId];\n\n    // first resolve all input values\n    // flow socket is set to true for the one flowing in, while all others are set to false.\n    let triggeredSocketName = '';\n    node.inputSockets.forEach((inputSocket) => {\n      if (inputSocket.valueTypeName === 'flow') {\n        if (inputSocket.name === link.socketName) {\n          inputSocket.value = true;\n          triggeredSocketName = inputSocket.name;\n        }\n        return;\n      }\n      this.resolveInputValueFromSocket(inputSocket);\n    });\n\n    this.engine.onNodeExecution.emit(node);\n    if (node instanceof AsyncNode) {\n      this.engine.asyncNodes.push(node);\n      node.triggered(this.engine, triggeredSocketName, () => {\n        // remove from the list of pending async nodes\n        const index = this.engine.asyncNodes.indexOf(node);\n        this.engine.asyncNodes.splice(index, 1);\n        this.executionSteps++;\n      });\n      return;\n    }\n    if (node instanceof FlowNode) {\n      node.triggered(this, triggeredSocketName);\n      this.executionSteps++;\n      return;\n    }\n\n    throw new TypeError(\n      `should not get here, unhandled node ${node.description.typeName}`\n    );\n  }\n\n  isCompleted() {\n    return (\n      this.fiberCompletedListenerStack.length === 0 && this.nextEval === null\n    );\n  }\n}\n", "/* eslint-disable space-in-parens */\n\nimport { Assert } from '../Diagnostics/Assert.js';\nimport { EventEmitter } from '../Events/EventEmitter.js';\nimport { Graph } from '../Graphs/Graph.js';\nimport { AsyncNode } from '../Nodes/AsyncNode.js';\nimport { EventNode } from '../Nodes/EventNode.js';\nimport { Node } from '../Nodes/Node.js';\nimport { sleep } from '../sleep.js';\nimport { Fiber } from './Fiber.js';\n\nexport class Engine {\n  // tracking the next node+input socket to execute.\n  private readonly fiberQueue: Fiber[] = [];\n  public readonly asyncNodes: AsyncNode[] = [];\n  public readonly eventNodes: EventNode[] = [];\n  public readonly onNodeExecution = new EventEmitter<Node>();\n  public executionSteps = 0;\n\n  constructor(public readonly graph: Graph) {\n    // collect all event nodes\n    Object.values(graph.nodes).forEach((node) => {\n      if (node instanceof EventNode) {\n        this.eventNodes.push(node);\n      }\n    });\n    // init all event nodes at startup\n    this.eventNodes.forEach((eventNode) => eventNode.init(this));\n  }\n\n  dispose() {\n    // dispose all, possibly in-progress, async nodes\n    this.asyncNodes.forEach((asyncNode) => asyncNode.dispose());\n\n    // dispose all event nodes\n    this.eventNodes.forEach((eventNode) => eventNode.dispose(this));\n  }\n\n  // asyncCommit\n  commitToNewFiber(\n    node: Node,\n    outputFlowSocketName: string,\n    fiberCompletedListener: (() => void) | undefined = undefined\n  ) {\n    Assert.mustBeTrue(node instanceof EventNode || node instanceof AsyncNode);\n    const outputSocket = node.outputSockets.find(\n      (socket) => socket.name === outputFlowSocketName\n    );\n    if (outputSocket === undefined) {\n      throw new Error(`no socket with the name ${outputFlowSocketName}`);\n    }\n    if (outputSocket.links.length > 1) {\n      throw new Error(\n        'invalid for an output flow socket to have multiple downstream links:' +\n          `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`\n      );\n    }\n    if (outputSocket.links.length === 1) {\n      const fiber = new Fiber(\n        this,\n        outputSocket.links[0],\n        fiberCompletedListener\n      );\n      this.fiberQueue.push(fiber);\n    }\n  }\n\n  // NOTE: This does not execute all if there are promises.\n  executeAllSync(limitInSeconds = 100, limitInSteps = 100000000): number {\n    const startDateTime = Date.now();\n    let elapsedSeconds = 0;\n    let elapsedSteps = 0;\n    while (\n      elapsedSteps < limitInSteps &&\n      elapsedSeconds < limitInSeconds &&\n      this.fiberQueue.length > 0\n    ) {\n      const currentFiber = this.fiberQueue[0];\n      const startingFiberExecutionSteps = currentFiber.executionSteps;\n      currentFiber.executeStep();\n      elapsedSteps += currentFiber.executionSteps - startingFiberExecutionSteps;\n      if (currentFiber.isCompleted()) {\n        // remove first element\n        this.fiberQueue.shift();\n      }\n      elapsedSeconds = (Date.now() - startDateTime) * 0.001;\n    }\n    this.executionSteps += elapsedSteps;\n\n    return elapsedSteps;\n  }\n\n  async executeAllAsync(\n    limitInSeconds = 100,\n    limitInSteps = 100000000\n  ): Promise<number> {\n    const startDateTime = Date.now();\n    let elapsedSteps = 0;\n    let elapsedTime = 0;\n    let iterations = 0;\n    do {\n      if (iterations > 0) {\n        // eslint-disable-next-line no-await-in-loop\n        await sleep(0);\n      }\n      elapsedSteps += this.executeAllSync(\n        limitInSeconds - elapsedTime,\n        limitInSteps - elapsedSteps\n      );\n      elapsedTime = (Date.now() - startDateTime) * 0.001;\n      iterations += 1;\n    } while (\n      (this.asyncNodes.length > 0 || this.fiberQueue.length > 0) &&\n      elapsedTime < limitInSeconds &&\n      elapsedSteps < limitInSteps\n    );\n\n    return elapsedSteps;\n  }\n}\n", "import { Logger } from '../Diagnostics/Logger.js';\nimport { Node } from '../Nodes/Node.js';\nexport function traceToLogger(node: Node) {\n  const prefix = `<< ${node.description.typeName}:${node.id} >> `;\n  Logger.verbose(prefix);\n}\n", "import { Logger } from '../../Diagnostics/Logger.js';\nimport { CustomEvent } from '../../Events/CustomEvent.js';\nimport { Link } from '../../Nodes/Link.js';\nimport { Node } from '../../Nodes/Node.js';\nimport { Registry } from '../../Registry.js';\nimport { Socket } from '../../Sockets/Socket.js';\nimport { Variable } from '../../Variables/Variable.js';\nimport { Graph } from '../Graph.js';\nimport {\n  CustomEventJSON,\n  FlowsJSON,\n  GraphJSON,\n  NodeJSON,\n  NodeParametersJSON,\n  VariableJSON\n} from './GraphJSON.js';\n\n// Purpose:\n//  - loads a node graph\nexport function readGraphFromJSON(\n  graphJson: GraphJSON,\n  registry: Registry\n): Graph {\n  const graph = new Graph(registry);\n\n  graph.name = graphJson?.name ?? graph.name;\n  graph.metadata = graphJson?.metadata ?? graph.metadata;\n\n  if ('variables' in graphJson) {\n    readVariablesJSON(graph, graphJson.variables ?? []);\n  }\n  if ('customEvents' in graphJson) {\n    readCustomEventsJSON(graph, graphJson.customEvents ?? []);\n  }\n\n  // register node based on variables and custom events.\n  graph.updateDynamicNodeDescriptions();\n\n  const nodesJson = graphJson?.nodes ?? [];\n\n  if (nodesJson.length === 0) {\n    Logger.warn('readGraphFromJSON: no nodes specified');\n  }\n\n  // create new BehaviorNode instances for each node in the json.\n  for (let i = 0; i < nodesJson.length; i += 1) {\n    const nodeJson = nodesJson[i];\n    readNodeJSON(graph, nodeJson);\n  }\n\n  // connect up the graph edges from BehaviorNode inputs to outputs.  This is required to follow execution\n  Object.values(graph.nodes).forEach((node) => {\n    // initialize the inputs by resolving to the reference nodes.\n    node.inputSockets.forEach((inputSocket) => {\n      inputSocket.links.forEach((link) => {\n        if (!(link.nodeId in graph.nodes)) {\n          throw new Error(\n            `node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` +\n              `a nonexistent upstream node id: ${link.nodeId}`\n          );\n        }\n        const upstreamNode = graph.nodes[link.nodeId];\n        const upstreamOutputSocket = upstreamNode.outputSockets.find(\n          (socket) => socket.name === link.socketName\n        );\n        if (upstreamOutputSocket === undefined) {\n          throw new Error(\n            `node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` +\n              `a nonexistent output '${link.socketName}' on upstream node '${upstreamNode.description.typeName}'`\n          );\n        }\n\n        // add, only if unique\n        const upstreamLink = new Link(node.id, inputSocket.name);\n        if (\n          upstreamOutputSocket.links.findIndex(\n            (value) =>\n              value.nodeId == upstreamLink.nodeId &&\n              value.socketName == upstreamLink.socketName\n          ) < 0\n        ) {\n          upstreamOutputSocket.links.push(upstreamLink);\n        }\n      });\n    });\n\n    node.outputSockets.forEach((outputSocket) => {\n      outputSocket.links.forEach((link) => {\n        if (!(link.nodeId in graph.nodes)) {\n          throw new Error(\n            `node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` +\n              `a nonexistent downstream node id ${link.nodeId}`\n          );\n        }\n\n        const downstreamNode = graph.nodes[link.nodeId];\n        const downstreamInputSocket = downstreamNode.inputSockets.find(\n          (socket) => socket.name === link.socketName\n        );\n        if (downstreamInputSocket === undefined) {\n          throw new Error(\n            `node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` +\n              `a nonexistent input '${link.socketName}' on downstream node '${downstreamNode.description.typeName}'`\n          );\n        }\n\n        // add, only if unique\n        const downstreamLink = new Link(node.id, outputSocket.name);\n        if (\n          downstreamInputSocket.links.findIndex(\n            (value) =>\n              value.nodeId == downstreamLink.nodeId &&\n              value.socketName == downstreamLink.socketName\n          ) < 0\n        ) {\n          downstreamInputSocket.links.push(downstreamLink);\n        }\n      });\n    });\n  });\n\n  return graph;\n}\n\nfunction readNodeJSON(graph: Graph, nodeJson: NodeJSON) {\n  if (nodeJson.type === undefined) {\n    throw new Error('readGraphFromJSON: no type for node');\n  }\n  const nodeName = nodeJson.type;\n  const node = graph.createNode(nodeName, nodeJson.id);\n\n  node.label = nodeJson?.label ?? node.label;\n  node.metadata = nodeJson?.metadata ?? node.metadata;\n\n  if (nodeJson.parameters !== undefined) {\n    readNodeParameterJSON(graph, node, nodeJson.parameters);\n  }\n  if (nodeJson.flows !== undefined) {\n    readNodeFlowsJSON(graph, node, nodeJson.flows);\n  }\n}\n\nfunction readNodeParameterJSON(\n  graph: Graph,\n  node: Node,\n  parametersJson: NodeParametersJSON\n) {\n  node.inputSockets.forEach((socket) => {\n    if (!(socket.name in parametersJson)) {\n      return;\n    }\n\n    const inputJson = parametersJson[socket.name];\n    if ('value' in inputJson) {\n      // eslint-disable-next-line no-param-reassign\n      socket.value = graph.registry.values\n        .get(socket.valueTypeName)\n        .deserialize(inputJson.value);\n    }\n\n    if ('link' in inputJson) {\n      const linkJson = inputJson.link;\n      socket.links.push(new Link(linkJson.nodeId, linkJson.socket));\n    }\n  });\n\n  // validate that there are no additional input sockets specified that were not read.\n  for (const inputName in parametersJson) {\n    const inputSocket = node.inputSockets.find(\n      (socket) => socket.name === inputName\n    );\n    if (inputSocket === undefined) {\n      throw new Error(\n        `node '${node.description.typeName}' specifies an input '${inputName}' that doesn't exist on its node type`\n      );\n    }\n  }\n}\n\nfunction readNodeFlowsJSON(graph: Graph, node: Node, flowsJson: FlowsJSON) {\n  node.outputSockets.forEach((socket) => {\n    if (socket.name in flowsJson) {\n      const outputLinkJson = flowsJson[socket.name];\n      socket.links.push(new Link(outputLinkJson.nodeId, outputLinkJson.socket));\n    }\n  });\n\n  // validate that there are no additional input sockets specified that were not read.\n  for (const outputName in flowsJson) {\n    const outputSocket = node.outputSockets.find(\n      (socket) => socket.name === outputName\n    );\n    if (outputSocket === undefined) {\n      throw new Error(\n        `node '${node.description.typeName}' specifies an output '${outputName}' that doesn't exist on its node type`\n      );\n    }\n  }\n}\n\nfunction readVariablesJSON(graph: Graph, variablesJson: VariableJSON[]) {\n  for (let i = 0; i < variablesJson.length; i += 1) {\n    const variableJson = variablesJson[i];\n\n    const variable = new Variable(\n      variableJson.id,\n      variableJson.name,\n      variableJson.valueTypeName,\n      graph.registry.values\n        .get(variableJson.valueTypeName)\n        .deserialize(variableJson.initialValue)\n    );\n    variable.label = variableJson?.label ?? variable.label;\n    variable.metadata = variableJson?.metadata ?? variable.metadata;\n\n    if (variableJson.id in graph.variables) {\n      throw new Error(`duplicate variable id ${variable.id}`);\n    }\n    graph.variables[variableJson.id] = variable;\n  }\n}\n\nfunction readCustomEventsJSON(\n  graph: Graph,\n  customEventsJson: CustomEventJSON[]\n) {\n  for (let i = 0; i < customEventsJson.length; i += 1) {\n    const customEventJson = customEventsJson[i];\n\n    const parameters: Socket[] = [];\n    (customEventJson.parameters ?? []).forEach((parameterJson) => {\n      parameters.push(\n        new Socket(\n          parameterJson.valueTypeName,\n          parameterJson.name,\n          graph.registry.values\n            .get(parameterJson.valueTypeName)\n            .deserialize(parameterJson.defaultValue)\n        )\n      );\n    });\n\n    const customEvent = new CustomEvent(\n      customEventJson.id,\n      customEventJson.name,\n      parameters\n    );\n    customEvent.label = customEventJson?.label ?? customEvent.label;\n    customEvent.metadata = customEventJson?.metadata ?? customEvent.metadata;\n\n    if (customEvent.id in graph.customEvents) {\n      throw new Error(`duplicate variable id ${customEvent.id}`);\n    }\n    graph.customEvents[customEvent.id] = customEvent;\n  }\n}\n", "import { Graph } from '../Graph.js';\nimport {\n  CustomEventJSON,\n  CustomEventParameterJSON,\n  GraphJSON,\n  LinkJSON,\n  NodeJSON,\n  NodeParameterJSON,\n  VariableJSON\n} from './GraphJSON.js';\n\nexport function writeGraphToJSON(graph: Graph): GraphJSON {\n  const graphJson: GraphJSON = {};\n\n  if (Object.keys(graph.metadata).length > 0) {\n    graphJson.metadata = graph.metadata;\n  }\n\n  // save custom events\n  Object.values(graph.customEvents).forEach((customEvent) => {\n    const customEventJson: CustomEventJSON = {\n      name: customEvent.name,\n      id: customEvent.id\n    };\n    if (customEvent.label.length > 0) {\n      customEventJson.label = customEvent.label;\n    }\n    if (customEvent.parameters.length > 0) {\n      const parametersJson: CustomEventParameterJSON[] = [];\n      customEvent.parameters.forEach((parameter) => {\n        parametersJson.push({\n          name: parameter.name,\n          valueTypeName: parameter.valueTypeName,\n          defaultValue: parameter.value\n        });\n      });\n      customEventJson.parameters = parametersJson;\n    }\n    if (Object.keys(customEvent.metadata).length > 0) {\n      customEventJson.metadata = customEvent.metadata;\n    }\n    if (graphJson.customEvents === undefined) {\n      graphJson.customEvents = [];\n    }\n    graphJson.customEvents.push(customEventJson);\n  });\n\n  // save variables\n  Object.values(graph.variables).forEach((variable) => {\n    const variableJson: VariableJSON = {\n      valueTypeName: variable.valueTypeName,\n      name: variable.name,\n      id: variable.id,\n      initialValue: graph.registry.values\n        .get(variable.valueTypeName)\n        .serialize(variable.initialValue)\n    };\n    if (variable.label.length > 0) {\n      variableJson.label = variable.label;\n    }\n    if (Object.keys(variable.metadata).length > 0) {\n      variableJson.metadata = variable.metadata;\n    }\n    if (graphJson.variables === undefined) {\n      graphJson.variables = [];\n    }\n    graphJson.variables.push(variableJson);\n  });\n\n  // save nodes\n  Object.values(graph.nodes).forEach((node) => {\n    const nodeJson: NodeJSON = {\n      type: node.description.typeName,\n      id: node.id\n    };\n    if (node.label.length > 0) {\n      nodeJson.label = node.label;\n    }\n    if (Object.keys(node.metadata).length > 0) {\n      nodeJson.metadata = node.metadata;\n    }\n\n    const parametersJson: NodeJSON['parameters'] = {};\n    node.inputSockets.forEach((inputSocket) => {\n      if (inputSocket.valueTypeName === 'flow') return;\n\n      let parameterJson: NodeParameterJSON | undefined = undefined;\n\n      if (inputSocket.links.length === 0) {\n        parameterJson = {\n          value: graph.registry.values\n            .get(inputSocket.valueTypeName)\n            .serialize(inputSocket.value)\n        };\n      } else if (inputSocket.links.length === 1) {\n        const link = inputSocket.links[0];\n        parameterJson = {\n          link: {\n            nodeId: link.nodeId,\n            socket: link.socketName\n          }\n        };\n      } else {\n        throw new Error(\n          `should not get here, inputSocket.links.length = ${inputSocket.links.length} > 1`\n        );\n      }\n      parametersJson[inputSocket.name] = parameterJson;\n    });\n\n    if (Object.keys(parametersJson).length > 0) {\n      nodeJson.parameters = parametersJson;\n    }\n\n    const flowsJson: { [output: string]: LinkJSON } = {};\n    node.outputSockets.forEach((outputSocket) => {\n      if (outputSocket.valueTypeName !== 'flow') return;\n\n      if (outputSocket.links.length === 0) return;\n\n      const linkJson = {\n        nodeId: outputSocket.links[0].nodeId,\n        socket: outputSocket.links[0].socketName\n      };\n\n      flowsJson[outputSocket.name] = linkJson;\n    });\n\n    if (Object.keys(flowsJson).length > 0) {\n      nodeJson.flows = flowsJson;\n    }\n    if (graphJson.nodes === undefined) {\n      graphJson.nodes = [];\n    }\n    graphJson.nodes.push(nodeJson);\n  });\n\n  return graphJson;\n}\n", "import { Registry } from '../../Registry.js';\nimport { Graph } from '../Graph.js';\nimport {\n  InputSocketSpecJSON,\n  NodeSpecJSON,\n  OutputSocketSpecJSON\n} from './NodeSpecJSON.js';\n\nexport function writeNodeSpecsToJSON(registry: Registry): NodeSpecJSON[] {\n  const nodeSpecsJSON: NodeSpecJSON[] = [];\n\n  const graph = new Graph(registry);\n\n  registry.nodes.getAllNames().forEach((nodeTypeName) => {\n    const node = graph.createNode(nodeTypeName);\n\n    const nodeSpecJSON: NodeSpecJSON = {\n      type: nodeTypeName,\n      category: node.description.category,\n      label: node.description.label,\n      inputs: [],\n      outputs: []\n    };\n\n    node.inputSockets.forEach((inputSocket) => {\n      const valueType =\n        inputSocket.valueTypeName === 'flow'\n          ? undefined\n          : registry.values.get(inputSocket.valueTypeName);\n\n      let defaultValue = inputSocket.value;\n      if (valueType !== undefined) {\n        defaultValue = valueType.serialize(defaultValue);\n      }\n      if (defaultValue === undefined && valueType !== undefined) {\n        defaultValue = valueType.serialize(valueType.creator());\n      }\n      const socketSpecJSON: InputSocketSpecJSON = {\n        name: inputSocket.name,\n        valueType: inputSocket.valueTypeName,\n        defaultValue\n      };\n      nodeSpecJSON.inputs.push(socketSpecJSON);\n    });\n\n    node.outputSockets.forEach((outputSocket) => {\n      const socketSpecJSON: OutputSocketSpecJSON = {\n        name: outputSocket.name,\n        valueType: outputSocket.valueTypeName\n      };\n      nodeSpecJSON.outputs.push(socketSpecJSON);\n    });\n\n    nodeSpecsJSON.push(nodeSpecJSON);\n  });\n\n  return nodeSpecsJSON;\n}\n", "import { ValueType } from './ValueType.js';\n\nexport class ValueTypeRegistry {\n  private readonly valueTypeNameToValueType: { [key: string]: ValueType } = {};\n\n  register(...valueTypes: Array<ValueType>) {\n    valueTypes.forEach((valueType) => {\n      if (valueType.name in this.valueTypeNameToValueType) {\n        throw new Error(`already registered value type ${valueType.name}`);\n      }\n      this.valueTypeNameToValueType[valueType.name] = valueType;\n    });\n  }\n\n  get(valueTypeName: string): ValueType {\n    if (!(valueTypeName in this.valueTypeNameToValueType)) {\n      throw new Error(`can not find value type with name '${valueTypeName}`);\n    }\n    return this.valueTypeNameToValueType[valueTypeName];\n  }\n\n  getAllNames(): string[] {\n    return Object.keys(this.valueTypeNameToValueType);\n  }\n}\n", "import { NodeTypeRegistry } from './Nodes/Registry/NodeTypeRegistry.js';\nimport { ValueTypeRegistry } from './Values/ValueTypeRegistry.js';\n\nexport class Registry {\n  public readonly values = new ValueTypeRegistry();\n  public readonly nodes = new NodeTypeRegistry();\n}\n", "import { Graph } from '../../Graphs/Graph.js';\nimport { Registry } from '../../Registry.js';\n\nconst nodeTypeNameRegex = /^\\w+(\\/\\w+)*$/;\nconst socketNameRegex = /^\\w+$/;\n\nexport function validateNodeRegistry(registry: Registry): string[] {\n  const errorList: string[] = [];\n  const graph = new Graph(registry);\n  registry.nodes.getAllNames().forEach((nodeTypeName) => {\n    const node = graph.createNode(nodeTypeName);\n\n    // ensure node is registered correctly.\n    if (node.description.typeName !== nodeTypeName) {\n      errorList.push(\n        `node with typeName '${node.description.typeName}' is registered under a different name '${nodeTypeName}'`\n      );\n    }\n\n    if (!nodeTypeNameRegex.test(node.description.typeName)) {\n      errorList.push(\n        `invalid node type name on node ${node.description.typeName}`\n      );\n    }\n\n    node.inputSockets.forEach((socket) => {\n      if (!socketNameRegex.test(socket.name)) {\n        errorList.push(\n          `invalid socket name for input socket ${socket.name} on node ${node.description.typeName}`\n        );\n      }\n\n      if (socket.valueTypeName === 'flow') {\n        return;\n      }\n      const valueType = registry.values.get(socket.valueTypeName);\n      // check to ensure all value types are supported.\n      if (valueType === undefined) {\n        errorList.push(\n          `node '${node.description.typeName}' has on input socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`\n        );\n      }\n    });\n\n    node.outputSockets.forEach((socket) => {\n      if (!socketNameRegex.test(socket.name)) {\n        errorList.push(\n          `invalid socket name for output socket ${socket.name} on node ${node.description.typeName}`\n        );\n      }\n      if (socket.valueTypeName === 'flow') {\n        return;\n      }\n      const valueType = registry.values.get(socket.valueTypeName);\n      // check to ensure all value types are supported.\n      if (valueType === undefined) {\n        errorList.push(\n          `node '${node.description.typeName}' has on output socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`\n        );\n      }\n    });\n  });\n  return errorList;\n}\n", "import { Registry } from '../../Registry.js';\n\nconst valueTypeNameRegex = /^\\w+$/;\n\nexport function validateValueRegistry(graphRegistry: Registry): string[] {\n  const errorList: string[] = [];\n\n  graphRegistry.values.getAllNames().forEach((valueTypeName) => {\n    if (!valueTypeNameRegex.test(valueTypeName)) {\n      errorList.push(`invalid value type name ${valueTypeName}`);\n    }\n\n    const valueType = graphRegistry.values.get(valueTypeName);\n\n    const value = valueType.creator();\n    const serializedValue = valueType.serialize(value);\n    const deserializedValue = valueType.deserialize(serializedValue);\n    const reserializedValue = valueType.serialize(deserializedValue);\n    const redeserializedValue = valueType.deserialize(reserializedValue);\n\n    if (JSON.stringify(serializedValue) !== JSON.stringify(reserializedValue)) {\n      errorList.push(\n        `value type (${valueTypeName}) reserialization mismatch between ${JSON.stringify(\n          serializedValue\n        )} and ${JSON.stringify(reserializedValue)}`\n      );\n    }\n\n    if (\n      typeof deserializedValue !== 'bigint' &&\n      JSON.stringify(deserializedValue) !== JSON.stringify(redeserializedValue)\n    ) {\n      errorList.push(\n        `value type (${valueTypeName}) redeserialization mismatch between ${JSON.stringify(\n          deserializedValue\n        )} and ${JSON.stringify(redeserializedValue)}`\n      );\n    }\n  });\n  return errorList;\n}\n", "import { validateNodeRegistry } from './Nodes/Validation/validateNodeRegistry.js';\nimport { Registry } from './Registry.js';\nimport { validateValueRegistry } from './Values/Validation/validateValueRegistry.js';\n\nexport function validateRegistry(registry: Registry): string[] {\n  const errorList: string[] = [];\n  errorList.push(\n    ...validateValueRegistry(registry),\n    ...validateNodeRegistry(registry)\n  );\n  return errorList;\n}\n", "import { Node } from '../../Nodes/Node.js';\nimport { Graph } from '../Graph.js';\n\nexport function validateGraphAcyclic(graph: Graph): string[] {\n  // apparently if you can topological sort, it is a DAG according to: https://stackoverflow.com/questions/4168/graph-serialization/4577#4577\n\n  // instead of modifying the graph, I will use metadata to mark it in place.\n  Object.values(graph.nodes).forEach((node) => {\n    // eslint-disable-next-line no-param-reassign\n    node.metadata['dag.marked'] = 'false';\n  });\n\n  // it appears that we can just keep trimming nodes whose input sockets have no connections.\n  // if we can remove all nodes, that means that there are no cycles.\n\n  const nodesToMark: Node[] = [];\n\n  do {\n    // clear array: https://stackoverflow.com/a/1232046\n    nodesToMark.length = 0;\n\n    Object.values(graph.nodes).forEach((node) => {\n      // ignore existing marked nodes.\n      if (node.metadata['dag.marked'] === 'true') {\n        return;\n      }\n\n      let inputSocketsConnected = false;\n      node.inputSockets.forEach((inputSocket) => {\n        inputSocket.links.forEach((link) => {\n          // is the other end marked?  If not, then it is still connected.\n          if (graph.nodes[link.nodeId].metadata['dag.marked'] === 'false') {\n            inputSocketsConnected = true;\n          }\n        });\n      });\n      if (!inputSocketsConnected) {\n        nodesToMark.push(node);\n      }\n    });\n    nodesToMark.forEach((node) => {\n      // eslint-disable-next-line no-param-reassign\n      node.metadata['dag.marked'] = 'true';\n    });\n  } while (nodesToMark.length > 0);\n\n  const errorList: string[] = [];\n\n  // output errors for each unmarked node\n  // also remove the metadata related to DAG marking\n  Object.values(graph.nodes).forEach((node) => {\n    if (node.metadata['dag.marked'] === 'false') {\n      errorList.push(\n        `node ${node.description.typeName} is part of a cycle, not a directed acyclic graph`\n      );\n    }\n    // eslint-disable-next-line no-param-reassign\n    delete node.metadata['dag.marked'];\n  });\n\n  return errorList;\n}\n", "import { Graph } from '../Graph.js';\n\nexport function validateGraphLinks(graph: Graph): string[] {\n  const errorList: string[] = [];\n  // for each node\n  Object.values(graph.nodes).forEach((node) => {\n    // for each input socket\n    node.inputSockets.forEach((inputSocket) => {\n      // ensure that connected output sockets are the same type\n      inputSocket.links.forEach((link) => {\n        // check if the node id is correct\n        if (!(link.nodeId in graph.nodes)) {\n          errorList.push(\n            `node ${node.description.typeName}.${inputSocket.name} has link using invalid nodeId: ${link.nodeId}`\n          );\n          return;\n        }\n\n        // check if the socketName is correct\n        const upstreamNode = graph.nodes[link.nodeId];\n        const outputSocket = upstreamNode.outputSockets.find(\n          (socket) => socket.name === link.socketName\n        );\n        if (outputSocket === undefined) {\n          errorList.push(\n            `node ${node.description.typeName}.${inputSocket.name} has link using a non-existent socket name: ` +\n              `${link.socketName}, it can not be found on upstream output node: ${upstreamNode.description.typeName}`\n          );\n          return;\n        }\n\n        // check if the socket types align\n        if (inputSocket.valueTypeName !== outputSocket.valueTypeName) {\n          errorList.push(\n            `type mismatch between ${node.description.typeName}.${inputSocket.name} [${inputSocket.valueTypeName}] ` +\n              `and ${upstreamNode.description.typeName}.${outputSocket.name} [${outputSocket.valueTypeName}]`\n          );\n        }\n      });\n    });\n  });\n  return errorList;\n}\n", "import { Graph } from '../Graph.js';\nimport { validateGraphAcyclic } from './validateGraphAcyclic.js';\nimport { validateGraphLinks } from './validateGraphLinks.js';\n\nexport function validateGraph(graph: Graph): string[] {\n  const errorList: string[] = [];\n  errorList.push(...validateGraphAcyclic(graph), ...validateGraphLinks(graph));\n  return errorList;\n}\n", "/* eslint-disable class-methods-use-this */\nimport { Logger } from '../../../../Diagnostics/Logger.js';\nimport { ILogger } from '../ILogger.js';\n\nexport class DefaultLogger implements ILogger {\n  verbose(text: string): void {\n    Logger.verbose(text);\n  }\n\n  info(text: string): void {\n    Logger.info(text);\n  }\n\n  warn(text: string): void {\n    Logger.warn(text);\n  }\n\n  error(text: string): void {\n    Logger.error(text);\n  }\n}\n", "import { EventEmitter } from '../../../../Events/EventEmitter.js';\nimport { ILifecycleEventEmitter } from '../ILifecycleEventEmitter.js';\n\nexport class ManualLifecycleEventEmitter implements ILifecycleEventEmitter {\n  public readonly startEvent = new EventEmitter<void>();\n  public readonly endEvent = new EventEmitter<void>();\n  public readonly tickEvent = new EventEmitter<void>();\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class ExpectTrue extends FlowNode {\n  public static Description = new NodeDescription(\n    'debug/expectTrue',\n    'Action',\n    'Assert Expect True',\n    (description, graph) => new ExpectTrue(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('boolean', 'condition'),\n        new Socket('string', 'description')\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeredSocketName: string) {\n    Assert.mustBeTrue(\n      this.readInput('condition'),\n      this.readInput('description')\n    );\n    fiber.commit(this, 'flow');\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { ILogger } from '../Abstractions/ILogger.js';\n\nexport class Log extends FlowNode {\n  public static Description = (logger: ILogger) =>\n    new NodeDescription(\n      'debug/log',\n      'Action',\n      'Debug Log',\n      (description, graph) => new Log(description, graph, logger)\n    );\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    private readonly logger: ILogger\n  ) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow'), new Socket('string', 'text')],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeredSocketName: string) {\n    this.logger.info(this.readInput('text'));\n    fiber.commit(this, 'flow');\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class Branch extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/branch',\n    'Flow',\n    'Branch',\n    (description, graph) => new Branch(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow'), new Socket('boolean', 'condition')],\n      [new Socket('flow', 'true'), new Socket('flow', 'false')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    fiber.commit(\n      this,\n      this.readInput<boolean>('condition') === true ? 'true' : 'false'\n    );\n  }\n}\n", "import { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { AsyncNode } from '../../../Nodes/AsyncNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// as long as this continues to be triggered within the duration period, it will not fire.\n// based lousy on https://www.npmjs.com/package/debounce\n\nexport class Debounce extends AsyncNode {\n  public static Description = new NodeDescription(\n    'flow/debounce',\n    'Flow',\n    'Debounce',\n    (description, graph) => new Debounce(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('float', 'waitDuration'),\n        new Socket('flow', 'cancel')\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  private triggerVersion = 0;\n\n  triggered(\n    engine: Engine,\n    triggeringSocketName: string,\n    finished: () => void\n  ) {\n    this.triggerVersion++;\n\n    // if cancelling, just increment triggerVersion and do not set a timer. :)\n    if (triggeringSocketName === 'cancel') {\n      return;\n    }\n\n    const localTriggerCount = this.triggerVersion;\n    setTimeout(() => {\n      if (this.triggerVersion >= localTriggerCount) {\n        // ignore this timer, as it isn't for the most recent trigger\n        return;\n      }\n\n      engine.commitToNewFiber(this, 'flow');\n      finished();\n    }, this.readInput<number>('waitDuration') * 1000);\n  }\n\n  dispose() {\n    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.\n  }\n}\n", "import { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { AsyncNode } from '../../../Nodes/AsyncNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// ASYNC - asynchronous evaluation\n// also called \"delay\"\n\nexport class Delay extends AsyncNode {\n  public static Description = new NodeDescription(\n    'flow/delay',\n    'Flow',\n    'Delay',\n    (description, graph) => new Delay(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow'), new Socket('float', 'duration', 1)],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  private timeoutPending = false;\n\n  triggered(\n    engine: Engine,\n    triggeringSocketName: string,\n    finished: () => void\n  ) {\n    // if there is a valid timeout running, leave it.\n    if (this.timeoutPending) {\n      return;\n    }\n\n    // otherwise start it.\n    this.timeoutPending = true;\n    setTimeout(() => {\n      // check if cancelled\n      if (!this.timeoutPending) return;\n      this.timeoutPending = false;\n      engine.commitToNewFiber(this, 'flow');\n      finished();\n    }, this.readInput<number>('duration') * 1000);\n  }\n\n  dispose() {\n    this.timeoutPending = false;\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class FlipFlop extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/flipFlop',\n    'Flow',\n    'Flip Flop',\n    (description, graph) => new FlipFlop(description, graph)\n  );\n\n  private isOn = true;\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow')],\n      [\n        new Socket('flow', 'on'),\n        new Socket('flow', 'off'),\n        new Socket('boolean', 'isOn')\n      ]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    this.writeOutput('isOn', this.isOn);\n    fiber.commit(this, this.isOn ? 'on' : 'off');\n    this.isOn = !this.isOn;\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class ForLoop extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/forLoop',\n    'Flow',\n    'For Loop',\n    (description, graph) => new ForLoop(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('integer', 'startIndex'),\n        new Socket('integer', 'endIndex')\n      ],\n      [\n        new Socket('flow', 'loopBody'),\n        new Socket('integer', 'index'),\n        new Socket('flow', 'completed')\n      ]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    // these outputs are fired sequentially in an async fashion but without delays.\n    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.\n    const startIndex = this.readInput<bigint>('startIndex');\n    const endIndex = this.readInput<bigint>('endIndex');\n    const loopBodyIteration = (i: bigint) => {\n      if (i < endIndex) {\n        this.writeOutput('index', i);\n        fiber.commit(this, 'loopBody', () => {\n          loopBodyIteration(i + 1n);\n        });\n      } else {\n        fiber.commit(this, 'completed');\n      }\n    };\n    loopBodyIteration(startIndex);\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/\n\nexport class Sequence extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/sequence',\n    'Flow',\n    'Sequence',\n    (description, graph) => new Sequence(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow')],\n      [\n        new Socket('flow', '1'),\n        new Socket('flow', '2'),\n        new Socket('flow', '3')\n      ]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    // these outputs are fired sequentially in an sync fashion but without delays.\n    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.\n    const sequenceIteration = (i: number) => {\n      if (i < this.outputSockets.length) {\n        const outputSocket = this.outputSockets[i];\n        fiber.commit(this, outputSocket.name, () => {\n          sequenceIteration(i + 1);\n        });\n      }\n    };\n    sequenceIteration(0);\n  }\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { EventNode } from '../../../Nodes/EventNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { ILifecycleEventEmitter } from '../Abstractions/ILifecycleEventEmitter.js';\n\n// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/\nexport class LifecycleOnEnd extends EventNode {\n  public static Description = (lifecycleEventEmitter: ILifecycleEventEmitter) =>\n    new NodeDescription(\n      'lifecycle/onEnd',\n      'Event',\n      'On End',\n      (description, graph) =>\n        new LifecycleOnEnd(description, graph, lifecycleEventEmitter)\n    );\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    private readonly lifecycleEventEmitter: ILifecycleEventEmitter\n  ) {\n    super(description, graph, [], [new Socket('flow', 'flow')]);\n  }\n\n  private onEndEvent: (() => void) | undefined = undefined;\n\n  init(engine: Engine) {\n    Assert.mustBeTrue(this.onEndEvent === undefined);\n    this.onEndEvent = () => {\n      engine.commitToNewFiber(this, 'flow');\n    };\n\n    this.lifecycleEventEmitter.endEvent.addListener(this.onEndEvent);\n  }\n\n  dispose(engine: Engine) {\n    Assert.mustBeTrue(this.onEndEvent !== undefined);\n    if (this.onEndEvent !== undefined) {\n      this.lifecycleEventEmitter.endEvent.removeListener(this.onEndEvent);\n    }\n  }\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { EventNode } from '../../../Nodes/EventNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { ILifecycleEventEmitter } from '../Abstractions/ILifecycleEventEmitter.js';\n\n// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/\nexport class LifecycleOnStart extends EventNode {\n  public static Description = (lifecycleEventEmitter: ILifecycleEventEmitter) =>\n    new NodeDescription(\n      'lifecycle/onStart',\n      'Event',\n      'On Start',\n      (description, graph) =>\n        new LifecycleOnStart(description, graph, lifecycleEventEmitter)\n    );\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    private readonly lifecycleEventEmitter: ILifecycleEventEmitter\n  ) {\n    super(description, graph, [], [new Socket('flow', 'flow')]);\n  }\n\n  private onStartEvent: (() => void) | undefined = undefined;\n\n  init(engine: Engine) {\n    Assert.mustBeTrue(this.onStartEvent === undefined);\n    this.onStartEvent = () => {\n      engine.commitToNewFiber(this, 'flow');\n    };\n\n    this.lifecycleEventEmitter.startEvent.addListener(this.onStartEvent);\n  }\n\n  dispose(engine: Engine) {\n    Assert.mustBeTrue(this.onStartEvent !== undefined);\n    if (this.onStartEvent !== undefined) {\n      this.lifecycleEventEmitter.startEvent.removeListener(this.onStartEvent);\n    }\n  }\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { EventNode } from '../../../Nodes/EventNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { ILifecycleEventEmitter } from '../Abstractions/ILifecycleEventEmitter.js';\n\n// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/\nexport class LifecycleOnTick extends EventNode {\n  public static Description = (lifecycleEventEmitter: ILifecycleEventEmitter) =>\n    new NodeDescription(\n      'lifecycle/onTick',\n      'Event',\n      'On Tick',\n      (description, graph) =>\n        new LifecycleOnTick(description, graph, lifecycleEventEmitter)\n    );\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    private readonly lifecycleEventEmitter: ILifecycleEventEmitter\n  ) {\n    super(\n      description,\n      graph,\n      [],\n      [\n        new Socket('flow', 'flow'),\n        new Socket('float', 'deltaSeconds'),\n        new Socket('float', 'time')\n      ]\n    );\n  }\n\n  private onTickEvent: (() => void) | undefined = undefined;\n\n  init(engine: Engine) {\n    Assert.mustBeTrue(this.onTickEvent === undefined);\n    let lastTickTime = Date.now();\n    this.onTickEvent = () => {\n      const currentTime = Date.now();\n      const deltaSeconds = (currentTime - lastTickTime) * 0.001;\n      this.writeOutput('deltaSeconds', deltaSeconds);\n      this.writeOutput('time', Date.now());\n      engine.commitToNewFiber(this, 'flow');\n      lastTickTime = currentTime;\n    };\n\n    this.lifecycleEventEmitter.tickEvent.addListener(this.onTickEvent);\n  }\n\n  dispose(engine: Engine) {\n    Assert.mustBeTrue(this.onTickEvent !== undefined);\n    if (this.onTickEvent !== undefined) {\n      this.lifecycleEventEmitter.tickEvent.removeListener(this.onTickEvent);\n    }\n  }\n}\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\n\nexport const Constant = new NodeDescription(\n  'math/boolean',\n  'Logic',\n  'Boolean',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['boolean'],\n      'boolean',\n      (a: boolean) => a\n    )\n);\nexport const And = new NodeDescription(\n  'math/and/boolean',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['boolean', 'boolean'],\n      'boolean',\n      (a: boolean, b: boolean) => a && b\n    )\n);\nexport const Or = new NodeDescription(\n  'math/or/boolean',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['boolean', 'boolean'],\n      'boolean',\n      (a: boolean, b: boolean) => a || b\n    )\n);\nexport const Not = new NodeDescription(\n  'math/negate/boolean',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['boolean'],\n      'boolean',\n      (a: boolean) => !a\n    )\n);\nexport const ToFloat = new NodeDescription(\n  'math/toFloat/boolean',\n  'Logic',\n  'To Float',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['boolean'],\n      'float',\n      (a: boolean) => (a ? 1 : 0)\n    )\n);\nexport const Equal = new NodeDescription(\n  'math/equal/boolean',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['boolean', 'boolean'],\n      'boolean',\n      (a: boolean, b: boolean) => a === b\n    )\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\n\nexport const BooleanValue = new ValueType(\n  'boolean',\n  () => false,\n  (value: string | boolean) =>\n    typeof value === 'string' ? value.toLowerCase() === 'true' : value,\n  (value: boolean) => value\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In0Out1FuncNode } from '../../../Nodes/Templates/In0Out1FuncNode.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\n\n// Unreal Engine Blueprint Float nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Float/\n\nexport const Constant = new NodeDescription(\n  'math/float',\n  'Logic',\n  'Float',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['float'],\n      'float',\n      (a: number) => a\n    )\n);\n\nexport const Add = new NodeDescription(\n  'math/add/float',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => a + b\n    )\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/float',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => a - b\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/float',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['float'],\n      'float',\n      (a: number) => -a\n    )\n);\n\nexport const Multiply = new NodeDescription(\n  'math/multiply/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => a * b\n    )\n);\nexport const Divide = new NodeDescription(\n  'math/divide/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => a / b\n    )\n);\nexport const Modulus = new NodeDescription(\n  'math/modulus/float',\n  'Logic',\n  'MOD',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => a % b\n    )\n);\n\nexport const Power = new NodeDescription(\n  'math/pow/float',\n  'Logic',\n  'POW',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      Math.pow\n    )\n);\nexport const SquareRoot = new NodeDescription(\n  'math/sqrt/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sqrt)\n);\n\nexport const E = new NodeDescription(\n  'math/e/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In0Out1FuncNode(description, graph, 'float', () => Math.E)\n);\nexport const Exp = new NodeDescription(\n  'math/exp/float',\n  'Logic',\n  'EXP',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.exp)\n);\nexport const Ln = new NodeDescription(\n  'math/ln/float',\n  'Logic',\n  'LN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log)\n);\nexport const Log2 = new NodeDescription(\n  'math/log2/float',\n  'Logic',\n  'LOG2',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log2)\n);\nexport const Log10 = new NodeDescription(\n  'math/log10/float',\n  'Logic',\n  'LOG10',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log10)\n);\n\nexport const PI = new NodeDescription(\n  'math/pi/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In0Out1FuncNode(description, graph, 'float', () => Math.PI)\n);\nexport const Sin = new NodeDescription(\n  'math/sin/float',\n  'Logic',\n  'SIN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sin)\n);\nexport const Asin = new NodeDescription(\n  'math/asin/float',\n  'Logic',\n  'ASIN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.asin)\n);\nexport const Cos = new NodeDescription(\n  'math/cos/float',\n  'Logic',\n  'COS',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.cos)\n);\nexport const Acos = new NodeDescription(\n  'math/acos/float',\n  'Logic',\n  'ACOS',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.acos)\n);\nexport const Tan = new NodeDescription(\n  'math/tan/float',\n  'Logic',\n  'TAN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.tan)\n);\nexport const Atan = new NodeDescription(\n  'math/atan/float',\n  'Logic',\n  'ATAN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.atan)\n);\n\nexport const Mix = new NodeDescription(\n  'math/mix/float',\n  'Logic',\n  'MIX',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float'],\n      'float',\n      (a: number, b: number, t: number) => {\n        const s = 1 - t;\n        return a * s + b * t;\n      },\n      ['a', 'b', 't']\n    )\n);\n\nexport const ToFloat = new NodeDescription(\n  'math/toFloat/float',\n  'Logic',\n  'To Float',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', (a: number) =>\n      Number(a)\n    )\n);\n\nexport const Min = new NodeDescription(\n  'math/min/float',\n  'Logic',\n  'MIN',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => Math.min(a, b) // TODO: can I jsut pass in Math.min?\n    )\n);\nexport const Max = new NodeDescription(\n  'math/max/float',\n  'Logic',\n  'MAX',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'float',\n      (a: number, b: number) => Math.max(a, b) // TODO: can I jsut pass in Math.max?\n    )\n);\nexport const Clamp = new NodeDescription(\n  'math/clamp/float',\n  'Logic',\n  'CLAMP',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float'],\n      'float',\n      (value: number, min: number, max: number) =>\n        value < min ? min : value > max ? max : value,\n      ['value', 'min', 'max']\n    )\n);\n\nexport const Abs = new NodeDescription(\n  'math/abs/float',\n  'Logic',\n  'ABS',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.abs)\n);\nexport const Sign = new NodeDescription(\n  'math/sign/float',\n  'Logic',\n  'SIGN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sign)\n);\n\nexport const Floor = new NodeDescription(\n  'math/floor/float',\n  'Logic',\n  'FLOOR',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.floor)\n);\nexport const Ceil = new NodeDescription(\n  'math/ceil/float',\n  'Logic',\n  'CEIL',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.ceil)\n);\nexport const Round = new NodeDescription(\n  'math/round/float',\n  'Logic',\n  'ROUND',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.round)\n);\nexport const Trunc = new NodeDescription(\n  'math/trunc/float',\n  'Logic',\n  'TRUNC',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'float', Math.trunc)\n);\n\nexport const Random = new NodeDescription(\n  'math/random/float',\n  'Logic',\n  'RANDOM',\n  (description, graph) =>\n    new In0Out1FuncNode(description, graph, 'float', Math.random)\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/float',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'boolean',\n      (a: number, b: number) => a === b\n    )\n);\nexport const GreaterThan = new NodeDescription(\n  'math/greaterThan/float',\n  'Logic',\n  '>',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'boolean',\n      (a: number, b: number) => a > b\n    )\n);\nexport const GreaterThanOrEqual = new NodeDescription(\n  'math/greaterThanOrEqual/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'boolean',\n      (a: number, b: number) => a >= b\n    )\n);\nexport const LessThan = new NodeDescription(\n  'math/lessThan/float',\n  'Logic',\n  '<',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'boolean',\n      (a: number, b: number) => a < b\n    )\n);\nexport const LessThanOrEqual = new NodeDescription(\n  'math/lessThanOrEqual/float',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'boolean',\n      (a: number, b: number) => a <= b\n    )\n);\n\nexport const IsNaN = new NodeDescription(\n  'math/isNaN/float',\n  'Logic',\n  'isNaN',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'boolean', Number.isNaN)\n);\nexport const IsInf = new NodeDescription(\n  'math/isInf/float',\n  'Logic',\n  'isInf',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['float'],\n      'boolean',\n      (a: number) => !Number.isFinite(a) && !Number.isNaN(a)\n    )\n);\n", "const cSeparator = /[^\\d+.-]+/;\n\nexport function parseSafeFloat(text: string, fallback = 0): number {\n  try {\n    return Number.parseFloat(text);\n  } catch {\n    return fallback;\n  }\n}\nexport function parseSafeFloats(text: string, fallback = 0): number[] {\n  return text\n    .split(cSeparator)\n    .filter(Boolean)\n    .map((value) => parseSafeFloat(value, fallback));\n}\n", "import { parseSafeFloat } from '../../../parseFloats.js';\nimport { ValueType } from '../../../Values/ValueType.js';\n\nexport const FloatValue = new ValueType(\n  'float',\n  () => 0,\n  (value: string | number) =>\n    typeof value === 'string' ? parseSafeFloat(value, 0) : value,\n  (value: number) => value\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\n\n// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/\n\nexport const Constant = new NodeDescription(\n  'math/integer',\n  'Logic',\n  'Integer',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['integer'],\n      'integer',\n      (a: bigint) => a\n    )\n);\n\nexport const Add = new NodeDescription(\n  'math/add/integer',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => a + b\n    )\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/integer',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => a - b\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/integer',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['integer'],\n      'integer',\n      (a: bigint) => -a\n    )\n);\n\nexport const Multiply = new NodeDescription(\n  'math/multiply/integer',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => a * b\n    )\n);\nexport const Divide = new NodeDescription(\n  'math/divide/integer',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => a / b\n    )\n);\nexport const Modulus = new NodeDescription(\n  'math/modulus/integer',\n  'Logic',\n  'MOD',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => a % b\n    )\n);\n\nexport const ToFloat = new NodeDescription(\n  'math/toFloat/integer',\n  'Logic',\n  'To Float',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['integer'], 'float', (a: bigint) =>\n      Number(a)\n    )\n);\n\nexport const Min = new NodeDescription(\n  'math/min/integer',\n  'Logic',\n  'MIN',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => (a > b ? b : a)\n    )\n);\nexport const Max = new NodeDescription(\n  'math/max/integer',\n  'Logic',\n  'MAX',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'integer',\n      (a: bigint, b: bigint) => (a > b ? a : b)\n    )\n);\nexport const Clamp = new NodeDescription(\n  'math/clamp/integer',\n  'Logic',\n  'CLAMP',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer', 'integer'],\n      'integer',\n      (value: bigint, min: bigint, max: bigint) =>\n        value < min ? min : value > max ? max : value,\n      ['value', 'min', 'max']\n    )\n);\n\nexport const Abs = new NodeDescription(\n  'math/abs/integer',\n  'Logic',\n  'ABS',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['integer'],\n      'integer',\n      (a: bigint) => (a < 0n ? -a : a)\n    )\n);\nexport const Sign = new NodeDescription(\n  'math/sign/integer',\n  'Logic',\n  'SIGN',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['integer'],\n      'integer',\n      (a: bigint) => (a < 0n ? -1n : a > 0n ? 1n : 0n)\n    )\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/integer',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'boolean',\n      (a: bigint, b: bigint) => a === b\n    )\n);\nexport const GreaterThan = new NodeDescription(\n  'math/greaterThan/integer',\n  'Logic',\n  '>',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'boolean',\n      (a: bigint, b: bigint) => a > b\n    )\n);\nexport const GreaterThanOrEqual = new NodeDescription(\n  'math/greaterThanOrEqual/integer',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'boolean',\n      (a: bigint, b: bigint) => a >= b\n    )\n);\nexport const LessThan = new NodeDescription(\n  'math/lessThan/integer',\n  'Logic',\n  '<',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'boolean',\n      (a: bigint, b: bigint) => a < b\n    )\n);\nexport const LessThanOrEqual = new NodeDescription(\n  'math/lessThanOrEqual/integer',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['integer', 'integer'],\n      'boolean',\n      (a: bigint, b: bigint) => a <= b\n    )\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\n\nexport const IntegerValue = new ValueType(\n  'integer',\n  () => 0n,\n  (value: string | number): bigint => BigInt(value),\n  (value: bigint) =>\n    Number.MIN_SAFE_INTEGER <= value && value <= Number.MAX_SAFE_INTEGER\n      ? Number(value)\n      : value.toString() // prefer string to ensure full range is covered\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\n\nexport const Constant = new NodeDescription(\n  'logic/string',\n  'Logic',\n  'String',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['string'],\n      'string',\n      (a: string) => a\n    )\n);\n\nexport const Concat = new NodeDescription(\n  'logic/concat/string',\n  'Logic',\n  'Concat',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['string', 'string'],\n      'string',\n      (a: string, b: string) => a.concat(b)\n    )\n);\nexport const Includes = new NodeDescription(\n  'logic/includes/string',\n  'Logic',\n  'Includes',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['string', 'string'],\n      'boolean',\n      (a: string, b: string) => a.includes(b)\n    )\n);\nexport const Length = new NodeDescription(\n  'logic/length/string',\n  'Logic',\n  'Length',\n  (description, graph) =>\n    new In1Out1FuncNode(\n      description,\n      graph,\n      ['string'],\n      'integer',\n      (a: string) => BigInt(a.length)\n    )\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/string',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['string', 'string'],\n      'boolean',\n      (a: string, b: string) => a === b\n    )\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\n\nexport const StringValue = new ValueType(\n  'string',\n  () => '',\n  (value: string) => value,\n  (value: string) => value\n);\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// based on Unreal Engine Blueprint DoN node\n\nexport class DoN extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/doN',\n    'Flow',\n    'DoN',\n    (description, graph) => new DoN(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('integer', 'n', 1),\n        new Socket('flow', 'reset')\n      ],\n      [new Socket('flow', 'flow'), new Socket('integer', 'count')]\n    );\n  }\n\n  private count = 0;\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    if (triggeringSocketName === 'reset') {\n      this.count = 0;\n      return;\n    }\n    if (triggeringSocketName === 'flow') {\n      if (this.count < Number(this.readInput<bigint>('n'))) {\n        this.writeOutput('count', this.count);\n        this.count++;\n        fiber.commit(this, 'flow');\n      }\n      return;\n    }\n    throw new Error('should not get here');\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// based on Unreal Engine Blueprint DoN node\n\nexport class DoOnce extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/doOnce',\n    'Flow',\n    'DoOnce',\n    (description, graph) => new DoOnce(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [new Socket('flow', 'flow'), new Socket('flow', 'reset')],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  private firedOnce = false;\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    if (triggeringSocketName === 'reset') {\n      this.firedOnce = false;\n      return;\n    }\n    if (triggeringSocketName === 'flow') {\n      if (!this.firedOnce) {\n        this.firedOnce = true;\n        fiber.commit(this, 'flow');\n      }\n      return;\n    }\n    throw new Error('should not get here');\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// based on Unreal Engine Blueprint Gate node\n\nexport class Gate extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/gate',\n    'Flow',\n    'Gate',\n    (description, graph) => new Gate(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('flow', 'open'),\n        new Socket('flow', 'close'),\n        new Socket('flow', 'toggle'),\n        new Socket('boolean', 'startClosed', true)\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  private isInitialized = false;\n  private isClosed = true;\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    if (!this.isInitialized) {\n      this.isClosed = this.readInput<boolean>('startClosed');\n      this.isInitialized = true;\n    }\n\n    switch (triggeringSocketName) {\n      case 'flow': {\n        if (!this.isClosed) {\n          fiber.commit(this, 'flow');\n        }\n        break;\n      }\n      case 'open': {\n        this.isClosed = false;\n        return;\n      }\n      case 'close': {\n        this.isClosed = true;\n        return;\n      }\n      case 'toggle': {\n        this.isClosed = !this.isClosed;\n        return;\n      }\n      default:\n        new Error('should not get here');\n    }\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/\n\nexport class MultiGate extends FlowNode {\n  public static Description = new NodeDescription(\n    'flow/multiGate',\n    'Flow',\n    'MultiGate',\n    (description, graph) => new MultiGate(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('flow', 'reset'),\n        new Socket('boolean', 'loop', true),\n        new Socket('integer', 'startIndex', 0)\n      ],\n      [\n        new Socket('flow', '1'),\n        new Socket('flow', '2'),\n        new Socket('flow', '3')\n      ]\n    );\n  }\n\n  private isInitialized = false;\n  private nextIndex = 0;\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    if (!this.isInitialized) {\n      this.nextIndex = Number(this.readInput('startIndex'));\n    }\n\n    if (this.readInput<boolean>('loop')) {\n      this.nextIndex = this.nextIndex % this.outputSockets.length;\n    }\n\n    switch (triggeringSocketName) {\n      case 'reset': {\n        this.nextIndex = 0;\n        return;\n      }\n      case 'flow': {\n        if (0 <= this.nextIndex && this.nextIndex < this.outputSockets.length) {\n          fiber.commit(this, this.outputSockets[this.nextIndex].name);\n        }\n        this.nextIndex++;\n        return;\n      }\n    }\n    // these outputs are fired sequentially in an sync fashion but without delays.\n    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.\n    const sequenceIteration = (i: number) => {\n      if (i < this.outputSockets.length) {\n        const outputSocket = this.outputSockets[i];\n        fiber.commit(this, outputSocket.name, () => {\n          sequenceIteration(i + 1);\n        });\n      }\n    };\n    sequenceIteration(0);\n  }\n}\n", "import { Assert } from '../../../Diagnostics/Assert.js';\nimport { Engine } from '../../../Execution/Engine.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { AsyncNode } from '../../../Nodes/AsyncNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// based on the description here: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/\n\nexport class Throttle extends AsyncNode {\n  public static Description = new NodeDescription(\n    'flow/throttle',\n    'Flow',\n    'Throttle',\n    (description, graph) => new Throttle(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('float', 'duration', 1),\n        new Socket('flow', 'cancel')\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  private triggerVersion = 0;\n  private timeoutPending = false;\n\n  triggered(\n    engine: Engine,\n    triggeringSocketName: string,\n    finished: () => void\n  ) {\n    // if cancelling, just increment triggerVersion and do not set a timer. :)\n    if (triggeringSocketName === 'cancel') {\n      if (this.timeoutPending) {\n        this.triggerVersion++;\n        this.timeoutPending = false;\n      }\n      return;\n    }\n\n    // if there is a valid timeout running, leave it.\n    if (this.timeoutPending) {\n      return;\n    }\n\n    // otherwise start it.\n    this.triggerVersion++;\n    const localTriggerCount = this.triggerVersion;\n    this.timeoutPending = true;\n    setTimeout(() => {\n      if (this.triggerVersion !== localTriggerCount) {\n        return;\n      }\n      Assert.mustBeTrue(this.timeoutPending);\n      this.timeoutPending = false;\n      engine.commitToNewFiber(this, 'flow');\n      finished();\n    }, this.readInput<number>('duration') * 1000);\n  }\n\n  dispose() {\n    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.\n    this.timeoutPending = false;\n  }\n}\n", "export function toCamelCase(text: string): string {\n  if (text.length > 0) {\n    return text.at(0)?.toLocaleUpperCase() + text.slice(1);\n  }\n  return text;\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { NodeDescription } from '../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../Nodes/Templates/In1Out1FuncNode.js';\nimport { Registry } from '../../Registry.js';\nimport { toCamelCase } from '../../toCamelCase.js';\n\nexport function registerSerializersForValueType(\n  registry: Registry,\n  valueTypeName: string\n) {\n  const camelCaseValueTypeName = toCamelCase(valueTypeName);\n  registry.nodes.register(\n    new NodeDescription(\n      `math/to${camelCaseValueTypeName}/string`,\n      'Logic',\n      `To ${camelCaseValueTypeName}`,\n      (graph, nodeType) =>\n        new In1Out1FuncNode<string, any>(\n          graph,\n          nodeType,\n          ['string'],\n          valueTypeName,\n          (a: string) => registry.values.get(valueTypeName).deserialize(a)\n        )\n    ),\n    new NodeDescription(\n      `math/toString/${valueTypeName}`,\n      'Logic',\n      'To String',\n      (graph, nodeType) =>\n        new In1Out1FuncNode<any, string>(\n          graph,\n          nodeType,\n          [valueTypeName],\n          'string',\n          (a: any) => registry.values.get(valueTypeName).serialize(a)\n        )\n    )\n  );\n}\n", "/* eslint-disable max-len */\nimport { getNodeDescriptions } from '../../Nodes/Registry/NodeDescription.js';\nimport { Registry } from '../../Registry.js';\nimport { DefaultLogger } from './Abstractions/Drivers/DefaultLogger.js';\nimport { ManualLifecycleEventEmitter } from './Abstractions/Drivers/ManualLifecycleEventEmitter.js';\nimport { ILifecycleEventEmitter } from './Abstractions/ILifecycleEventEmitter.js';\nimport { ILogger } from './Abstractions/ILogger.js';\nimport { ExpectTrue as AssertExpectTrue } from './Debug/AssertExpectTrue.js';\nimport { Log as DebugLog } from './Debug/DebugLog.js';\nimport { Branch } from './Flow/Branch.js';\nimport { Debounce } from './Flow/Debounce.js';\nimport { Delay } from './Flow/Delay.js';\nimport { DoN } from './Flow/DoN.js';\nimport { DoOnce } from './Flow/DoOnce.js';\nimport { FlipFlop } from './Flow/FlipFlop.js';\nimport { ForLoop } from './Flow/ForLoop.js';\nimport { Gate } from './Flow/Gate.js';\nimport { MultiGate } from './Flow/MultieGate.js';\nimport { Sequence } from './Flow/Sequence.js';\nimport { Throttle } from './Flow/Throttle.js';\nimport { LifecycleOnEnd } from './Lifecycle/LifecycleOnEnd.js';\nimport { LifecycleOnStart } from './Lifecycle/LifecycleOnStart.js';\nimport { LifecycleOnTick } from './Lifecycle/LifecycleOnTick.js';\nimport { registerSerializersForValueType } from './registerSerializersForValueType.js';\nimport * as BooleanNodes from './Values/BooleanNodes.js';\nimport { BooleanValue } from './Values/BooleanValue.js';\nimport * as FloatNodes from './Values/FloatNodes.js';\nimport { FloatValue } from './Values/FloatValue.js';\nimport * as IntegerNodes from './Values/IntegerNodes.js';\nimport { IntegerValue } from './Values/IntegerValue.js';\nimport * as StringNodes from './Values/StringNodes.js';\nimport { StringValue } from './Values/StringValue.js';\n\nexport function registerCoreProfile(\n  registry: Registry,\n  logger: ILogger = new DefaultLogger(),\n  lifecycleEventEmitter: ILifecycleEventEmitter = new ManualLifecycleEventEmitter()\n) {\n  const { nodes, values } = registry;\n\n  // pull in value type nodes\n  values.register(BooleanValue);\n  values.register(StringValue);\n  values.register(IntegerValue);\n  values.register(FloatValue);\n\n  // pull in value type nodes\n  nodes.register(...getNodeDescriptions(StringNodes));\n  nodes.register(...getNodeDescriptions(BooleanNodes));\n  nodes.register(...getNodeDescriptions(IntegerNodes));\n  nodes.register(...getNodeDescriptions(FloatNodes));\n\n  // actions\n\n  nodes.register(DebugLog.Description(logger));\n  nodes.register(AssertExpectTrue.Description);\n\n  // events\n\n  nodes.register(LifecycleOnStart.Description(lifecycleEventEmitter));\n  nodes.register(LifecycleOnEnd.Description(lifecycleEventEmitter));\n  nodes.register(LifecycleOnTick.Description(lifecycleEventEmitter));\n\n  // flow control\n\n  nodes.register(Branch.Description);\n  nodes.register(FlipFlop.Description);\n  nodes.register(ForLoop.Description);\n  nodes.register(Sequence.Description);\n  nodes.register(Delay.Description);\n  nodes.register(Debounce.Description);\n  nodes.register(Throttle.Description);\n  nodes.register(DoN.Description);\n  nodes.register(DoOnce.Description);\n  nodes.register(Gate.Description);\n  nodes.register(MultiGate.Description);\n\n  // string converters\n\n  ['boolean', 'float', 'integer'].forEach((valueTypeName) => {\n    registerSerializersForValueType(registry, valueTypeName);\n  });\n\n  return registry;\n}\n", "import { parseSafeFloats } from '../../../../parseFloats.js';\n\nexport type Vec3JSON = { x: number; y: number; z: number };\nexport type ColorJSON = { r: number; g: number; b: number };\n\nexport class Vec3 {\n  constructor(\n    public x: number = 0,\n    public y: number = 0,\n    public z: number = 0\n  ) {}\n\n  clone(optionalResult = new Vec3()): Vec3 {\n    return optionalResult.set(this.x, this.y, this.z);\n  }\n\n  set(x: number, y: number, z: number): this {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n}\n\nexport function vec3Equals(a: Vec3, b: Vec3): boolean {\n  return a.x === b.x && a.y === b.y && a.z === b.z;\n}\nexport function vec3Add(a: Vec3, b: Vec3, optionalResult = new Vec3()): Vec3 {\n  return optionalResult.set(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nexport function vec3Subtract(\n  a: Vec3,\n  b: Vec3,\n  optionalResult = new Vec3()\n): Vec3 {\n  return optionalResult.set(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nexport function vec3Scale(\n  a: Vec3,\n  b: number,\n  optionalResult = new Vec3()\n): Vec3 {\n  return optionalResult.set(a.x * b, a.y * b, a.z * b);\n}\nexport function vec3Negate(a: Vec3, optionalResult = new Vec3()): Vec3 {\n  return optionalResult.set(-a.x, -a.y, -a.z);\n}\nexport function vec3Length(a: Vec3): number {\n  return Math.sqrt(vec3Dot(a, a));\n}\nexport function vec3Normalize(a: Vec3, optionalResult = new Vec3()): Vec3 {\n  const invLength = 1 / vec3Length(a);\n  return vec3Scale(a, invLength, optionalResult);\n}\nexport function vec3Dot(a: Vec3, b: Vec3): number {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\nexport function vec3Cross(a: Vec3, b: Vec3, optionalResult = new Vec3()): Vec3 {\n  const ax = a.x;\n  const ay = a.y;\n  const az = a.z;\n  const bx = b.x;\n  const by = b.y;\n  const bz = b.z;\n\n  return optionalResult.set(\n    ay * bz - az * by,\n    az * bx - ax * bz,\n    ax * by - ay * bx\n  );\n}\nexport function vec3Mix(\n  a: Vec3,\n  b: Vec3,\n  t: number,\n  optionalResult = new Vec3()\n): Vec3 {\n  const s = 1 - t;\n  return optionalResult.set(\n    a.x * s + b.x * t,\n    a.y * s + b.y * t,\n    a.z * s + b.z * t\n  );\n}\nexport function vec3FromArray(\n  array: Float32Array | number[],\n  offset = 0,\n  optionalResult = new Vec3()\n): Vec3 {\n  return optionalResult.set(\n    array[offset + 0],\n    array[offset + 1],\n    array[offset + 2]\n  );\n}\nexport function vec3ToArray(\n  a: Vec3,\n  array: Float32Array | number[],\n  offset = 0\n): void {\n  array[offset + 0] = a.x;\n  array[offset + 1] = a.y;\n  array[offset + 2] = a.z;\n}\nexport function vec3ToString(a: Vec3): string {\n  return `(${a.x}, ${a.y}, ${a.z})`;\n}\nexport function vec3Parse(text: string, optionalResult = new Vec3()): Vec3 {\n  return vec3FromArray(parseSafeFloats(text), 0, optionalResult);\n}\n\nexport function hslToRGB(hsl: Vec3, optionalResult = new Vec3()): Vec3 {\n  function hue2rgb(p: number, q: number, t: number): number {\n    if (t < 0) {\n      t += 1;\n    }\n    if (t > 1) {\n      t -= 1;\n    }\n    if (t < 1 / 6) {\n      return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n      return q;\n    }\n    if (t < 2 / 3) {\n      return p + (q - p) * 6 * (2 / 3 - t);\n    }\n\n    return p;\n  }\n\n  // h,s,l ranges are in 0.0 - 1.0\n  const h = ((hsl.x % 1) + 1) % 1; // euclidean modulo\n  const s = Math.min(Math.max(hsl.y, 0), 1);\n  const l = Math.min(Math.max(hsl.z, 0), 1);\n\n  if (s === 0) {\n    return optionalResult.set(1, 1, 1);\n  }\n\n  const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n  const q = 2 * l - p;\n\n  return optionalResult.set(\n    hue2rgb(q, p, h + 1 / 3),\n    hue2rgb(q, p, h),\n    hue2rgb(q, p, h - 1 / 3)\n  );\n}\n\nexport function rgbToHSL(rgb: Vec3, optionalResult = new Vec3()): Vec3 {\n  // h,s,l ranges are in 0.0 - 1.0\n  const r = rgb.x,\n    g = rgb.y,\n    b = rgb.z;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n\n  let hue = 0;\n  let saturation = 0;\n  const lightness = (min + max) / 2;\n\n  if (min === max) {\n    hue = 0;\n    saturation = 0;\n  } else {\n    const delta = max - min;\n\n    saturation =\n      lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n    switch (max) {\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n      case g:\n        hue = (b - r) / delta + 2;\n        break;\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n\n    hue /= 6;\n  }\n\n  return optionalResult.set(hue, saturation, lightness);\n}\n\nexport function hexToRGB(hex: number, optionalResult = new Vec3()): Vec3 {\n  hex = Math.floor(hex);\n  return optionalResult.set(\n    ((hex >> 16) & 255) / 255,\n    ((hex >> 8) & 255) / 255,\n    (hex & 255) / 255\n  );\n}\n\nexport function rgbToHex(rgb: Vec3): number {\n  return ((rgb.x * 255) << 16) ^ ((rgb.y * 255) << 8) ^ ((rgb.z * 255) << 0);\n}\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { ColorJSON, Vec3, vec3Parse } from './Internal/Vec3.js';\n\nexport const ColorValue = new ValueType(\n  'color',\n  () => new Vec3(),\n  (value: string | ColorJSON) =>\n    typeof value === 'string'\n      ? vec3Parse(value)\n      : new Vec3(value.r, value.g, value.b),\n  (value) => ({ r: value.x, g: value.y, b: value.z } as ColorJSON)\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { Vec3, Vec3JSON, vec3Parse } from './Internal/Vec3.js';\n\nexport const EulerValue = new ValueType(\n  'euler',\n  () => new Vec3(),\n  (value: string | Vec3JSON) =>\n    typeof value === 'string'\n      ? vec3Parse(value)\n      : new Vec3(value.x, value.y, value.z),\n  (value) => ({ x: value.x, y: value.y, z: value.z } as Vec3JSON)\n);\n", "import { parseSafeFloats } from '../../../../parseFloats.js';\nimport { Vec3 } from './Vec3.js';\n\nexport type Vec4JSON = { x: number; y: number; z: number; w: number };\n\nexport class Vec4 {\n  constructor(\n    public x: number = 0,\n    public y: number = 0,\n    public z: number = 0,\n    public w: number = 0\n  ) {}\n  clone(optionalResult = new Vec4()): Vec4 {\n    return optionalResult.set(this.x, this.y, this.z, this.w);\n  }\n  set(x: number, y: number, z: number, w: number): this {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n}\nexport function vec4Equals(a: Vec4, b: Vec4): boolean {\n  return a.x === b.x && a.y === b.y && a.z === b.z && a.w == b.w;\n}\nexport function vec4Add(a: Vec4, b: Vec4, optionalResult = new Vec4()): Vec4 {\n  return optionalResult.set(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);\n}\nexport function vec4Subtract(\n  a: Vec4,\n  b: Vec4,\n  optionalResult = new Vec4()\n): Vec4 {\n  return optionalResult.set(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);\n}\nexport function vec4Scale(\n  a: Vec4,\n  b: number,\n  optionalResult = new Vec4()\n): Vec4 {\n  return optionalResult.set(a.x * b, a.y * b, a.z * b, a.w * b);\n}\nexport function vec4Negate(a: Vec4, optionalResult = new Vec4()): Vec4 {\n  return optionalResult.set(-a.x, -a.y, -a.z, -a.w);\n}\nexport function vec4Length(a: Vec4): number {\n  return Math.sqrt(vec4Dot(a, a));\n}\nexport function vec4Normalize(a: Vec4, optionalResult = new Vec4()): Vec4 {\n  const invLength = 1 / vec4Length(a);\n  return vec4Scale(a, invLength, optionalResult);\n}\nexport function vec4Dot(a: Vec4, b: Vec4): number {\n  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n}\nexport function vec4Mix(\n  a: Vec4,\n  b: Vec4,\n  t: number,\n  optionalResult = new Vec4()\n): Vec4 {\n  const s = 1 - t;\n  return optionalResult.set(\n    a.x * s + b.x * t,\n    a.y * s + b.y * t,\n    a.z * s + b.z * t,\n    a.w * s + b.w * t\n  );\n}\nexport function vec4FromArray(\n  array: Float32Array | number[],\n  offset = 0,\n  optionalResult = new Vec4()\n): Vec4 {\n  return optionalResult.set(\n    array[offset + 0],\n    array[offset + 1],\n    array[offset + 2],\n    array[offset + 3]\n  );\n}\nexport function vec4ToArray(\n  a: Vec4,\n  array: Float32Array | number[],\n  offset = 0\n): void {\n  array[offset + 0] = a.x;\n  array[offset + 1] = a.y;\n  array[offset + 2] = a.z;\n  array[offset + 3] = a.w;\n}\nexport function vec4ToString(a: Vec4): string {\n  return `(${a.x}, ${a.y}, ${a.z}, ${a.w})`;\n}\nexport function vec4Parse(text: string, optionalResult = new Vec4()): Vec4 {\n  return vec4FromArray(parseSafeFloats(text), 0, optionalResult);\n}\nexport function quatConjugate(a: Vec4, optionalResult = new Vec4()): Vec4 {\n  return optionalResult.set(-a.x, -a.y, -a.z, a.w);\n}\nexport function quatMultiply(\n  a: Vec4,\n  b: Vec4,\n  optionalResult = new Vec4()\n): Vec4 {\n  // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n  const qax = a.x;\n  const qay = a.y;\n  const qaz = a.z;\n  const qaw = a.w;\n  const qbx = b.x;\n  const qby = b.y;\n  const qbz = b.z;\n  const qbw = b.w;\n\n  return optionalResult.set(\n    qax * qbw + qaw * qbx + qay * qbz - qaz * qby,\n    qay * qbw + qaw * qby + qaz * qbx - qax * qbz,\n    qaz * qbw + qaw * qbz + qax * qby - qay * qbx,\n    qaw * qbw - qax * qbx - qay * qby - qaz * qbz\n  );\n}\n\nexport function quatSlerp(\n  a: Vec4,\n  b: Vec4,\n  t: number,\n  optionalResult = new Vec4()\n): Vec4 {\n  if (t <= 0) return a.clone(optionalResult);\n  if (t >= 1) return b.clone(optionalResult);\n\n  // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n  let cosHalfTheta = vec4Dot(a, b);\n\n  if (cosHalfTheta < 0) {\n    vec4Negate(b, optionalResult);\n\n    cosHalfTheta = -cosHalfTheta;\n  } else {\n    b.clone(optionalResult);\n  }\n\n  if (cosHalfTheta >= 1) {\n    return optionalResult;\n  }\n\n  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n\n  if (sqrSinHalfTheta <= Number.EPSILON) {\n    vec4Mix(a, optionalResult, t);\n    vec4Normalize(optionalResult, optionalResult);\n\n    return optionalResult;\n  }\n\n  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;\n  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\n  optionalResult.w = a.w * ratioA + optionalResult.w * ratioB;\n  optionalResult.x = a.x * ratioA + optionalResult.x * ratioB;\n  optionalResult.y = a.y * ratioA + optionalResult.y * ratioB;\n  optionalResult.z = a.z * ratioA + optionalResult.z * ratioB;\n\n  return optionalResult;\n}\nexport function eulerToQuat(\n  euler: Vec3,\n  optionalResult: Vec4 = new Vec4()\n): Vec4 {\n  // eslint-disable-next-line max-len\n  // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\n  const c1 = Math.cos(euler.x / 2);\n  const c2 = Math.cos(euler.y / 2);\n  const c3 = Math.cos(euler.z / 2);\n\n  const s1 = Math.sin(euler.x / 2);\n  const s2 = Math.sin(euler.y / 2);\n  const s3 = Math.sin(euler.z / 2);\n\n  // XYZ order only\n  return optionalResult.set(\n    s1 * c2 * c3 + c1 * s2 * s3,\n    c1 * s2 * c3 - s1 * c2 * s3,\n    c1 * c2 * s3 + s1 * s2 * c3,\n    c1 * c2 * c3 - s1 * s2 * s3\n  );\n}\n\nexport function angleAxisToQuat(\n  angle: number,\n  axis: Vec3,\n  optionalResult = new Vec4()\n): Vec4 {\n  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n  // assumes axis is normalized\n\n  const halfAngle = angle / 2;\n  const s = Math.sin(halfAngle);\n\n  return optionalResult.set(\n    axis.x * s,\n    axis.y * s,\n    axis.z * s,\n    Math.cos(halfAngle)\n  );\n}\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { Vec4, Vec4JSON, vec4Parse } from './Internal/Vec4.js';\n\nexport const QuatValue = new ValueType(\n  'quat',\n  () => new Vec4(),\n  (value: string | Vec4JSON) =>\n    typeof value === 'string'\n      ? vec4Parse(value)\n      : new Vec4(value.x, value.y, value.z, value.w),\n  (value) => ({ x: value.x, y: value.y, z: value.z, w: value.w } as Vec4JSON)\n);\n", "import { parseSafeFloats } from '../../../../parseFloats.js';\n\nexport type Vec2JSON = { x: number; y: number };\n\nexport class Vec2 {\n  constructor(public x: number = 0, public y: number = 0) {}\n\n  clone(optionalResult = new Vec2()): Vec2 {\n    return optionalResult.set(this.x, this.y);\n  }\n  set(x: number, y: number): this {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n}\n\nexport function vec2Equals(a: Vec2, b: Vec2): boolean {\n  return a.x === b.x && a.y === b.y;\n}\nexport function vec2Add(\n  a: Vec2,\n  b: Vec2,\n  optionalResult: Vec2 = new Vec2()\n): Vec2 {\n  return optionalResult.set(a.x + b.x, a.y + b.y);\n}\nexport function vec2Subtract(\n  a: Vec2,\n  b: Vec2,\n  optionalResult: Vec2 = new Vec2()\n): Vec2 {\n  return optionalResult.set(a.x - b.x, a.y - b.y);\n}\nexport function vec2Scale(\n  a: Vec2,\n  b: number,\n  optionalResult: Vec2 = new Vec2()\n): Vec2 {\n  return optionalResult.set(a.x * b, a.y * b);\n}\nexport function vec2Negate(a: Vec2, optionalResult: Vec2 = new Vec2()): Vec2 {\n  return optionalResult.set(-a.x, -a.y);\n}\nexport function vec2Length(a: Vec2): number {\n  return Math.sqrt(vec2Dot(a, a));\n}\nexport function vec2Normalize(\n  a: Vec2,\n  optionalResult: Vec2 = new Vec2()\n): Vec2 {\n  const invLength = 1 / vec2Length(a);\n  return vec2Scale(a, invLength, optionalResult);\n}\nexport function vec2Dot(a: Vec2, b: Vec2): number {\n  return a.x * b.x + a.y * b.y;\n}\nexport function vec2Mix(\n  a: Vec2,\n  b: Vec2,\n  t: number,\n  optionalResult = new Vec2()\n): Vec2 {\n  const s = 1 - t;\n  return optionalResult.set(a.x * s + b.x * t, a.y * s + b.y * t);\n}\nexport function vec2FromArray(\n  array: Float32Array | number[],\n  offset = 0,\n  optionalResult: Vec2 = new Vec2()\n): Vec2 {\n  return optionalResult.set(array[offset + 0], array[offset + 1]);\n}\nexport function vec2ToArray(\n  a: Vec2,\n  array: Float32Array | number[],\n  offset = 0\n): void {\n  array[offset + 0] = a.x;\n  array[offset + 1] = a.y;\n}\n\nexport function vec2ToString(a: Vec2): string {\n  return `(${a.x}, ${a.y})`;\n}\nexport function vec2Parse(text: string, optionalResult = new Vec2()): Vec2 {\n  return vec2FromArray(parseSafeFloats(text), 0, optionalResult);\n}\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { Vec2, Vec2JSON, vec2Parse } from './Internal/Vec2.js';\n\nexport const Vec2Value = new ValueType(\n  'vec2',\n  () => new Vec2(),\n  (value: string | Vec2JSON) =>\n    typeof value === 'string' ? vec2Parse(value) : new Vec2(value.x, value.y),\n  (value) => ({ x: value.x, y: value.y } as Vec2JSON)\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { Vec3, Vec3JSON, vec3Parse } from './Internal/Vec3.js';\n\nexport const Vec3Value = new ValueType(\n  'vec3',\n  () => new Vec3(),\n  (value: string | Vec3JSON) =>\n    typeof value === 'string'\n      ? vec3Parse(value)\n      : new Vec3(value.x, value.y, value.z),\n  (value) => ({ x: value.x, y: value.y, z: value.z } as Vec3JSON)\n);\n", "import { ValueType } from '../../../Values/ValueType.js';\nimport { Vec4, Vec4JSON, vec4Parse } from './Internal/Vec4.js';\n\nexport const Vec4Value = new ValueType(\n  'vec4',\n  () => new Vec4(),\n  (value: string | Vec4JSON) =>\n    typeof value === 'string'\n      ? vec4Parse(value)\n      : new Vec4(value.x, value.y, value.z, value.w),\n  (value) => ({ x: value.x, y: value.y, z: value.z, w: value.w } as Vec4JSON)\n);\n", "import { EventEmitter } from '../../../../Events/EventEmitter.js';\nimport { ValueTypeRegistry } from '../../../../Values/ValueTypeRegistry.js';\nimport { BooleanValue } from '../../../Core/Values/BooleanValue.js';\nimport { FloatValue } from '../../../Core/Values/FloatValue.js';\nimport { IntegerValue } from '../../../Core/Values/IntegerValue.js';\nimport { StringValue } from '../../../Core/Values/StringValue.js';\nimport { ColorValue } from '../../Values/ColorValue.js';\nimport { EulerValue } from '../../Values/EulerValue.js';\nimport { QuatValue } from '../../Values/QuatValue.js';\nimport { Vec2Value } from '../../Values/Vec2Value.js';\nimport { Vec3Value } from '../../Values/Vec3Value.js';\nimport { Vec4Value } from '../../Values/Vec4Value.js';\nimport { IScene } from '../IScene.js';\n\nexport class DummyScene implements IScene {\n  public onSceneChanged = new EventEmitter<void>();\n  private valueRegistry = new ValueTypeRegistry();\n\n  constructor() {\n    const values = this.valueRegistry;\n    // pull in value type nodes\n    values.register(BooleanValue);\n    values.register(StringValue);\n    values.register(IntegerValue);\n    values.register(FloatValue);\n    values.register(Vec2Value);\n    values.register(Vec3Value);\n    values.register(Vec4Value);\n    values.register(ColorValue);\n    values.register(EulerValue);\n    values.register(QuatValue);\n  }\n\n  getProperty(jsonPath: string, valueTypeName: string): any {\n    return this.valueRegistry.get(valueTypeName).creator();\n  }\n  setProperty(): void {\n    this.onSceneChanged.emit();\n  }\n  addOnClickedListener(\n    jsonPath: string,\n    callback: (jsonPath: string) => void\n  ): void {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import { Fiber } from '../../../Execution/Fiber.js';\nimport { Graph } from '../../../Graphs/Graph.js';\nimport { FlowNode } from '../../../Nodes/FlowNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { toCamelCase } from '../../../toCamelCase.js';\nimport { IScene } from '../Abstractions/IScene.js';\n\nexport class SetSceneProperty extends FlowNode {\n  public static GetDescriptions(scene: IScene, ...valueTypeNames: string[]) {\n    return valueTypeNames.map(\n      (valueTypeName) =>\n        new NodeDescription(\n          `scene/set/${valueTypeName}`,\n          'Action',\n          `Set Scene ${toCamelCase(valueTypeName)}`,\n          (description, graph) =>\n            new SetSceneProperty(description, graph, valueTypeName, scene)\n        )\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly valueTypeName: string,\n    private readonly scene: IScene\n  ) {\n    super(\n      description,\n      graph,\n      [\n        new Socket('flow', 'flow'),\n        new Socket('string', 'jsonPath'),\n        new Socket(valueTypeName, 'value')\n      ],\n      [new Socket('flow', 'flow')]\n    );\n  }\n\n  triggered(fiber: Fiber, triggeringSocketName: string) {\n    const scene = this.scene;\n    const value = this.readInput('value');\n    scene.setProperty(this.readInput('jsonPath'), this.valueTypeName, value);\n    fiber.commit(this, 'flow');\n  }\n}\n", "import { Graph } from '../../../Graphs/Graph.js';\nimport { EventNode } from '../../../Nodes/EventNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\n// very 3D specific.\nexport class OnSceneNodeClick extends EventNode {\n  public static Description = new NodeDescription(\n    'scene/nodeClick',\n    'Event',\n    'On Node Click',\n    (description, graph) => new OnSceneNodeClick(description, graph)\n  );\n\n  constructor(description: NodeDescription, graph: Graph) {\n    super(\n      description,\n      graph,\n      [],\n      [new Socket('flow', 'flow'), new Socket('float', 'nodeIndex')]\n    );\n  }\n}\n", "import { Graph } from '../../../Graphs/Graph.js';\nimport { ImmediateNode } from '../../../Nodes/ImmediateNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\n\nexport class VecElements<T> extends ImmediateNode {\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    valueTypeName: string,\n    elementNames: string[] = ['x', 'y', 'z', 'w'],\n    toArray: (value: T, array: number[], offset: number) => void\n  ) {\n    super(\n      description,\n      graph,\n      [new Socket(valueTypeName, 'value')],\n      elementNames.map((elementName) => new Socket('float', elementName)),\n      () => {\n        const value = this.readInput('value') as T;\n        const elementValues = elementNames.map(() => 0);\n        toArray(value, elementValues, 0);\n        elementNames.forEach((elementName, index) =>\n          this.writeOutput(elementName, elementValues[index])\n        );\n      }\n    );\n  }\n}\n", "import { Graph } from '../../../Graphs/Graph.js';\nimport { ImmediateNode } from '../../../Nodes/ImmediateNode.js';\nimport { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { Socket } from '../../../Sockets/Socket.js';\nimport { toCamelCase } from '../../../toCamelCase.js';\nimport { IScene } from '../Abstractions/IScene.js';\n\nexport class GetSceneProperty extends ImmediateNode {\n  public static GetDescriptions(scene: IScene, ...valueTypeNames: string[]) {\n    return valueTypeNames.map(\n      (valueTypeName) =>\n        new NodeDescription(\n          `scene/get/${valueTypeName}`,\n          'Query',\n          `Get Scene ${toCamelCase(valueTypeName)}`,\n          (description, graph) =>\n            new GetSceneProperty(description, graph, valueTypeName, scene)\n        )\n    );\n  }\n\n  constructor(\n    description: NodeDescription,\n    graph: Graph,\n    public readonly valueTypeName: string,\n    private readonly scene: IScene\n  ) {\n    super(\n      description,\n      graph,\n      [new Socket('string', 'jsonPath')],\n      [new Socket(valueTypeName, 'value')],\n      () => {\n        this.writeOutput(\n          'value',\n          this.scene.getProperty(this.readInput('jsonPath'), valueTypeName)\n        );\n      }\n    );\n  }\n}\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  hexToRGB,\n  hslToRGB,\n  rgbToHex,\n  rgbToHSL,\n  Vec3,\n  vec3Add,\n  vec3Equals,\n  vec3Mix,\n  vec3Negate,\n  vec3Scale,\n  vec3Subtract,\n  vec3ToArray\n} from './Internal/Vec3.js';\n\nexport const Constant = new NodeDescription(\n  'math/color',\n  'Logic',\n  'Color',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['color'], 'color', (a: Vec3) => a)\n);\nexport const Create = new NodeDescription(\n  'math/toColor/rgb',\n  'Logic',\n  'RGB To Color',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float'],\n      'color',\n      (r: number, g: number, b: number) => new Vec3(r, g, b),\n      ['r', 'g', 'b']\n    )\n);\n\nexport const Elements = new NodeDescription(\n  'math/toRgb/color',\n  'Logic',\n  'Color to RGB',\n  (description, graph) =>\n    new VecElements(description, graph, 'color', ['r', 'g', 'b'], vec3ToArray)\n);\n\nexport const Add = new NodeDescription(\n  'math/add/color',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['color', 'color'],\n      'color',\n      vec3Add\n    )\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/color',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['color', 'color'],\n      'color',\n      vec3Subtract\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/color',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['color'], 'color', vec3Negate)\n);\n\nexport const Scale = new NodeDescription(\n  'math/scale/color',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['color', 'float'],\n      'color',\n      vec3Scale\n    )\n);\n\nexport const Mix = new NodeDescription(\n  'math/mix/color',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['color', 'color', 'float'],\n      'color',\n      vec3Mix,\n      ['a', 'b', 't']\n    )\n);\n\nexport const HslToColor = new NodeDescription(\n  'math/ToColor/hsl',\n  'Logic',\n  'HSL to Color',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec3'], 'color', hslToRGB)\n);\nexport const ColorToHsl = new NodeDescription(\n  'math/toHsl/color',\n  'Logic',\n  'Color to HSL',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['color'], 'vec3', rgbToHSL)\n);\n\nexport const HexToColor = new NodeDescription(\n  'math/toColor/hex',\n  'Logic',\n  'HEX to Color',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['float'], 'color', hexToRGB)\n);\nexport const ColorToHex = new NodeDescription(\n  'math/toHex/color',\n  'Logic',\n  'Color to HEX',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['color'], 'float', rgbToHex)\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/color',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['color', 'color'],\n      'boolean',\n      vec3Equals\n    )\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  Vec3,\n  vec3Add,\n  vec3Equals,\n  vec3Mix,\n  vec3Negate,\n  vec3Scale,\n  vec3Subtract,\n  vec3ToArray\n} from './Internal/Vec3.js';\nimport { eulerToQuat } from './Internal/Vec4.js';\n\nexport const Constant = new NodeDescription(\n  'math/euler',\n  'Logic',\n  'Euler',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['euler'], 'euler', (a: Vec3) => a)\n);\nexport const Create = new NodeDescription(\n  'math/toEuler/float',\n  'Logic',\n  'Float to Euler',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float'],\n      'euler',\n      (x: number, y: number, z: number) => new Vec3(x, y, z),\n      ['x', 'y', 'z']\n    )\n);\n\nexport const Elements = new NodeDescription(\n  'math/toFloat/euler',\n  'Logic',\n  'Euler to Float',\n  (description, graph) =>\n    new VecElements(description, graph, 'euler', ['x', 'y', 'z'], vec3ToArray)\n);\n\nexport const Add = new NodeDescription(\n  'math/add/euler',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['euler', 'euler'],\n      'euler',\n      vec3Add\n    )\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/euler',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['euler', 'euler'],\n      'euler',\n      vec3Subtract\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/euler',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['euler'], 'euler', vec3Negate)\n);\n\nexport const Scale = new NodeDescription(\n  'math/scale/euler',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['euler', 'float'],\n      'euler',\n      vec3Scale\n    )\n);\n\nexport const Mix = new NodeDescription(\n  'math/mix/euler',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['euler', 'euler', 'float'],\n      'euler',\n      vec3Mix,\n      ['a', 'b', 't']\n    )\n);\n\nexport const toQuat = new NodeDescription(\n  'math/toQuat/euler',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['euler'], 'quat', eulerToQuat)\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/euler',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['euler', 'euler'],\n      'boolean',\n      vec3Equals\n    )\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  Vec2,\n  vec2Add,\n  vec2Dot,\n  vec2Equals,\n  vec2Length,\n  vec2Mix,\n  vec2Negate,\n  vec2Normalize,\n  vec2Scale,\n  vec2Subtract,\n  vec2ToArray\n} from './Internal/Vec2.js';\n\nexport const Constant = new NodeDescription(\n  'math/vec2',\n  'Logic',\n  'Vec2',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', (a: Vec2) => a)\n);\n\nexport const Create = new NodeDescription(\n  'math/toVec2/float',\n  'Logic',\n  'Float to Vec2',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float'],\n      'vec2',\n      (x: number, y: number) => new Vec2(x, y),\n      ['x', 'y']\n    )\n);\nexport const Elements = new NodeDescription(\n  'math/toFloat/vec2',\n  'Logic',\n  'Vec2 To Float',\n  (description, graph) =>\n    new VecElements(description, graph, 'vec2', ['x', 'y', 'z'], vec2ToArray)\n);\n\nexport const Add = new NodeDescription(\n  'math/add/vec2',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Add)\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/vec2',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec2', 'vec2'],\n      'vec2',\n      vec2Subtract\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/vec2',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Negate)\n);\n\nexport const Scale = new NodeDescription(\n  'math/scale/vec2',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec2', 'float'],\n      'vec2',\n      vec2Scale\n    )\n);\nexport const Length = new NodeDescription(\n  'math/length/vec2',\n  'Logic',\n  'Length',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec2'], 'float', vec2Length)\n);\nexport const Normalize = new NodeDescription(\n  'math/normalize/vec2',\n  'Logic',\n  'Normalize',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Normalize)\n);\nexport const Dot = new NodeDescription(\n  'math/dot/vec2',\n  'Logic',\n  'Dot Product',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'float', vec2Dot)\n);\n\nexport const Mix = new NodeDescription(\n  'math/mix/vec2',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['vec2', 'vec2', 'float'],\n      'vec2',\n      vec2Mix,\n      ['a', 'b', 't']\n    )\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/vec2',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec2', 'vec2'],\n      'boolean',\n      vec2Equals\n    )\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  Vec3,\n  vec3Add,\n  vec3Cross,\n  vec3Dot,\n  vec3Equals,\n  vec3Length,\n  vec3Mix,\n  vec3Negate,\n  vec3Normalize,\n  vec3Scale,\n  vec3Subtract,\n  vec3ToArray\n} from './Internal/Vec3.js';\n\nexport const Constant = new NodeDescription(\n  'math/vec3',\n  'Logic',\n  'Vec3',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', (a: Vec3) => a)\n);\n\nexport const Create = new NodeDescription(\n  'math/toVec3/float',\n  'Logic',\n  'Float to Vec3',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float'],\n      'vec3',\n      (x: number, y: number, z: number) => new Vec3(x, y, z),\n      ['x', 'y', 'z']\n    )\n);\n\nexport const Elements = new NodeDescription(\n  'math/toFloat/vec3',\n  'Logic',\n  'Vec3 To Float',\n  (description, graph) =>\n    new VecElements(description, graph, 'vec3', ['x', 'y', 'z'], vec3ToArray)\n);\n\nexport const Add = new NodeDescription(\n  'math/add/vec3',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Add)\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/vec3',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec3', 'vec3'],\n      'vec3',\n      vec3Subtract\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/vec3',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Negate)\n);\nexport const Scale = new NodeDescription(\n  'math/scale/vec3',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec3', 'float'],\n      'vec3',\n      vec3Scale\n    )\n);\nexport const Length = new NodeDescription(\n  'math/length/vec3',\n  'Logic',\n  'Length',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec3'], 'float', vec3Length)\n);\nexport const Normalize = new NodeDescription(\n  'math/normalize/vec3',\n  'Logic',\n  'Normalize',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Normalize)\n);\nexport const Cross = new NodeDescription(\n  'math/cross/vec3',\n  'Logic',\n  'Cross',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Cross)\n);\nexport const Dot = new NodeDescription(\n  'math/dot/vec3',\n  'Logic',\n  'Dot',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'float', vec3Dot)\n);\nexport const Mix = new NodeDescription(\n  'math/mix/vec3',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['vec3', 'vec3', 'float'],\n      'vec3',\n      vec3Mix,\n      ['a', 'b', 't']\n    )\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/vec3',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec3', 'vec3'],\n      'boolean',\n      vec3Equals\n    )\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { In4Out1FuncNode } from '../../../Nodes/Templates/In4Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  Vec4,\n  vec4Add,\n  vec4Dot,\n  vec4Equals,\n  vec4Length,\n  vec4Mix,\n  vec4Negate,\n  vec4Normalize,\n  vec4Scale,\n  vec4Subtract,\n  vec4ToArray\n} from './Internal/Vec4.js';\n\nexport const Constant = new NodeDescription(\n  'math/vec4',\n  'Logic',\n  'Vec4',\n  (description, graph) =>\n    new In1Out1FuncNode<Vec4, Vec4>(\n      description,\n      graph,\n      ['vec4'],\n      'vec4',\n      (a) => a\n    )\n);\nexport const Create = new NodeDescription(\n  'math/toVec4/float',\n  'Logic',\n  'Float to Vec4',\n  (description, graph) =>\n    new In4Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float', 'float'],\n      'vec4',\n      (x: number, y: number, z: number, w: number) => new Vec4(x, y, z, w),\n      ['x', 'y', 'z', 'w']\n    )\n);\nexport const Elements = new NodeDescription(\n  'math/toFloat/vec4',\n  'Logic',\n  'Vec4 to Float',\n  (description, graph) =>\n    new VecElements(\n      description,\n      graph,\n      'vec4',\n      ['x', 'y', 'z', 'w'],\n      vec4ToArray\n    )\n);\nexport const Add = new NodeDescription(\n  'math/add/vec4',\n  'Logic',\n  '+',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Add)\n);\nexport const Subtract = new NodeDescription(\n  'math/subtract/vec4',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec4', 'vec4'],\n      'vec4',\n      vec4Subtract\n    )\n);\nexport const Negate = new NodeDescription(\n  'math/negate/vec4',\n  'Logic',\n  '-',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Negate)\n);\nexport const Scale = new NodeDescription(\n  'math/scale/vec4',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec4', 'float'],\n      'vec4',\n      vec4Scale\n    )\n);\nexport const Length = new NodeDescription(\n  'math/length/vec4',\n  'Logic',\n  'Length',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec4'], 'float', vec4Length)\n);\nexport const Normalize = new NodeDescription(\n  'math/normalize/vec4',\n  'Logic',\n  'Normalize',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Normalize)\n);\nexport const Dot = new NodeDescription(\n  'math/dot/vec4',\n  'Logic',\n  'Dot Product',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'float', vec4Dot)\n);\nexport const Mix = new NodeDescription(\n  'math/mix/vec4',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['vec4', 'vec4', 'float'],\n      'vec4',\n      vec4Mix,\n      ['a', 'b', 't']\n    )\n);\n\nexport const Equal = new NodeDescription(\n  'math/equal/vec4',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['vec4', 'vec4'],\n      'boolean',\n      vec4Equals\n    )\n);\n", "import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';\nimport { In1Out1FuncNode } from '../../../Nodes/Templates/In1Out1FuncNode.js';\nimport { In2Out1FuncNode } from '../../../Nodes/Templates/In2Out1FuncNode.js';\nimport { In3Out1FuncNode } from '../../../Nodes/Templates/In3Out1FuncNode.js';\nimport { In4Out1FuncNode } from '../../../Nodes/Templates/In4Out1FuncNode.js';\nimport { VecElements } from '../Logic/VecElements.js';\nimport {\n  angleAxisToQuat,\n  quatConjugate,\n  quatMultiply,\n  quatSlerp,\n  Vec4,\n  vec4Dot,\n  vec4Equals,\n  vec4Length,\n  vec4Normalize,\n  vec4Scale,\n  vec4ToArray\n} from './Internal/Vec4.js';\n\n/*\n- from Angle Axis\n- from Euler\n- to Angle Axis\n- to Euler\n- Conjugate\n- Multiply\n- Slerp\n- Squad\n- Scale\n- \n*/\n\nexport const Constant = new NodeDescription(\n  'math/quat',\n  'Logic',\n  'Quaternion',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['quat'], 'quat', (a: Vec4) => a)\n);\nexport const Create = new NodeDescription(\n  'math/toQuat/float',\n  'Logic',\n  'Float to Quat',\n  (description, graph) =>\n    new In4Out1FuncNode(\n      description,\n      graph,\n      ['float', 'float', 'float', 'float'],\n      'quat',\n      (x: number, y: number, z: number, w: number) => new Vec4(x, y, z, w),\n      ['x', 'y', 'z', 'w']\n    )\n);\nexport const Elements = new NodeDescription(\n  'math/toFloat/quat',\n  'Logic',\n  'Quat to Float',\n  (description, graph) =>\n    new VecElements(\n      description,\n      graph,\n      'quat',\n      ['x', 'y', 'z', 'w'],\n      vec4ToArray\n    )\n);\n\nexport const Negate = new NodeDescription(\n  'math/conjugate/quat',\n  'Logic',\n  'Conjugate',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatConjugate)\n);\n\nexport const Multiply = new NodeDescription(\n  'math/multiply/quat',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['quat', 'quat'],\n      'quat',\n      quatMultiply\n    )\n);\nexport const Scale = new NodeDescription(\n  'math/scale/quat',\n  'Logic',\n  '',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['quat', 'float'],\n      'quat',\n      vec4Scale\n    )\n);\nexport const Length = new NodeDescription(\n  'math/length/quat',\n  'Logic',\n  'Length',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['quat'], 'float', vec4Length)\n);\nexport const Normalize = new NodeDescription(\n  'math/normalize/quat',\n  'Logic',\n  'Normalize',\n  (description, graph) =>\n    new In1Out1FuncNode(description, graph, ['quat'], 'quat', vec4Normalize)\n);\nexport const Dot = new NodeDescription(\n  'math/dot/quat',\n  'Logic',\n  'Dot Product',\n  (description, graph) =>\n    new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'float', vec4Dot)\n);\n\nexport const FromAngleAxis = new NodeDescription(\n  'math/toQuat/angleAxis',\n  'Logic',\n  'Angle Axis to Quat',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['float', 'vec3'],\n      'quat',\n      angleAxisToQuat\n    )\n);\nexport const Slerp = new NodeDescription(\n  'math/slerp/quat',\n  'Logic',\n  'Slerp',\n  (description, graph) =>\n    new In3Out1FuncNode(\n      description,\n      graph,\n      ['quat', 'quat', 'float'],\n      'quat',\n      quatSlerp,\n      ['a', 'b', 't']\n    )\n);\nexport const Equal = new NodeDescription(\n  'math/equal/quat',\n  'Logic',\n  '=',\n  (description, graph) =>\n    new In2Out1FuncNode(\n      description,\n      graph,\n      ['quat', 'quat'],\n      'boolean',\n      vec4Equals\n    )\n);\n", "/* eslint-disable max-len */\nimport { getNodeDescriptions } from '../../Nodes/Registry/NodeDescription.js';\nimport { Registry } from '../../Registry.js';\nimport { registerSerializersForValueType } from '../Core/registerSerializersForValueType.js';\nimport { DummyScene } from './Abstractions/Drivers/DummyScene.js';\nimport { IScene } from './Abstractions/IScene.js';\nimport { SetSceneProperty } from './Actions/SetSceneProperty.js';\nimport { OnSceneNodeClick } from './Events/OnSceneNodeClick.js';\nimport { GetSceneProperty } from './Queries/GetSceneProperty.js';\nimport * as ColorNodes from './Values/ColorNodes.js';\nimport { ColorValue } from './Values/ColorValue.js';\nimport * as EulerNodes from './Values/EulerNodes.js';\nimport { EulerValue } from './Values/EulerValue.js';\nimport * as QuatNodes from './Values/QuatNodes.js';\nimport { QuatValue } from './Values/QuatValue.js';\nimport * as Vec2Nodes from './Values/Vec2Nodes.js';\nimport { Vec2Value } from './Values/Vec2Value.js';\nimport * as Vec3Nodes from './Values/Vec3Nodes.js';\nimport { Vec3Value } from './Values/Vec3Value.js';\nimport * as Vec4Nodes from './Values/Vec4Nodes.js';\nimport { Vec4Value } from './Values/Vec4Value.js';\n\nexport function registerSceneProfile(\n  registry: Registry,\n  scene: IScene = new DummyScene()\n) {\n  const { values, nodes } = registry;\n\n  // pull in value type nodes\n  values.register(Vec2Value);\n  values.register(Vec3Value);\n  values.register(Vec4Value);\n  values.register(ColorValue);\n  values.register(EulerValue);\n  values.register(QuatValue);\n\n  // pull in value type nodes\n  nodes.register(...getNodeDescriptions(Vec2Nodes));\n  nodes.register(...getNodeDescriptions(Vec3Nodes));\n  nodes.register(...getNodeDescriptions(Vec4Nodes));\n  nodes.register(...getNodeDescriptions(ColorNodes));\n  nodes.register(...getNodeDescriptions(EulerNodes));\n  nodes.register(...getNodeDescriptions(QuatNodes));\n\n  // events\n\n  nodes.register(OnSceneNodeClick.Description);\n\n  // actions\n  const allValueTypeNames = values.getAllNames();\n  nodes.register(\n    ...SetSceneProperty.GetDescriptions(scene, ...allValueTypeNames)\n  );\n  nodes.register(\n    ...GetSceneProperty.GetDescriptions(scene, ...allValueTypeNames)\n  );\n\n  const newValueTypeNames = ['vec2', 'vec3', 'vec4', 'quat', 'euler', 'color'];\n\n  // variables\n\n  newValueTypeNames.forEach((valueTypeName) => {\n    registerSerializersForValueType(registry, valueTypeName);\n  });\n\n  return registry;\n}\n"],
  "mappings": "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",
  "names": ["graph", "graph", "graph", "graph", "Constant", "Equal", "ToFloat", "Constant", "ToFloat", "Equal", "Abs", "Add", "Clamp", "Constant", "Divide", "Equal", "GreaterThan", "GreaterThanOrEqual", "LessThan", "LessThanOrEqual", "Max", "Min", "Modulus", "Multiply", "Negate", "Sign", "Subtract", "ToFloat", "Constant", "Add", "Subtract", "Negate", "Multiply", "Divide", "Modulus", "ToFloat", "Min", "Max", "Clamp", "Abs", "Sign", "Equal", "GreaterThan", "GreaterThanOrEqual", "LessThan", "LessThanOrEqual", "Constant", "Equal", "Constant", "Equal", "p", "q", "Add", "Constant", "Equal", "Mix", "Negate", "Subtract", "Constant", "Add", "Subtract", "Negate", "Mix", "Equal", "Add", "Constant", "Create", "Elements", "Equal", "Mix", "Negate", "Scale", "Subtract", "Constant", "Create", "Elements", "Add", "Subtract", "Negate", "Scale", "Mix", "Equal", "Add", "Constant", "Create", "Elements", "Equal", "Length", "Mix", "Negate", "Scale", "Subtract", "Constant", "Create", "Elements", "Add", "Subtract", "Negate", "Scale", "Length", "Mix", "Equal", "Add", "Constant", "Create", "Dot", "Elements", "Equal", "Length", "Mix", "Negate", "Normalize", "Scale", "Subtract", "Constant", "Create", "Elements", "Add", "Subtract", "Negate", "Scale", "Length", "Normalize", "Dot", "Mix", "Equal", "Add", "Constant", "Create", "Dot", "Elements", "Equal", "Length", "Mix", "Negate", "Normalize", "Scale", "Subtract", "Constant", "Create", "Elements", "Add", "Subtract", "Negate", "Scale", "Length", "Normalize", "Dot", "Mix", "Equal", "Constant", "Create", "Dot", "Elements", "Equal", "Length", "Multiply", "Negate", "Normalize", "Scale", "Constant", "Create", "Elements", "Negate", "Multiply", "Scale", "Length", "Normalize", "Dot", "Equal"]
}
