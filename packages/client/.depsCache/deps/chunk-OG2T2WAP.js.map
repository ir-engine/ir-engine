{
  "version": 3,
  "sources": ["../../../../node_modules/@hookstate/node_modules/.pnpm/tslib@2.4.0/node_modules/tslib/tslib.es6.js", "../../../../node_modules/@hookstate/core/src/is-shallow-equal.ts", "../../../../node_modules/@hookstate/core/src/index.ts"],
  "sourcesContent": ["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n", "/**\r\n * Copied from fbjs is-shallow-equal\r\n */\r\n\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\nfunction is(x: any, y: any): boolean {\r\n    // SameValue algorithm\r\n    if (x === y) { // Steps 1-5, 7-10\r\n        // Steps 6.b-6.e: +0 != -0\r\n        // Added the nonzero y check to make Flow happy, but it is redundant\r\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\r\n    } else {\r\n        // Step 6.a: NaN == NaN\r\n        return x !== x && y !== y;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs equality by iterating through keys on an object and returning false\r\n * when any key has values which are not strictly equal between the arguments.\r\n * Returns true when the values of all keys are strictly equal.\r\n */\r\nexport function shallowEqual(objA: any, objB: any): boolean {\r\n    if (is(objA, objB)) {\r\n        return true;\r\n    }\r\n\r\n    if (typeof objA !== 'object' || objA === null ||\r\n        typeof objB !== 'object' || objB === null) {\r\n        return false;\r\n    }\r\n\r\n    const keysA = Object.keys(objA);\r\n    const keysB = Object.keys(objB);\r\n\r\n    if (keysA.length !== keysB.length) {\r\n        return false;\r\n    }\r\n\r\n    // Test for A's keys different from B.\r\n    for (let i = 0; i < keysA.length; i++) {\r\n        if (\r\n            !hasOwnProperty.call(objB, keysA[i]) ||\r\n            !is(objA[keysA[i]], objB[keysA[i]])\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}", "import React from 'react';\r\nimport { shallowEqual } from './is-shallow-equal';\r\n\r\n///\r\n/// EXPORTED SYMBOLS (LIBRARY INTERFACE)\r\n///\r\n\r\n/**\r\n * 'JSON path' from root of a state object to a nested property.\r\n * Return type of [StateMethod.path](#readonly-path).\r\n *\r\n * For example, an object `{ a: [{ b: 1 }, { 1000: 'value' }, '3rd'] }`,\r\n * has got the following paths pointing to existing properties:\r\n *\r\n * - `[]`\r\n * - `['a']`\r\n * - `['a', 0]`\r\n * - `['a', 0, 'b']`\r\n * - `['a', 1]`\r\n * - `['a', 1, 1000]`\r\n * - `['a', 2]`\r\n */\r\nexport type Path = ReadonlyArray<string | number>;\r\n\r\n/**\r\n * Type of an argument of [StateMethods.set](#set).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetStateAction<S> = (S | Promise<S>) | ((prevState: S) => (S | Promise<S>));\r\n\r\n/**\r\n * Type of an argument of [StateMethods.merge](#merge).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetPartialStateAction<S> =\r\n    S extends ReadonlyArray<(infer U)> ?\r\n    ReadonlyArray<U> | Record<number, U> | ((prevValue: S) => (ReadonlyArray<U> | Record<number, U>)) :\r\n    S extends object | string ? Partial<S> | ((prevValue: S) => Partial<S>) :\r\n    React.SetStateAction<S>;\r\n\r\n/**\r\n * Type of an argument of [hookstate](#hookstate) and [useHookstate](#useHookstate).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetInitialStateAction<S> = S | Promise<S> | (() => S | Promise<S>)\r\n\r\n/**\r\n * Special symbol which might be used to delete properties\r\n * from an object calling [StateMethods.set](#set) or [StateMethods.merge](#merge).\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/nested-state#deleting-existing-element)\r\n */\r\nexport const none = Symbol('none') as StateValueAtPath;\r\n\r\n/**\r\n * Return type of [StateMethods.keys](#readonly-keys).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type InferStateKeysType<S> =\r\n    S extends ReadonlyArray<infer _> ? ReadonlyArray<number> :\r\n    S extends null ? undefined :\r\n    S extends object ? ReadonlyArray<string> :\r\n    undefined;\r\n\r\n// TODO deprecate\r\nexport type InferredStateKeysType<S> = InferStateKeysType<S>;\r\n/**\r\n * Return type of [StateMethods.map()](#map).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type InferStateOrnullType<S, E> =\r\n    S extends undefined ? undefined :\r\n    S extends null ? null : State<S, E>;\r\n\r\n// TODO deprecated\r\nexport type InferredStateOrnullType<S, E> = InferStateOrnullType<S, E>\r\n\r\n/**\r\n * For plugin developers only.\r\n * An instance to manipulate the state in more controlled way.\r\n * \r\n * @typeparam S Type of a value of a state\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface PluginStateControl<S> {\r\n    /**\r\n     * Get state value, but do not leave the traces of reading it.\r\n     */\r\n    getUntracked(): S;\r\n    /**\r\n     * Set new state value, but do not trigger rerender.\r\n     * \r\n     * @param newValue new value to set to a state.\r\n     */\r\n    setUntracked(newValue: SetStateAction<S>): Path[];\r\n    /**\r\n     * Merge new state value, but do not trigger rerender.\r\n     * \r\n     * @param mergeValue new partial value to merge with the current state value and set.\r\n     */\r\n    mergeUntracked(mergeValue: SetPartialStateAction<S>): Path[];\r\n    /**\r\n     * Trigger rerender for hooked states, where values at the specified paths are used.\r\n     * \r\n     * @param paths paths of the state variables to search for being used by components and rerender\r\n     */\r\n    rerender(paths: Path[]): void;\r\n}\r\n\r\n// TODO move __State to State definition, so StateMethods are not used directly by user\r\n// TODO and declare incompatible __synthetic marker, so StateMethods would become forced to be replaced by State\r\n/**\r\n * An interface to manage a state in Hookstate.\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport interface StateMethods<S, E = {}> extends __State<S, E> {\r\n    // TODO remove default value for E parameter\r\n    /**\r\n     * 'Javascript' object 'path' to an element relative to the root object\r\n     * in the state. For example:\r\n     *\r\n     * ```tsx\r\n     * const state = useHookstate([{ name: 'First Task' }])\r\n     * state.path IS []\r\n     * state[0].path IS [0]\r\n     * state.[0].name.path IS [0, 'name']\r\n     * ```\r\n     */\r\n    readonly path: Path;\r\n\r\n    /**\r\n     * Return the keys of nested states.\r\n     * For a given state of [State](#state) type,\r\n     * `state.keys` will be structurally equal to Object.keys(state),\r\n     * with two minor difference:\r\n     * 1. if `state.value` is an array, the returned result will be\r\n     * an array of numbers, not strings like with `Object.keys`.\r\n     * 2. if `state.value` is not an object, the returned result will be undefined.\r\n     */\r\n    readonly keys: InferStateKeysType<S>;\r\n\r\n    /**\r\n     * Unwraps and returns the underlying state value referred by\r\n     * [path](#readonly-path) of this state instance.\r\n     *\r\n     * It returns the same result as [StateMethods.get](#get) method.\r\n     *\r\n     * This property is more useful than [get](#get) method for the cases,\r\n     * when a value may hold null or undefined values.\r\n     * Typescript compiler does not handle elimination of undefined with get(),\r\n     * like in the following examples, but value does:\r\n     *\r\n     * ```tsx\r\n     * const state = useHookstate<number | undefined>(0)\r\n     * const myvalue: number = state.value\r\n     *      ? state.value + 1\r\n     *      : 0; // <-- compiles\r\n     * const myvalue: number = state.get()\r\n     *      ? state.get() + 1\r\n     *      : 0; // <-- does not compile\r\n     * ```\r\n     */\r\n    readonly value: S;\r\n\r\n    // TODO deprecate in favor of promise\r\n    /**\r\n     * True if state value is not yet available (eg. equal to a promise)\r\n     */\r\n    readonly promised: boolean;\r\n\r\n    // TODO document\r\n    readonly promise: Promise<State<S, E>> | undefined;\r\n\r\n    /**\r\n     * If a state was set to a promise and the promise was rejected,\r\n     * this property will return the error captured from the promise rejection\r\n     */\r\n    readonly error: StateErrorAtRoot | undefined;\r\n\r\n    /**\r\n     * Unwraps and returns the underlying state value referred by\r\n     * [path](#readonly-path) of this state instance.\r\n     *\r\n     * It returns the same result as [StateMethods.value](#readonly-value) method.\r\n     * \r\n     * If the additional option `noproxy` is set, the method will return\r\n     * the original data object without wrapping it by proxy.\r\n     * All properties of the object will be marked as used and on change will trigger the rerender.\r\n     * \r\n     * If the additional option `stealth` is set, the method will not mark\r\n     * the object as used and it will not trigger the rerender if it is changed.\r\n     * It might be helpful to use it during debugging, for example:\r\n     * `console.log(state.get({ stealth: true }))`.\r\n     * If you use it, make sure you know what you are doing. \r\n     */\r\n    get(options?: { noproxy?: boolean, stealth?: boolean }): S;\r\n\r\n    /**\r\n     * Sets new value for a state.\r\n     * If `this.path === []`,\r\n     * it is similar to the `setState` variable returned by `React.useState` hook.\r\n     * If `this.path !== []`, it sets only the segment of the state value, pointed out by the path.\r\n     * Unlike [merge](#merge) method, this method will not accept partial updates.\r\n     * Partial updates can be also done by walking the nested states and setting those.\r\n     *\r\n     * @param newValue new value to set to a state.\r\n     * It can be a value, a promise resolving to a value\r\n     * (only if [this.path](#readonly-path) is `[]`),\r\n     * or a function returning one of these.\r\n     * The function receives the current state value as an argument.\r\n     */\r\n    set(newValue: SetStateAction<S>): void;\r\n\r\n    /**\r\n     * Similarly to [set](#set) method updates state value.\r\n     *\r\n     * - If current state value is an object, it does partial update for the object.\r\n     * - If state value is an array and the argument is an array too,\r\n     * it concatenates the current value with the value of the argument and sets it to the state.\r\n     * - If state value is an array and the `merge` argument is an object,\r\n     * it does partial update for the current array value.\r\n     * - If current state value is a string, it concatenates the current state\r\n     * value with the argument converted to string and sets the result to the state.\r\n     */\r\n    merge(newValue: SetPartialStateAction<S>): void;\r\n\r\n    /**\r\n     * Returns nested state by key.\r\n     * `state.nested('myprop')` returns the same as `state.myprop` or `state['myprop']`,\r\n     * but also works for properties, which names collide with names of state methods.\r\n     * \r\n     * [Learn more about nested states...](https://hookstate.js.org/docs/nested-state)\r\n     * \r\n     * @param key child property name or index\r\n     */\r\n    nested<K extends keyof S>(key: K): State<S[K], E>;\r\n\r\n    /**\r\n     * If state value is null or undefined, returns state value.\r\n     * Otherwise, it returns this state instance but\r\n     * with null and undefined removed from the type parameter.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/nullable-state)\r\n     */\r\n    ornull: InferStateOrnullType<S, E>;\r\n\r\n    // TODO deprecate\r\n    /**\r\n     * Adds plugin to the state.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/extensions-overview)\r\n     */\r\n    attach(plugin: () => Plugin): State<S, E>\r\n\r\n    // TODO deprecate\r\n    /**\r\n     * For plugin developers only.\r\n     * It is a method to get the instance of the previously attached plugin.\r\n     * If a plugin has not been attached to a state,\r\n     * it returns an Error as the first element.\r\n     * A plugin may trhow an error to indicate that plugin has not been attached.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n     */\r\n    attach(pluginId: symbol): [PluginCallbacks | Error, PluginStateControl<S>]\r\n}\r\n\r\n/**\r\n * Mixin for the [StateMethods](#interfacesstatemethodsmd) for a [State](#state),\r\n * which can be destroyed by a client.\r\n */\r\nexport interface StateMethodsDestroy {\r\n    // TODO deprecate and replace by deactivate/activate within the StateMethods directly\r\n    /**\r\n     * Destroys an instance of a state, so\r\n     * it can clear the allocated native resources (if any)\r\n     * and can not be used anymore after it has been destroyed.\r\n     */\r\n    destroy(): void;\r\n}\r\n\r\n/**\r\n * Returns an interface stripped of all keys that don't resolve to U, defaulting \r\n * to a non-strict comparison of T[key] extends U. Setting B to true performs\r\n * a strict type comparison of T[key] extends U & U extends T[key]\r\n */\r\nexport type __KeysOfType<T, U, B = false> = {\r\n    [P in keyof T]: B extends true\r\n    ? T[P] extends U\r\n    ? (U extends T[P]\r\n        ? P\r\n        : never)\r\n    : never\r\n    : T[P] extends U\r\n    ? P\r\n    : never;\r\n}[keyof T];\r\n\r\n// type PickByType<T, U, B = false> = Pick<T, KeysOfType<T, U, B>>;\r\n\r\nexport const __state = Symbol('__state')\r\nexport interface __State<S, E> {\r\n    [__state]: [S, E]\r\n}\r\n\r\n// TODO document, give example how to use in extension method signatures\r\nexport type InferStateValueType<V> = DeepReturnType<V> extends __State<(infer S), (infer _)> ? S : V\r\n// TODO document, give example how to use in extension method signatures\r\nexport type InferStateExtensionType<V> = DeepReturnType<V> extends __State<(infer _), (infer E)>\r\n    ? E\r\n    : DeepReturnType<V> extends Extension<(infer _), (infer _), (infer E)>\r\n    ? E : V\r\nexport type DeepReturnType<V> = V extends (...args: any) => (infer R) ? DeepReturnType<R> : V;\r\n\r\n/**\r\n * Type of a result of [hookstate](#hookstate) and [useHookstate](#useHookstate) functions\r\n * \r\n * @typeparam S Type of a value of a state\r\n * \r\n * [Learn more about global states...](https://hookstate.js.org/docs/global-state)\r\n * [Learn more about local states...](https://hookstate.js.org/docs/local-state)\r\n * [Learn more about nested states...](https://hookstate.js.org/docs/nested-state)\r\n */\r\nexport type State<S, E = {}> = StateMethods<S, E> & E & (\r\n    S extends ReadonlyArray<(infer U)> ? ReadonlyArray<State<U, E>> :\r\n    S extends object ? Omit<\r\n        { readonly [K in keyof Required<S>]: State<S[K], E>; },\r\n        keyof StateMethods<S, E> | keyof StateMethodsDestroy | __KeysOfType<S, Function> | keyof E\r\n    > : {}\r\n);\r\n\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with root state value.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\n// TODO remove export when plugins API is removed\r\nexport type StateValueAtRoot = any; //tslint:disable-line: no-any\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with nested state value.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type StateValueAtPath = any; //tslint:disable-line: no-any\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with state error.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type StateErrorAtRoot = any; //tslint:disable-line: no-any\r\n\r\n// TODO document\r\nexport type StateExtensionUnknown = any; //tslint:disable-line: no-any\r\n\r\n/**\r\n * For plugin developers only.\r\n * PluginCallbacks.onSet argument type.\r\n */\r\nexport interface PluginCallbacksOnSetArgument {\r\n    readonly path: Path,\r\n    readonly state?: StateValueAtRoot,\r\n    /**\r\n     * **A note about previous values and merging:**\r\n     * State values are muteable in Hookstate for performance reasons. This causes a side effect in the merge operation.\r\n     * While merging, the previous state object is mutated as the desired changes are applied. This means the value of\r\n     * `previous` will reflect the merged changes as well, matching the new `state` value rather than the previous\r\n     * state value. As a result, the `previous` property is unreliable when merge is used. The\r\n     * [merged](#optional-readonly-merged) property can be used to detect which values were merged in but it will not\r\n     * inform you whether those values are different from the previous state.\r\n     *\r\n     * As a workaround, you can replace merge calls with the immutable-style set operation like so:\r\n     *\r\n     * ```\r\n     * state.set(p => {\r\n     *     let copy = p.clone(); /// here it is up to you to define how to clone the current state\r\n     *     copy.field = 'new value for field';\r\n     *     delete copy.fieldToDelete;\r\n     *     return copy;\r\n     * })\r\n     * ```\r\n     */\r\n    readonly previous?: StateValueAtPath,\r\n    readonly value?: StateValueAtPath,\r\n    readonly merged?: StateValueAtPath,\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * PluginCallbacks.onDestroy argument type.\r\n */\r\nexport interface PluginCallbacksOnDestroyArgument {\r\n    readonly state?: StateValueAtRoot,\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * Set of callbacks, a plugin may subscribe to.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface PluginCallbacks {\r\n    readonly onSet?: (arg: PluginCallbacksOnSetArgument) => void,\r\n    readonly onDestroy?: (arg: PluginCallbacksOnDestroyArgument) => void,\r\n};\r\n\r\n/**\r\n * For plugin developers only.\r\n * Hookstate plugin specification and factory method.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface Plugin {\r\n    /**\r\n     * Unique identifier of a plugin.\r\n     */\r\n    readonly id: symbol;\r\n    /**\r\n     * Initializer for a plugin when it is attached for the first time.\r\n     */\r\n    readonly init?: (state: State<StateValueAtRoot, {}>) => PluginCallbacks;\r\n}\r\n\r\n// TODO document\r\nexport interface Extension<S, I, E> {\r\n    readonly onCreate?: (\r\n        state: State<S, {}>,\r\n        extensionsCallbacks: {\r\n            [K in keyof I]: (i: State<StateValueAtPath, E & I>) => I[K];\r\n        },\r\n    ) => { readonly [K in keyof Required<E>]: (state: State<StateValueAtPath, E & I>) => E[K]; },\r\n    readonly onInit?: (\r\n        state: State<S, E & I>,\r\n        extensionsCallbacks: {\r\n            [K in keyof E & I]: (i: State<StateValueAtPath, E & I>) => (E & I)[K];\r\n        }\r\n    ) => void,\r\n    readonly onPreset?: (state: State<StateValueAtPath, E & I>, value: StateValueAtPath) => void,\r\n    readonly onPremerge?: (state: State<StateValueAtPath, E & I>, value: StateValueAtPath) => void,\r\n    readonly onSet?: (state: State<StateValueAtPath, E & I>, descriptor: SetActionDescriptor) => void,\r\n    readonly onDestroy?: (state: State<S, E & I>) => void,\r\n};\r\n\r\nexport type ExtensionFactory<S, I, E> = (typemarker?: __State<S, I>) => Extension<S, I, E>\r\n\r\n// TODO deprecate\r\n/**\r\n * Creates new state and returns it.\r\n *\r\n * You can create as many global states as you need.\r\n *\r\n * When you the state is not needed anymore,\r\n * it should be destroyed by calling\r\n * `destroy()` method of the returned instance.\r\n * This is necessary for some plugins,\r\n * which allocate native resources,\r\n * like subscription to databases, broadcast channels, etc.\r\n * In most cases, a global state is used during\r\n * whole life time of an application and would not require\r\n * destruction. However, if you have got, for example,\r\n * a catalog of dynamically created and destroyed global states,\r\n * the states should be destroyed as advised above.\r\n *\r\n * @param initial Initial value of the state.\r\n * It can be a value OR a promise,\r\n * which asynchronously resolves to a value,\r\n * OR a function returning a value or a promise.\r\n *\r\n * @typeparam S Type of a value of the state\r\n *\r\n * @returns [State](#state) instance,\r\n * which can be used directly to get and set state value\r\n * outside of React components.\r\n * When you need to use the state in a functional `React` component,\r\n * pass the created state to [useHookstate](#useHookstate) function and\r\n * use the returned result in the component's logic.\r\n */\r\nexport function createState<S>(\r\n    initial: SetInitialStateAction<S>\r\n): State<S, {}> & StateMethodsDestroy {\r\n    return hookstate(initial) as State<S, {}> & StateMethodsDestroy\r\n}\r\n\r\n// TODO deprecated\r\nexport function createHookstate<S>(\r\n    initial: SetInitialStateAction<S>\r\n): State<S, {}> {\r\n    return hookstate(initial) as State<S, {}> & StateMethodsDestroy\r\n}\r\n\r\n// TODO block this on type system level\r\nexport function hookstate<S, E = {}>(\r\n    source: __State<S, E>,\r\n    extension?: ExtensionFactory<S, E, StateExtensionUnknown>\r\n): never;\r\nexport function hookstate<S, E = {}>(\r\n    initial: SetInitialStateAction<S>,\r\n    extension?: ExtensionFactory<S, {}, E>\r\n): State<S, E>;\r\nexport function hookstate<S, E = {}>(\r\n    initial: SetInitialStateAction<S>,\r\n    extension?: ExtensionFactory<S, {}, E>\r\n): State<S, E> {\r\n    const store = createStore(initial);\r\n    store.activate(extension as ExtensionFactory<StateValueAtRoot, {}, StateExtensionUnknown>)\r\n    const methods = store.toMethods();\r\n    const devtools = createState[DevToolsID]\r\n    if (devtools) {\r\n        methods.attach(devtools)\r\n    }\r\n    return methods.self() as unknown as State<S, E> & StateMethodsDestroy;\r\n}\r\n\r\n// TODO deprectate useState\r\n/**\r\n * @warning Initializing a local state to a promise without using \r\n * an initializer callback function, which returns a Promise,\r\n * is almost always a mistake. So, it is blocked.\r\n * Use `useHookstate(() => your_promise)` instead of `useHookstate(your_promise)`.\r\n */\r\nexport function useState<S>(\r\n    source: Promise<S>\r\n): never;\r\n/**\r\n * Enables a functional React component to use a state,\r\n * either created by [hookstate](#hookstate) (*global* state) or\r\n * derived from another call to [useHookstate](#useHookstate) (*scoped* state).\r\n *\r\n * The `useHookstate` forces a component to rerender every time, when:\r\n * - a segment/part of the state data is updated *AND only if*\r\n * - this segment was **used** by the component during or after the latest rendering.\r\n *\r\n * For example, if the state value is `{ a: 1, b: 2 }` and\r\n * a component uses only `a` property of the state, it will rerender\r\n * only when the whole state object is updated or when `a` property is updated.\r\n * Setting the state value/property to the same value is also considered as an update.\r\n *\r\n * A component can use one or many states,\r\n * i.e. you may call `useHookstate` multiple times for multiple states.\r\n *\r\n * The same state can be used by multiple different components.\r\n *\r\n * @param source a reference to the state to hook into\r\n *\r\n * The `useHookstate` is a hook and should follow React's rules of hooks.\r\n *\r\n * @returns an instance of [State](#state),\r\n * which **must be** used within the component (during rendering\r\n * or in effects) or it's children.\r\n */\r\nexport function useState<S>(\r\n    source: State<S, {}>\r\n): State<S, {}>;\r\n/**\r\n * This function enables a functional React component to use a state,\r\n * created per component by [useHookstate](#useHookstate) (*local* state).\r\n * In this case `useHookstate` behaves similarly to `React.useState`,\r\n * but the returned instance of [State](#state)\r\n * has got more features.\r\n *\r\n * When a state is used by only one component, and maybe it's children,\r\n * it is recommended to use *local* state instead of *global*,\r\n * which is created by [hookstate](#hookstate).\r\n *\r\n * *Local* (per component) state is created when a component is mounted\r\n * and automatically destroyed when a component is unmounted.\r\n *\r\n * The same as with the usage of a *global* state,\r\n * `useHookstate` forces a component to rerender when:\r\n * - a segment/part of the state data is updated *AND only if*\r\n * - this segment was **used** by the component during or after the latest rendering.\r\n *\r\n * You can use as many local states within the same component as you need.\r\n *\r\n * @param source An initial value state.\r\n *\r\n * @returns an instance of [State](#state),\r\n * which **must be** used within the component (during rendering\r\n * or in effects) or it's children.\r\n */\r\nexport function useState<S>(\r\n    source: SetInitialStateAction<S>\r\n): State<S, {}>;\r\nexport function useState<S>(\r\n    source: SetInitialStateAction<S> | State<S, {}>\r\n): State<S, {}> {\r\n    return useHookstate(source as State<S, {}>);\r\n}\r\n\r\n// TODO document\r\nexport function extend<\r\n    S,\r\n    E,\r\n    E1 extends {} = {},\r\n    E2 extends {} = {},\r\n    E3 extends {} = {},\r\n    E4 extends {} = {},\r\n    E5 extends {} = {}\r\n>(\r\n    e1?: ExtensionFactory<S, E, E1>,\r\n    e2?: ExtensionFactory<S, E1 & E, E2>,\r\n    e3?: ExtensionFactory<S, E2 & E1 & E, E3>,\r\n    e4?: ExtensionFactory<S, E3 & E2 & E1 & E, E4>,\r\n    e5?: ExtensionFactory<S, E4 & E3 & E2 & E1 & E, E5>\r\n): ExtensionFactory<S, E, E5 & E4 & E3 & E2 & E1> {\r\n    function extended(extensions: (ExtensionFactory<S, E, {}>)[]) {\r\n        let exts = extensions.map(i => i());\r\n        let onInitCbs = exts.map(i => i.onInit).filter(i => i)\r\n        let onPremergeCbs = exts.map(i => i.onPremerge).filter(i => i)\r\n        let onPresetCbs = exts.map(i => i.onPreset).filter(i => i)\r\n        let onSetCbs = exts.map(i => i.onSet).filter(i => i)\r\n        let onDestroyCbs = exts.map(i => i.onDestroy).filter(i => i)\r\n        let result: Writeable<Extension<S, E, {}>> = {\r\n            onCreate: (instanceFactory, combinedMethods) => {\r\n                for (let ext of exts) {\r\n                    if (ext.onCreate) {\r\n                        let extMethods = ext.onCreate(instanceFactory, combinedMethods)\r\n                        Object.assign(combinedMethods, extMethods)\r\n                    }\r\n                }\r\n                return combinedMethods\r\n            }\r\n        }\r\n        if (onInitCbs.length > 0) {\r\n            result.onInit = (s, e) => {\r\n                for (let cb of onInitCbs) {\r\n                    cb!(s, e);\r\n                }\r\n            }\r\n        }\r\n        if (onPremergeCbs.length > 0) {\r\n            result.onPremerge = (s, d) => {\r\n                for (let cb of onPremergeCbs) {\r\n                    cb!(s, d);\r\n                }\r\n            }\r\n        }\r\n        if (onPresetCbs.length > 0) {\r\n            result.onPreset = (s, d) => {\r\n                for (let cb of onPresetCbs) {\r\n                    cb!(s, d);\r\n                }\r\n            }\r\n        }\r\n        if (onSetCbs.length > 0) {\r\n            result.onSet = (s, d) => {\r\n                for (let cb of onSetCbs) {\r\n                    cb!(s, d);\r\n                }\r\n            }\r\n        }\r\n        if (onDestroyCbs.length > 0) {\r\n            result.onDestroy = (s) => {\r\n                for (let cb of onDestroyCbs) {\r\n                    cb!(s);\r\n                }\r\n            }\r\n        }\r\n        return result as Extension<S, E, E1 & E2 & E3 & E4 & E5>\r\n    }\r\n    return () => extended((\r\n        [e1, e2, e3, e4, e5] as ExtensionFactory<S, E, {}>[]\r\n    ).filter(i => i!))\r\n}\r\n\r\n/**\r\n * @warning Initializing a local state to a promise without using \r\n * an initializer callback function, which returns a Promise,\r\n * is almost always a mistake. So, it is blocked.\r\n * Use `useHookstate(() => your_promise)` instead of `useHookstate(your_promise)`.\r\n */\r\nexport function useHookstate<S, E = {}>(\r\n    source: Promise<S>,\r\n    extension?: ExtensionFactory<S, {}, E>\r\n): never;\r\n// TODO block this on type system level\r\nexport function useHookstate<S, E = {}>(\r\n    source: __State<S, E>,\r\n    extension: ExtensionFactory<S, E, StateExtensionUnknown>\r\n): never;\r\n/**\r\n * Alias to [useHookstate](#useHookstate) which provides a workaround\r\n * for [React 20613 bug](https://github.com/facebook/react/issues/20613)\r\n */\r\nexport function useHookstate<S, E = {}>(\r\n    source: __State<S, E>\r\n): State<S, E>;\r\n/**\r\n * Alias to [useHookstate](#useHookstate) which provides a workaround\r\n * for [React 20613 bug](https://github.com/facebook/react/issues/20613)\r\n */\r\nexport function useHookstate<S, E = {}>(\r\n    source: SetInitialStateAction<S>,\r\n    extension?: ExtensionFactory<S, {}, E>\r\n): State<S, E>;\r\nexport function useHookstate<S, E = {}>(\r\n    source: SetInitialStateAction<S> | State<S, E>,\r\n    extension?: ExtensionFactory<S, {}, E>\r\n): State<S, E> {\r\n    const parentMethods = Object(source) === source ?\r\n        source[self] as StateMethodsImpl<S, E> | undefined :\r\n        undefined;\r\n    if (parentMethods) {\r\n        if (parentMethods.isMounted) {\r\n            // Scoped state mount\r\n            // eslint-disable-next-line react-hooks/rules-of-hooks\r\n            const initializer = () => {\r\n                // warning: this is called twice in react strict mode\r\n                let store = parentMethods.store\r\n                let onSetUsedCallback = () => setValue({\r\n                    store: store, // immutable\r\n                    state: state, // immutable\r\n                    source: value.source // mutable, get the latest from value\r\n                })\r\n                let state = new StateMethodsImpl<S, E>(\r\n                    store,\r\n                    parentMethods.path,\r\n                    store.get(parentMethods.path),\r\n                    store.edition,\r\n                    onSetUsedCallback\r\n                );\r\n                return {\r\n                    store: store,\r\n                    state: state,\r\n                    source: source\r\n                }\r\n            };\r\n            const [value, setValue] = React.useState(initializer);\r\n\r\n            if (value.store !== parentMethods.store || !('source' in value)) {\r\n                throw new StateInvalidUsageError(parentMethods.path, ErrorId.InitStateStoreSwitchover)\r\n            }\r\n\r\n            // TODO move to a class hide props on prototype level\r\n            // hide props from development tools\r\n            Object.defineProperty(value, 'store', { enumerable: false });\r\n            Object.defineProperty(value, 'state', { enumerable: false });\r\n            Object.defineProperty(value, 'source', { enumerable: false });\r\n\r\n            value.state.reconstruct(\r\n                parentMethods.path,\r\n                value.store.get(parentMethods.path),\r\n                value.store.edition,\r\n                // parent state object has changed its reference object\r\n                // so the scopped state should change too\r\n                value.source !== source\r\n            );\r\n            value.source = source;\r\n\r\n            // need to subscribe in sync mode, because\r\n            // safari delays calling the effect giving priority to timeouts and network events,\r\n            // which can cause the state update\r\n            parentMethods.subscribe(value.state); // no-op if already subscribed\r\n            useIsomorphicLayoutEffect(() => {\r\n                // warning: in strict mode, effect is called twice\r\n                // so need to restore subscription and reconstruct the extension\r\n                // after the first effect unmount callback\r\n                value.state.onMount() // no-op if already mounted\r\n                parentMethods.subscribe(value.state); // no-op if already subscribed\r\n                return () => {\r\n                    value.state.onUnmount()\r\n                    parentMethods.unsubscribe(value.state);\r\n                }\r\n            }, []);\r\n\r\n            let state = value.state.self();\r\n            // expose property in development tools\r\n            value['[hookstate(scoped)]'] = state; // TODO use label here, add core extension to label states\r\n            return state\r\n        } else {\r\n            // Global state mount or destroyed link\r\n            // eslint-disable-next-line react-hooks/rules-of-hooks\r\n            let initializer = () => {\r\n                // warning: this is called twice in react strict mode\r\n                let store = parentMethods.store\r\n                let onSetUsedCallback = () => setValue({\r\n                    store: store, // immutable\r\n                    state: state, // immutable\r\n                    source: value.source // mutable, get the latest from value\r\n                })\r\n                let state = new StateMethodsImpl<S, E>(\r\n                    store,\r\n                    RootPath,\r\n                    store.get(RootPath),\r\n                    store.edition,\r\n                    onSetUsedCallback\r\n                );\r\n                return {\r\n                    store: store,\r\n                    state: state,\r\n                    source: source\r\n                }\r\n            }\r\n            const [value, setValue] = React.useState(initializer);\r\n\r\n            if (value.store !== parentMethods.store || !('source' in value)) {\r\n                throw new StateInvalidUsageError(parentMethods.path, ErrorId.InitStateStoreSwitchover)\r\n            }\r\n\r\n            // hide props from development tools\r\n            Object.defineProperty(value, 'store', { enumerable: false });\r\n            Object.defineProperty(value, 'state', { enumerable: false });\r\n            Object.defineProperty(value, 'source', { enumerable: false });\r\n\r\n            value.state.reconstruct(\r\n                RootPath,\r\n                value.store.get(RootPath),\r\n                value.store.edition,\r\n                // parent state object has changed its reference object\r\n                // so the scopped state should change too\r\n                value.source !== source\r\n            );\r\n            value.source = source;\r\n\r\n            // need to subscribe in sync mode, because\r\n            // safari delays calling the effect giving priority to timeouts and network events,\r\n            // which can cause the state update\r\n            value.store.subscribe(value.state); // no-op if already subscribed\r\n            useIsomorphicLayoutEffect(() => {\r\n                // warning: in strict mode, effect is called twice\r\n                // so need to restore subscription and reconstruct the extension\r\n                // after the first effect unmount callback\r\n                value.state.onMount() // no-op if already mounted\r\n                value.store.subscribe(value.state); // no-op if already subscribed\r\n                return () => {\r\n                    value.state.onUnmount()\r\n                    value.store.unsubscribe(value.state);\r\n                }\r\n            }, []);\r\n\r\n            let state: State<StateValueAtPath, E> = value.state.self();\r\n            for (let ind = 0; ind < parentMethods.path.length; ind += 1) {\r\n                state = state.nested(parentMethods.path[ind]);\r\n            }\r\n            // expose property in development tools\r\n            value['[hookstate(global)]'] = state; // TODO use label here, add core extension to label states\r\n            return state as State<S, E>;\r\n        }\r\n    } else {\r\n        // Local state mount\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        let initializer = () => {\r\n            // warning: this is called twice in react strict mode\r\n            let store = createStore(source)\r\n            let onSetUsedCallback = () => setValue({\r\n                store: store,\r\n                state: state,\r\n            })\r\n            let state = new StateMethodsImpl<S, E>(\r\n                store,\r\n                RootPath,\r\n                store.get(RootPath),\r\n                store.edition,\r\n                onSetUsedCallback\r\n            );\r\n            return {\r\n                store: store,\r\n                state: state\r\n            }\r\n        }\r\n        const [value, setValue] = React.useState(initializer);\r\n\r\n        if ('source' in value) {\r\n            throw new StateInvalidUsageError(RootPath, ErrorId.InitStateStoreSwitchover)\r\n        }\r\n\r\n        // hide props from development tools\r\n        Object.defineProperty(value, 'store', { enumerable: false });\r\n        Object.defineProperty(value, 'state', { enumerable: false });\r\n\r\n        value.state.reconstruct(\r\n            RootPath,\r\n            value.store.get(RootPath),\r\n            value.store.edition,\r\n            false\r\n        );\r\n\r\n        // need to subscribe in sync mode, because\r\n        // safari delays calling the effect giving priority to timeouts and network events,\r\n        // which can cause the state update\r\n        value.store.subscribe(value.state); // no-op if already subscribed\r\n        // need to attach the extension straight away\r\n        // because extension methods are used in render function\r\n        // and we can not defer it to the effect callback\r\n        value.store.activate(extension as ExtensionFactory<StateValueAtRoot, {}, StateExtensionUnknown>); // no-op if already attached\r\n        useIsomorphicLayoutEffect(() => {\r\n            // warning: in strict mode, effect is called twice\r\n            // so need to restore subscription and reconstruct the extension\r\n            // after the first effect unmount callback\r\n            value.state.onMount() // no-op if already mounted\r\n            value.store.subscribe(value.state); // no-op if already subscribed\r\n            value.store.activate(extension as ExtensionFactory<StateValueAtRoot, {}, StateExtensionUnknown>); // no-op if already attached\r\n            return () => {\r\n                value.state.onUnmount()\r\n                value.store.unsubscribe(value.state);\r\n                value.store.deactivate() // this will destroy the extensions\r\n            }\r\n        }, []);\r\n\r\n        const devtools = useState[DevToolsID]\r\n        if (devtools) {\r\n            value.state.attach(devtools)\r\n        }\r\n        let state = value.state.self();\r\n        // expose property in development tools\r\n        value['[hookstate(local)]'] = state; // TODO use label here, add core extension to label states\r\n        return state\r\n    }\r\n}\r\n\r\n// TODO block on type system\r\nexport function StateFragment<S, E>(\r\n    props: {\r\n        state: __State<S, E>,\r\n        extension: ExtensionFactory<S, E, StateExtensionUnknown>,\r\n        children: (state: State<S, E>) => React.ReactElement,\r\n        suspend?: boolean,\r\n    }\r\n): never;\r\n/**\r\n * Allows to use a state without defining a functional react component.\r\n * It can be also used in class-based React components. It is also\r\n * particularly useful for creating *scoped* states.\r\n *\r\n * [Learn more...](https://hookstate.js.org/docs/using-without-statehook)\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function StateFragment<S, E>(\r\n    props: {\r\n        state: __State<S, E>,\r\n        children: (state: State<S, E>) => React.ReactElement,\r\n        suspend?: boolean,\r\n    }\r\n): React.ReactElement;\r\n/**\r\n * Allows to use a state without defining a functional react component.\r\n * See more at [StateFragment](#statefragment)\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/using-without-statehook)\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function StateFragment<S, E>(\r\n    props: {\r\n        state: SetInitialStateAction<S>,\r\n        extension?: ExtensionFactory<S, {}, E>,\r\n        children: (state: State<S, E>) => React.ReactElement,\r\n        suspend?: boolean,\r\n    }\r\n): React.ReactElement;\r\nexport function StateFragment<S, E>(\r\n    props: {\r\n        state: State<S, E> | SetInitialStateAction<S>,\r\n        extension?: ExtensionFactory<S, {}, E>,\r\n        children: (state: State<S, E>) => React.ReactElement,\r\n        suspend?: boolean, // TODO document\r\n    }\r\n): React.ReactElement {\r\n    const scoped = useHookstate(props.state as SetInitialStateAction<S>, props.extension);\r\n    return props.suspend && suspend(scoped) || props.children(scoped);\r\n}\r\n\r\n// TODO document\r\nexport function suspend<S, E>(state: State<S, E>) {\r\n    const p = state.promise;\r\n    return p && React.createElement(React.lazy(() => p as Promise<any>));\r\n}\r\n\r\n// TODO deprecate\r\n/**\r\n * A plugin which allows to opt-out from usage of Javascript proxies for\r\n * state usage tracking. It is useful for performance tuning.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/performance-managed-rendering#downgraded-plugin)\r\n */\r\nexport function Downgraded(): Plugin { // tslint:disable-line: function-name\r\n    return {\r\n        id: DowngradedID\r\n    }\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * Reserved plugin ID for developers tools extension.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport const DevToolsID = Symbol('DevTools');\r\n\r\n/**\r\n * Return type of [DevTools](#devtools).\r\n */\r\nexport interface DevToolsExtensions {\r\n    /**\r\n     * Assigns custom label to identify the state in the development tools\r\n     * @param name label for development tools\r\n     */\r\n    label(name: string): void;\r\n    /**\r\n     * Logs to the development tools\r\n     */\r\n    log(str: string, data?: any): void;    // tslint:disable-line: no-any\r\n}\r\n\r\n/**\r\n * Returns access to the development tools for a given state.\r\n * Development tools are delivered as optional plugins.\r\n * You can activate development tools from `@hookstate/devtools`package,\r\n * for example. If no development tools are activated,\r\n * it returns an instance of dummy tools, which do nothing, when called.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/devtools)\r\n * \r\n * @param state A state to relate to the extension.\r\n * \r\n * @returns Interface to interact with the development tools for a given state.\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function DevTools<S, E>(state: State<S, E>): DevToolsExtensions {\r\n    const plugin = state.attach(DevToolsID);\r\n    if (plugin[0] instanceof Error) {\r\n        return EmptyDevToolsExtensions;\r\n    }\r\n    return plugin[0] as DevToolsExtensions;\r\n}\r\n\r\n///\r\n/// INTERNAL SYMBOLS (LIBRARY IMPLEMENTATION)\r\n///\r\n\r\nconst self = Symbol('self')\r\n\r\nconst EmptyDevToolsExtensions: DevToolsExtensions = {\r\n    label() { /* */ },\r\n    log() { /* */ }\r\n}\r\n\r\nenum ErrorId {\r\n    // TODO document\r\n    StateUsedInDependencyList = 100,\r\n\r\n    InitStateToValueFromState = 101,\r\n    SetStateToValueFromState = 102,\r\n    GetStateWhenPromised = 103,\r\n    SetStateWhenPromised = 104,\r\n    SetStateNestedToPromised = 105,\r\n    SetStateWhenDestroyed = 106,\r\n    ToJson_Value = 108,\r\n    ToJson_State = 109,\r\n\r\n    // TODO document\r\n    GetProperty_Function = 110,\r\n    // TODO document\r\n    InitStateStoreSwitchover = 111,\r\n\r\n    GetUnknownPlugin = 120,\r\n\r\n    SetProperty_State = 201,\r\n    SetProperty_Value = 202,\r\n    SetPrototypeOf_State = 203,\r\n    SetPrototypeOf_Value = 204,\r\n    PreventExtensions_State = 205,\r\n    PreventExtensions_Value = 206,\r\n    DefineProperty_State = 207,\r\n    DefineProperty_Value = 208,\r\n    DeleteProperty_State = 209,\r\n    DeleteProperty_Value = 210,\r\n    Construct_State = 211,\r\n    Construct_Value = 212,\r\n    Apply_State = 213,\r\n    Apply_Value = 214,\r\n}\r\n\r\nclass StateInvalidUsageError extends Error {\r\n    constructor(path: Path, id: ErrorId, details?: string) {\r\n        super(`Error: HOOKSTATE-${id} [path: /${path.join('/')}${details ? `, details: ${details}` : ''}]. ` +\r\n            `See https://hookstate.js.org/docs/exceptions#hookstate-${id}`)\r\n    }\r\n}\r\n\r\ninterface Subscriber {\r\n    onSet(paths: SetActionDescriptor, actions: Set<() => void>): boolean;\r\n}\r\n\r\ninterface Subscribable {\r\n    subscribe(l: Subscriber): void;\r\n    unsubscribe(l: Subscriber): void;\r\n}\r\n\r\n// TODO deprecate\r\nconst DowngradedID = Symbol('Downgraded');\r\nconst SelfMethodsID = Symbol('ProxyMarker');\r\n\r\nconst RootPath: Path = [];\r\n\r\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\n\r\n// TODO document move\r\nexport interface SetActionDescriptor {\r\n    // path to update / rerender,\r\n    // migth be not the same as the part of state methods\r\n    // for example, when a new index is added to array\r\n    path: Path,\r\n    actions?: Record<string | number, \"I\" | \"U\" | \"D\">\r\n}\r\n\r\nclass Store implements Subscribable {\r\n    // > 0 means active store, < 0 means destroyed\r\n    // please note, in react strict mode and hot reload cases\r\n    // state can be reused, so we should support store resurection\r\n    public edition = 1;\r\n\r\n    private _stateMethods: StateMethodsImpl<StateValueAtRoot, StateExtensionUnknown>;\r\n\r\n    private _subscribers: Set<Subscriber> = new Set();\r\n\r\n    private _setSubscribers: Set<Required<PluginCallbacks>['onSet']> = new Set();\r\n    private _destroySubscribers: Set<Required<PluginCallbacks>['onDestroy']> = new Set();\r\n    private _plugins: Map<symbol, PluginCallbacks> = new Map();\r\n\r\n    private _extension?: Extension<StateValueAtRoot, {}, {}>;\r\n    private _extensionMethods?: {};\r\n\r\n    private _promise?: Promise<StateValueAtRoot>;\r\n    private _promiseResolver?: (_: StateValueAtRoot) => void;\r\n    private _promiseError?: StateValueAtRoot;\r\n\r\n    constructor(private _value: StateValueAtRoot) {\r\n        if (Object(_value) === _value &&\r\n            configuration.promiseDetector(_value)) {\r\n            this.setPromised(_value)\r\n        } else if (_value === none) {\r\n            this.setPromised(undefined)\r\n        }\r\n\r\n        let onSetUsedStoreStateMethods = () => {\r\n            this._stateMethods.reconstruct(\r\n                RootPath,\r\n                this.get(RootPath),\r\n                this.edition,\r\n                false\r\n            )\r\n        }\r\n        onSetUsedStoreStateMethods[IsUnmounted] = true\r\n\r\n        this._stateMethods = new StateMethodsImpl<StateValueAtRoot, {}>(\r\n            this,\r\n            RootPath,\r\n            this.get(RootPath),\r\n            this.edition,\r\n            onSetUsedStoreStateMethods\r\n        )\r\n        this.subscribe(this._stateMethods)\r\n    }\r\n\r\n    setPromised(promise: StateValueAtPath | undefined) {\r\n        this._value = none\r\n        this._promiseError = undefined\r\n        this._promiseResolver = undefined\r\n\r\n        if (!promise) {\r\n            this._promise = new Promise<StateValueAtRoot>(resolve => {\r\n                this._promiseResolver = resolve;\r\n            })\r\n            return;\r\n        }\r\n\r\n        promise = promise\r\n            .then((r: StateValueAtRoot) => {\r\n                if (this._promise === promise) {\r\n                    this._promise = undefined\r\n                    this._promiseError = undefined\r\n                    this._promiseResolver === undefined\r\n                    this.update(this._stateMethods.self(), this.set(RootPath, r, undefined))\r\n                }\r\n            })\r\n            .catch((err: StateValueAtRoot) => {\r\n                if (this._promise === promise) {\r\n                    this._promise = undefined\r\n                    this._promiseResolver = undefined\r\n                    this._promiseError = err\r\n                    this.edition += 1\r\n                    let ad = { path: RootPath };\r\n                    this.update(this._stateMethods.self(), ad)\r\n                }\r\n            })\r\n        this._promise = promise\r\n    }\r\n\r\n    activate(extensionFactory: ExtensionFactory<StateValueAtRoot, {}, StateExtensionUnknown> | undefined) {\r\n        if (this.edition < 0) {\r\n            this.edition = -this.edition\r\n        }\r\n        if (this._extension === undefined) {\r\n            this._extension = extensionFactory?.();\r\n            this._extensionMethods = this._extension?.onCreate?.(this._stateMethods.self(), {})\r\n            // this is invoked with all extension methods activated on the state\r\n            this._extension?.onInit?.(this._stateMethods.self(), this._extensionMethods || {})\r\n        }\r\n    }\r\n\r\n    deactivate() {\r\n        // TODO remove when plugins are deprecated\r\n        // old plugins do not support second activation\r\n        let params = this._value !== none ? { state: this._value } : {};\r\n        this._destroySubscribers.forEach(cb => cb(params))\r\n\r\n        if (this._extension) {\r\n            this._extension.onDestroy?.(this._stateMethods.self())\r\n            delete this._extension;\r\n            delete this._extensionMethods;\r\n        }\r\n        if (this.edition > 0) {\r\n            this.edition = -this.edition\r\n        }\r\n    }\r\n\r\n    get extension() {\r\n        return this._extensionMethods\r\n    }\r\n\r\n    get promise() {\r\n        return this._promise;\r\n    }\r\n\r\n    get promiseError() {\r\n        return this._promiseError;\r\n    }\r\n\r\n    get(path: Path) {\r\n        let result = this._value;\r\n        if (result === none) {\r\n            return result;\r\n        }\r\n        path.forEach(p => {\r\n            result = result[p];\r\n        });\r\n        return result;\r\n    }\r\n\r\n    set(path: Path, value: StateValueAtPath, mergeValue: Partial<StateValueAtPath> | undefined): SetActionDescriptor {\r\n        if (this.edition < 0) {\r\n            // TODO convert to console log\r\n            throw new StateInvalidUsageError(path, ErrorId.SetStateWhenDestroyed)\r\n        }\r\n\r\n        if (path.length === 0) {\r\n            // Root value UPDATE case,\r\n\r\n            const onSetArg: Writeable<PluginCallbacksOnSetArgument> = {\r\n                path: path,\r\n                state: value,\r\n                value: value,\r\n                previous: this._value,\r\n                merged: mergeValue\r\n            }\r\n            if (value === none) {\r\n                this.setPromised(undefined)\r\n                delete onSetArg.value\r\n                delete onSetArg.state\r\n            } else if (Object(value) === value && configuration.promiseDetector(value)) {\r\n                this.setPromised(value)\r\n                value = none\r\n                delete onSetArg.value\r\n                delete onSetArg.state\r\n            } else if (this._promise && !this._promiseResolver) {\r\n                throw new StateInvalidUsageError(path, ErrorId.SetStateWhenPromised)\r\n            } else {\r\n                this._promiseError = undefined\r\n            }\r\n\r\n            let prevValue = this._value;\r\n            if (prevValue === none) {\r\n                delete onSetArg.previous\r\n            }\r\n            this._value = value;\r\n            this.afterSet(onSetArg)\r\n\r\n            if (prevValue === none && this._value !== none && this._promiseResolver) {\r\n                this._promise = undefined\r\n                this._promiseError = undefined\r\n                let resolver = this._promiseResolver\r\n                this._promiseResolver === undefined\r\n                resolver(this._value)\r\n            }\r\n\r\n            return {\r\n                path\r\n            };\r\n        }\r\n\r\n        if (Object(value) === value && configuration.promiseDetector(value)) {\r\n            // TODO this one still can get into the state as nested property, need to check on read instead\r\n            throw new StateInvalidUsageError(path, ErrorId.SetStateNestedToPromised)\r\n        }\r\n\r\n        let target = this._value;\r\n        for (let i = 0; i < path.length - 1; i += 1) {\r\n            target = target[path[i]];\r\n        }\r\n\r\n        const p = path[path.length - 1]\r\n        if (p in target) {\r\n            if (value !== none) {\r\n                // Property UPDATE case\r\n                let prevValue = target[p]\r\n                target[p] = value;\r\n                this.afterSet({\r\n                    path: path,\r\n                    state: this._value,\r\n                    value: value,\r\n                    previous: prevValue,\r\n                    merged: mergeValue\r\n                })\r\n\r\n                return {\r\n                    path\r\n                };\r\n            } else {\r\n                // Property DELETE case\r\n                let prevValue = target[p]\r\n                if (Array.isArray(target) && typeof p === 'number') {\r\n                    target.splice(p, 1)\r\n                } else {\r\n                    delete target[p]\r\n                }\r\n                this.afterSet({\r\n                    path: path,\r\n                    state: this._value,\r\n                    previous: prevValue,\r\n                    merged: mergeValue\r\n                })\r\n\r\n                // if an array of objects is about to loose existing property\r\n                // we consider it is the whole object is changed\r\n                // which is identified by upper path\r\n                return {\r\n                    path: path.slice(0, -1),\r\n                    actions: { [p]: \"D\" as \"D\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (value !== none) {\r\n            // Property INSERT case\r\n            target[p] = value;\r\n            this.afterSet({\r\n                path: path,\r\n                state: this._value,\r\n                value: value,\r\n                merged: mergeValue\r\n            })\r\n\r\n            // if an array of objects is about to be extended by new property\r\n            // we consider it is the whole object is changed\r\n            // which is identified by upper path\r\n            return {\r\n                path: path.slice(0, -1),\r\n                actions: { [p]: \"I\" as \"I\" }\r\n            }\r\n        }\r\n\r\n        // Non-existing property DELETE case\r\n        // no-op\r\n        return {\r\n            path\r\n        };\r\n    }\r\n\r\n    preset(state: State<StateValueAtPath, StateExtensionUnknown>, value: StateValueAtPath) {\r\n        this._extension?.onPreset?.(state, value)\r\n    }\r\n\r\n    premerge(state: State<StateValueAtPath, StateExtensionUnknown>, value: StateValueAtPath) {\r\n        this._extension?.onPremerge?.(state, value)\r\n    }\r\n\r\n    update(state: State<StateValueAtPath, StateExtensionUnknown>, ad: SetActionDescriptor) {\r\n        this._extension?.onSet?.(state, ad)\r\n\r\n        const actions = new Set<() => void>();\r\n        // check if actions descriptor can be unfolded into a number of individual update actions\r\n        // this is the case when merge call swaps to properties for example\r\n        // so we optimize rerendering only these properties\r\n        if (ad.actions && Object.values(ad.actions).findIndex(i => i !== \"U\") === -1) {\r\n            // all actions are update actions\r\n            Object.keys(ad.actions).forEach(key => {\r\n                this._subscribers.forEach(s => s.onSet({ path: ad.path.concat(key) }, actions));\r\n            })\r\n        } else {\r\n            this._subscribers.forEach(s => s.onSet(ad, actions));\r\n        }\r\n        actions.forEach(a => a());\r\n    }\r\n\r\n    afterSet(params: PluginCallbacksOnSetArgument) {\r\n        if (this.edition > 0) {\r\n            this.edition += 1;\r\n        }\r\n        if (this.edition < 0) {\r\n            this.edition -= 1;\r\n        }\r\n        this._setSubscribers.forEach(cb => cb(params))\r\n    }\r\n\r\n    getPlugin(pluginId: symbol) {\r\n        return this._plugins.get(pluginId)\r\n    }\r\n\r\n    register(plugin: Plugin) {\r\n        const existingInstance = this._plugins.get(plugin.id)\r\n        if (existingInstance) {\r\n            return;\r\n        }\r\n\r\n        const pluginCallbacks = plugin.init ? plugin.init(this._stateMethods.self()) : {};\r\n        this._plugins.set(plugin.id, pluginCallbacks);\r\n        if (pluginCallbacks.onSet) {\r\n            this._setSubscribers.add((p) => pluginCallbacks.onSet!(p))\r\n        }\r\n        if (pluginCallbacks.onDestroy) {\r\n            this._destroySubscribers.add((p) => pluginCallbacks.onDestroy!(p))\r\n        }\r\n    }\r\n\r\n    toMethods() {\r\n        return this._stateMethods;\r\n    }\r\n\r\n    subscribe(l: Subscriber) {\r\n        this._subscribers.add(l);\r\n    }\r\n\r\n    unsubscribe(l: Subscriber) {\r\n        this._subscribers.delete(l);\r\n    }\r\n\r\n    destroy() {\r\n        this.deactivate()\r\n    }\r\n\r\n    toJSON() {\r\n        throw new StateInvalidUsageError(RootPath, ErrorId.ToJson_Value);\r\n    }\r\n}\r\n\r\n// use symbol property to allow for easier reference finding\r\nconst UnusedValue = Symbol('UnusedValue');\r\n\r\n// use symbol to mark that a function has no effect anymore\r\nconst IsUnmounted = Symbol('IsUnmounted');\r\n\r\n// TODO remove from the docs IE11 support\r\n\r\nclass StateMethodsImpl<S, E> implements StateMethods<S, E>, StateMethodsDestroy, Subscribable, Subscriber {\r\n    private subscribers: Set<Subscriber> | undefined;\r\n\r\n    private childrenCreated: Record<string | number, StateMethodsImpl<StateValueAtPath, E>> | undefined;\r\n    private childrenUsedPrevious: Record<string | number, StateMethodsImpl<StateValueAtPath, E>> | undefined;\r\n    private childrenUsed: Record<string | number, StateMethodsImpl<StateValueAtPath, E>> | undefined;\r\n\r\n    private valueUsedNoProxy: boolean | undefined;\r\n    private valueUsedNoProxyPrevious: boolean | undefined;\r\n    private valueUsed: StateValueAtPath = UnusedValue;\r\n\r\n    private selfUsed: State<S, E> | undefined;\r\n\r\n    get [__state](): [S, E] {\r\n        return [this.get(), this.self() as E]\r\n    };\r\n\r\n    constructor(\r\n        public readonly store: Store,\r\n        public path: Path,\r\n        private valueSource: S,\r\n        private valueEdition: number,\r\n        private onSetUsed: () => void\r\n    ) { }\r\n\r\n    reconstruct(path: Path, valueSource: S, valueEdition: number, reset: boolean) {\r\n        this.path = path;\r\n        this.valueSource = valueSource;\r\n        this.valueEdition = valueEdition;\r\n        this.valueUsed = UnusedValue;\r\n\r\n        if (reset) {\r\n            delete this.selfUsed;\r\n            delete this.childrenCreated\r\n            delete this.childrenUsedPrevious\r\n        } else {\r\n            this.valueUsedNoProxyPrevious = this.valueUsedNoProxy;\r\n            this.childrenUsedPrevious = this.childrenUsed;\r\n        }\r\n        delete this.valueUsedNoProxy;\r\n        delete this.childrenUsed\r\n\r\n        // We should not delete subscribers as these are self cleaned up when unmounted\r\n        // Theoretically it is possible to reconnect subscribers like we done it for \r\n        // children, but it is easier and more efficient to leave subscribers to have independent lifecycle\r\n        // If we delete subscribers here, scoped states wrapped in React.memo\r\n        // will lose state change propagation and rerendering for scopped states\r\n        // delete this.subscribers;\r\n    }\r\n\r\n    reconnect() {\r\n        // Mark it's as used, because it is used in a dependency list\r\n        // (we are making it's value used implicitly, so rerender is triggered).\r\n        // Otherwise, no rerender => no effects running, even when a value is changed.\r\n        // This is marking the state used a bit more than it might be really used\r\n        // in the effect callback. More optimized / precise implementation would be\r\n        // to remember useSelf as previous (similar to childrenUsed),\r\n        // but it is a lot more complicated and the benefit is not worth the complexity.\r\n        // So, mark it used.\r\n        // We also using it without proxy if it wass used without proxy during the\r\n        // previous render, because otherwise children usage might be not traced completely\r\n        // and so will not result in renreder if children are updated.\r\n        // This is covered by some tests, but there are so many possible corner cases...\r\n        this.get({ __internalAllowPromised: true, noproxy: this.valueUsedNoProxyPrevious })\r\n        this.childrenUsed = {\r\n            ...this.childrenUsedPrevious,\r\n            ...this.childrenUsed\r\n        }\r\n    }\r\n\r\n    getUntracked(__internalAllowPromised?: boolean) {\r\n        if (this.valueEdition !== this.store.edition) {\r\n            this.valueSource = this.store.get(this.path)\r\n            this.valueEdition = this.store.edition\r\n\r\n            if (this.valueUsed !== UnusedValue) {\r\n                this.valueUsed = UnusedValue\r\n                this.get({ __internalAllowPromised: true }) // renew cache to keep it marked used\r\n            }\r\n        }\r\n        if (__internalAllowPromised) {\r\n            return this.valueSource\r\n        }\r\n        if (this.store.promiseError) {\r\n            throw this.store.promiseError;\r\n        }\r\n        if (this.store.promise) {\r\n            throw new StateInvalidUsageError(this.path, ErrorId.GetStateWhenPromised)\r\n        }\r\n        return this.valueSource;\r\n    }\r\n\r\n    get(options?: { noproxy?: boolean, stealth?: boolean, __internalAllowPromised?: boolean }) {\r\n        const valueSource = this.getUntracked(options?.__internalAllowPromised)\r\n        if (options?.stealth) {\r\n            return valueSource;\r\n        }\r\n        if (this.valueUsed === UnusedValue) {\r\n            if (Array.isArray(valueSource)) {\r\n                this.valueUsed = this.valueArrayImpl(valueSource as unknown as StateValueAtPath[]);\r\n            } else if (Object(valueSource) === valueSource) {\r\n                if ((valueSource as StateValueAtPath).constructor?.name === \"Object\") {\r\n                    this.valueUsed = this.valueObjectImpl(valueSource as unknown as object);\r\n                } else {\r\n                    // any other object except Object, for example Date\r\n                    this.valueUsedNoProxy = true\r\n                    this.valueUsed = valueSource;\r\n                }\r\n            } else {\r\n                this.valueUsed = valueSource;\r\n            }\r\n        }\r\n        if (options?.noproxy) {\r\n            this.valueUsedNoProxy = true\r\n            return valueSource;\r\n        }\r\n        return this.valueUsed as S;\r\n    }\r\n\r\n    get value(): S {\r\n        // various tools, including react dev tools and webpack import\r\n        // inspect an object and it's properties\r\n        // so these should not throw\r\n        // return this.get({ __internalAllowPromised: true })\r\n        return this.get()\r\n    }\r\n\r\n    // TODO remove when attach is removed\r\n    setUntracked(newValue: SetStateAction<S>, mergeValue?: Partial<StateValueAtPath>): Path[] {\r\n        let r = this.setUntrackedV4(newValue, mergeValue);\r\n        if (r) {\r\n            return [r.path]\r\n        }\r\n        return []\r\n    }\r\n\r\n    // TODO remove mergeValue when attach is removed\r\n    setUntrackedV4(newValue: SetStateAction<S>, mergeValue?: Partial<StateValueAtPath>): SetActionDescriptor | null {\r\n        if (typeof newValue === 'function') {\r\n            newValue = (newValue as ((prevValue: S) => S))(this.getUntracked());\r\n        }\r\n        this.store.preset(this.self() as unknown as State<StateValueAtPath, {}>, newValue)\r\n\r\n        if (Object(newValue) === newValue && newValue[SelfMethodsID]) {\r\n            // TODO check on read instead as it might escape as nested on set anyway\r\n            throw new StateInvalidUsageError(this.path, ErrorId.SetStateToValueFromState)\r\n        }\r\n        if (newValue !== Object(newValue) && newValue === this.getUntracked(true)) {\r\n            // this is primitive value and has not changed\r\n            // so skip this set call as it does not make an effect\r\n            return null\r\n        }\r\n        return this.store.set(this.path, newValue, mergeValue);\r\n    }\r\n\r\n    set(newValue: SetStateAction<S>) {\r\n        let ad = this.setUntrackedV4(newValue);\r\n        if (ad) {\r\n            this.store.update(this.self() as State<StateValueAtPath, StateExtensionUnknown>, ad);\r\n        }\r\n    }\r\n\r\n    mergeUntracked(sourceValue: SetPartialStateAction<S>): Path[] {\r\n        let r = this.mergeUntrackedV4(sourceValue);\r\n        if (r) {\r\n            return [r.path]\r\n        }\r\n        return []\r\n    }\r\n\r\n    mergeUntrackedV4(sourceValue: SetPartialStateAction<S>): SetActionDescriptor | null {\r\n        const currentValue = this.getUntracked()\r\n        if (typeof sourceValue === 'function') {\r\n            sourceValue = (sourceValue as Function)(currentValue);\r\n        }\r\n        this.store.premerge(this.self() as unknown as State<StateValueAtPath, {}>, sourceValue)\r\n\r\n        if (Array.isArray(currentValue)) {\r\n            if (Array.isArray(sourceValue)) {\r\n                let ad: Required<SetActionDescriptor> = { path: this.path, actions: {} };\r\n                sourceValue.forEach((e, i) => {\r\n                    ad.actions[currentValue.push(e) - 1] = \"I\"\r\n                })\r\n                if (Object.keys(ad.actions).length > 0) {\r\n                    this.setUntrackedV4(currentValue, sourceValue)\r\n                    return ad\r\n                }\r\n                return null\r\n            } else {\r\n                let ad: Required<SetActionDescriptor> = { path: this.path, actions: {} };\r\n                const deletedIndexes: number[] = []\r\n                Object.keys(sourceValue).sort().forEach(i => {\r\n                    const index = Number(i);\r\n                    const newPropValue = sourceValue[index]\r\n                    if (newPropValue === none) {\r\n                        ad.actions[index] = \"D\"\r\n                        deletedIndexes.push(index)\r\n                    } else {\r\n                        if (index in currentValue) {\r\n                            ad.actions[index] = \"U\"\r\n                        } else {\r\n                            ad.actions[index] = \"I\"\r\n                        }\r\n                        (currentValue as StateValueAtPath[])[index] = newPropValue\r\n                    }\r\n                });\r\n                // indexes are ascending sorted as per above\r\n                // so, delete one by one from the end\r\n                // this way index positions do not change\r\n                deletedIndexes.reverse().forEach(p => {\r\n                    (currentValue as unknown as []).splice(p, 1)\r\n                })\r\n                if (Object.keys(ad.actions).length > 0) {\r\n                    this.setUntrackedV4(currentValue, sourceValue)\r\n                    return ad\r\n                }\r\n                return null\r\n            }\r\n        } else if (Object(currentValue) === currentValue) {\r\n            let ad: Required<SetActionDescriptor> = { path: this.path, actions: {} };\r\n            Object.keys(sourceValue).forEach(key => {\r\n                const newPropValue = sourceValue[key]\r\n                if (newPropValue === none) {\r\n                    ad.actions[key] = \"D\"\r\n                    delete currentValue[key]\r\n                } else {\r\n                    if (key in currentValue) {\r\n                        ad.actions[key] = \"U\"\r\n                    } else {\r\n                        ad.actions[key] = \"I\"\r\n                    }\r\n                    currentValue[key] = newPropValue\r\n                }\r\n            })\r\n            if (Object.keys(ad.actions).length > 0) {\r\n                this.setUntrackedV4(currentValue, sourceValue)\r\n                return ad\r\n            }\r\n            return null\r\n        } else if (typeof currentValue === 'string') {\r\n            return this.setUntrackedV4((currentValue + String(sourceValue)) as unknown as S, sourceValue)\r\n        } else {\r\n            return this.setUntrackedV4(sourceValue as S)\r\n        }\r\n    }\r\n\r\n    merge(sourceValue: SetPartialStateAction<S>) {\r\n        let r = this.mergeUntrackedV4(sourceValue);\r\n        if (r) {\r\n            this.store.update(this.self() as State<StateValueAtPath, StateExtensionUnknown>, r)\r\n        }\r\n    }\r\n\r\n    nested<K extends keyof S>(key: K): State<S[K], E> {\r\n        return this.child(key as string | number).self() as State<S[K], E>\r\n    }\r\n\r\n    rerender(paths: Path[]) {\r\n        for (let path of paths) {\r\n            this.store.update(this.self() as State<StateValueAtPath, StateExtensionUnknown>, { path })\r\n        }\r\n    }\r\n\r\n    destroy(): void {\r\n        this.store.destroy()\r\n    }\r\n\r\n    subscribe(l: Subscriber) {\r\n        if (this.subscribers === undefined) {\r\n            this.subscribers = new Set();\r\n        }\r\n        this.subscribers.add(l);\r\n    }\r\n\r\n    unsubscribe(l: Subscriber) {\r\n        if (this.subscribers) {\r\n            this.subscribers.delete(l);\r\n        }\r\n    }\r\n\r\n    get isMounted(): boolean {\r\n        return !this.onSetUsed[IsUnmounted]\r\n    }\r\n\r\n    onMount() {\r\n        delete this.onSetUsed[IsUnmounted];\r\n    }\r\n\r\n    onUnmount() {\r\n        this.onSetUsed[IsUnmounted] = true\r\n    }\r\n\r\n    onSet(ad: SetActionDescriptor, actions: Set<() => void>): boolean {\r\n        const update = () => {\r\n            let isAffected = false\r\n            if (this.valueUsedNoProxy\r\n                // TODO this condition becomes redundant when Downgraded plugins is deleted\r\n                && this.valueUsed !== UnusedValue) {\r\n                actions.add(this.onSetUsed);\r\n                delete this.selfUsed;\r\n                isAffected = true;\r\n            }\r\n            let path = ad.path;\r\n            const nextChildKey = path[this.path.length];\r\n            if (nextChildKey === undefined) {\r\n                // There is no next child to dive into\r\n                // So it is this one which was updated\r\n                if (this.valueUsed !== UnusedValue) {\r\n                    actions.add(this.onSetUsed);\r\n                    delete this.selfUsed;\r\n                    delete this.childrenUsed;\r\n\r\n                    if (ad.actions && this.childrenCreated) {\r\n                        // TODO add automated unit tests for this part\r\n                        if (Array.isArray(this.valueSource)\r\n                            && Object.values(ad.actions).includes(\"D\")) {\r\n                            // this is an array and some elements were removed\r\n                            // so invalidate cache for all children after the first deleted\r\n                            let firstDeletedIndex = Object.keys(ad.actions)\r\n                                .map(i => Number(i))\r\n                                .sort()\r\n                                .find(i => ad.actions?.[i] === \"D\")!\r\n                            for (let childKey in this.childrenCreated) {\r\n                                if (Number(childKey) >= firstDeletedIndex ||\r\n                                    childKey in ad.actions) {\r\n                                    delete this.childrenCreated[childKey]\r\n                                }\r\n                            }\r\n                        } else {\r\n                            for (let childKey in ad.actions) {\r\n                                delete this.childrenCreated[childKey]\r\n                            }\r\n                        }\r\n                    } else {\r\n                        delete this.childrenCreated;\r\n                    }\r\n                    return true;\r\n                }\r\n            } else {\r\n                const nextChild = this.childrenUsed?.[nextChildKey];\r\n                if (nextChild && nextChild.onSet(ad, actions)) {\r\n                    delete this.selfUsed;\r\n                    return true;\r\n                }\r\n            }\r\n            return isAffected;\r\n        }\r\n\r\n        const updated = update();\r\n        if (!updated && this.subscribers !== undefined) {\r\n            this.subscribers.forEach(s => {\r\n                if (s.onSet(ad, actions)) {\r\n                    delete this.selfUsed;\r\n                }\r\n            })\r\n        }\r\n        return updated;\r\n    }\r\n\r\n    get keys(): InferStateKeysType<S> {\r\n        const value = this.get()\r\n        if (Array.isArray(value)) {\r\n            return Object.keys(value).map(i => Number(i)).filter(i => Number.isInteger(i)) as\r\n                unknown as InferStateKeysType<S>;\r\n        }\r\n        if (Object(value) === value) {\r\n            return Object.keys(value) as unknown as InferStateKeysType<S>;\r\n        }\r\n        return undefined as InferStateKeysType<S>;\r\n    }\r\n\r\n    child(key: number | string) {\r\n        this.childrenUsed = this.childrenUsed || {};\r\n        const cachedChild = this.childrenUsed.hasOwnProperty(key) && this.childrenUsed[key];\r\n        if (cachedChild) {\r\n            return cachedChild;\r\n        }\r\n\r\n        const valueSource = this.valueSource[key]\r\n        if (typeof valueSource === 'function') {\r\n            // hitting a method of a custom type, should be no-op\r\n            throw new StateInvalidUsageError(this.path, ErrorId.GetProperty_Function)\r\n        }\r\n        this.childrenCreated = this.childrenCreated || {};\r\n        const child = this.childrenCreated[key];\r\n        let r;\r\n        if (child) {\r\n            child.reconstruct(\r\n                this.path.concat(key),\r\n                valueSource,\r\n                this.valueEdition,\r\n                false\r\n            )\r\n            r = child;\r\n        } else {\r\n            r = new StateMethodsImpl<StateValueAtPath, E>(\r\n                this.store,\r\n                this.path.concat(key),\r\n                valueSource,\r\n                this.valueEdition,\r\n                this.onSetUsed,\r\n            )\r\n            this.childrenCreated[key] = r;\r\n        }\r\n        if (this.valueUsedNoProxy) {\r\n            // TODO this is redundant when Downgraded plugin is deleted\r\n            r.valueUsedNoProxy = true;\r\n        }\r\n        this.childrenUsed[key] = r;\r\n        return r;\r\n    }\r\n\r\n    private valueArrayImpl(currentValue: StateValueAtPath[]): S {\r\n        return proxyWrap(this.path, currentValue,\r\n            () => currentValue,\r\n            (target: object, key: PropertyKey) => {\r\n                if (key === 'length') {\r\n                    return (target as []).length;\r\n                }\r\n                if (key in Array.prototype) {\r\n                    return Array.prototype[key];\r\n                }\r\n                if (key === SelfMethodsID) {\r\n                    return this;\r\n                }\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    return target[key];\r\n                }\r\n                const index = Number(key);\r\n                if (!Number.isInteger(index)) {\r\n                    return undefined;\r\n                }\r\n                return this.child(index).get();\r\n            },\r\n            (target: object, key: PropertyKey, value: StateValueAtPath) => {\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_Value)\r\n            },\r\n            true\r\n        ) as unknown as S;\r\n    }\r\n\r\n    private valueObjectImpl(currentValue: object): S {\r\n        return proxyWrap(this.path, currentValue,\r\n            () => currentValue,\r\n            (target: object, key: PropertyKey) => {\r\n                if (key in Object.prototype) {\r\n                    return Object.prototype[key];\r\n                }\r\n                if (key === SelfMethodsID) {\r\n                    return this;\r\n                }\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    return target[key];\r\n                }\r\n                return this.child(key).get();\r\n            },\r\n            (target: object, key: PropertyKey, value: StateValueAtPath) => {\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_Value)\r\n            },\r\n            true\r\n        ) as unknown as S;\r\n    }\r\n\r\n    self(): State<S, E> {\r\n        if (this.selfUsed) {\r\n            return this.selfUsed\r\n        }\r\n\r\n        const getter = (_: object, key: PropertyKey) => {\r\n            if (key === self) {\r\n                return this\r\n            }\r\n            if (typeof key === 'symbol') {\r\n                return undefined\r\n            }\r\n            if (key === 'toJSON') {\r\n                throw new StateInvalidUsageError(this.path, ErrorId.ToJson_State);\r\n            }\r\n\r\n            let nestedGetter = (prop: PropertyKey) => {\r\n                const currentValue = this.get({ __internalAllowPromised: prop === '$$typeof' || prop === 'constructor' });\r\n\r\n                if (prop in Object.prototype) {\r\n                    // Mark it used entirely, so changes to the value\r\n                    // invalidate and rerender results for Object.prototype.toString(),\r\n                    // for example.\r\n                    // We check for Object prototype functions\r\n                    // even for primitive values, because primitive values still\r\n                    // can have object methods.\r\n                    return Object.prototype[prop];\r\n                }\r\n\r\n                if (// if currentValue is primitive type\r\n                    (Object(currentValue) !== currentValue) &&\r\n                    // if promised, it will be none\r\n                    currentValue !== none) {\r\n                    // This was an error case, but various tools like webpack bundler\r\n                    // and react dev tools attempt to get props out of non-null object,\r\n                    // so this was changed to return just undefined for any property request\r\n                    // as there is no way to fix 3rd party tools.\r\n                    // Logging a warning to console is also not an option\r\n                    // as it pollutes console for legitimate apps on app start app.\r\n                    // Ref: https://github.com/avkonst/hookstate/issues/125\r\n                    return undefined\r\n                }\r\n\r\n                if (Array.isArray(currentValue)) {\r\n                    if (prop === 'length') {\r\n                        return currentValue.length;\r\n                    }\r\n                    if (prop in Array.prototype) {\r\n                        return Array.prototype[prop];\r\n                    }\r\n                    const index = Number(prop);\r\n                    if (!Number.isInteger(index)) {\r\n                        return undefined;\r\n                    }\r\n                    return this.nested(index as keyof S)\r\n                }\r\n                return this.nested(prop.toString() as keyof S)\r\n            }\r\n\r\n            switch (key) {\r\n                case 'path':\r\n                    return this.path\r\n                case 'keys':\r\n                    return this.keys\r\n                case 'value':\r\n                    return this.value\r\n                case 'ornull':\r\n                    return this.ornull\r\n                case 'promised':\r\n                    return this.promised\r\n                case 'promise':\r\n                    return this.promise\r\n                case 'error':\r\n                    return this.error\r\n                case 'get':\r\n                    return (opts: { noproxy: boolean, stealth: boolean }) => this.get(opts)\r\n                case 'set':\r\n                    return (p: SetStateAction<S>) => this.set(p)\r\n                case 'merge':\r\n                    return (p: SetPartialStateAction<S>) => this.merge(p)\r\n                case 'nested':\r\n                    return (p: keyof S) => nestedGetter(p)\r\n                case 'attach':\r\n                    return (p: symbol) => this.attach(p)\r\n                case 'destroy': // TODO move destroy to the state, otherwise State type hides this well existing property\r\n                    // TODO when depreacted update hookstate-106 exception docs\r\n                    return () => this.destroy()\r\n                default:\r\n                    // check if extension method\r\n                    let ext = this.store.extension\r\n                    if (ext && key in ext) {\r\n                        return ext[key](this.self())\r\n                    }\r\n                    // otherwise nested child\r\n                    return nestedGetter(key)\r\n            }\r\n        }\r\n\r\n        this.selfUsed = proxyWrap(this.path, this.valueSource,\r\n            (opts) => {\r\n                return this.get({ __internalAllowPromised: true, stealth: opts?.stealth });\r\n            },\r\n            getter,\r\n            (_, key, value) => {\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_State)\r\n            },\r\n            false) as unknown as State<S, E>;\r\n        return this.selfUsed\r\n    }\r\n\r\n    get promised(): boolean {\r\n        this.get({ __internalAllowPromised: true }) // marks used\r\n        return !!this.store.promise;\r\n    }\r\n\r\n    get promise(): Promise<State<S, E>> | undefined {\r\n        this.get({ __internalAllowPromised: true }) // marks used\r\n        return this.store.promise?.then(_ => this.self());\r\n    }\r\n\r\n    get error(): StateErrorAtRoot | undefined {\r\n        this.get({ __internalAllowPromised: !!this.store.promiseError }) // marks used\r\n        return this.store.promiseError;\r\n    }\r\n\r\n    get ornull(): InferStateOrnullType<S, E> {\r\n        const value = this.get()\r\n        if (value === null || value === undefined) {\r\n            return value as unknown as InferStateOrnullType<S, E>;\r\n        }\r\n        return this.self() as InferStateOrnullType<S, E>;\r\n    }\r\n\r\n    attach(plugin: () => Plugin): State<S, E>\r\n    attach(pluginId: symbol): [PluginCallbacks | Error, PluginStateControl<S>]\r\n    attach(p: (() => Plugin) | symbol):\r\n        State<S, E> | [PluginCallbacks | Error, PluginStateControl<S>] {\r\n        if (typeof p === 'function') {\r\n            const pluginMeta = p();\r\n            if (pluginMeta.id === DowngradedID) {\r\n                this.valueUsedNoProxy = true;\r\n                if (this.valueUsed !== UnusedValue) {\r\n                    const currentValue = this.getUntracked(true);\r\n                    this.valueUsed = currentValue;\r\n                }\r\n                return this.self();\r\n            }\r\n            this.store.register(pluginMeta);\r\n            return this.self();\r\n        } else {\r\n            return [\r\n                this.store.getPlugin(p) ||\r\n                (new StateInvalidUsageError(this.path, ErrorId.GetUnknownPlugin, p.toString())),\r\n                this\r\n            ];\r\n        }\r\n    }\r\n}\r\n\r\nfunction proxyWrap(\r\n    path: Path,\r\n    // tslint:disable-next-line: no-any\r\n    targetBootstrap: any,\r\n    // tslint:disable-next-line: no-any\r\n    targetGetter: (opts?: { stealth?: boolean }) => any,\r\n    // tslint:disable-next-line: no-any\r\n    propertyGetter: (unused: any, key: PropertyKey) => any,\r\n    // tslint:disable-next-line: no-any\r\n    propertySetter: (unused: any, p: PropertyKey, value: any, receiver: any) => boolean,\r\n    isValueProxy: boolean\r\n) {\r\n    const onInvalidUsage = (op: ErrorId) => {\r\n        throw new StateInvalidUsageError(path, op)\r\n    }\r\n    if (Object(targetBootstrap) !== targetBootstrap) {\r\n        targetBootstrap = {}\r\n    }\r\n    return new Proxy(targetBootstrap, {\r\n        getPrototypeOf: (_target) => {\r\n            // should satisfy the invariants:\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf#Invariants\r\n            const targetReal = targetGetter()\r\n            if (targetReal === undefined || targetReal === null) {\r\n                return null;\r\n            }\r\n            if (targetReal === none) {\r\n                return Object.getPrototypeOf(new Promise(() => { }));\r\n            }\r\n            return Object.getPrototypeOf(targetReal);\r\n        },\r\n        setPrototypeOf: (_target, v) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.SetPrototypeOf_State :\r\n                ErrorId.SetPrototypeOf_Value)\r\n        },\r\n        isExtensible: (_target) => {\r\n            // should satisfy the invariants:\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible#Invariants\r\n            return true; // required to satisfy the invariants of the getPrototypeOf\r\n            // return Object.isExtensible(target);\r\n        },\r\n        preventExtensions: (_target) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.PreventExtensions_State :\r\n                ErrorId.PreventExtensions_Value)\r\n        },\r\n        getOwnPropertyDescriptor: (_target, p) => {\r\n            const targetReal = targetGetter()\r\n\r\n            if (Object(targetReal) === targetReal) {\r\n                const origin = Object.getOwnPropertyDescriptor(targetReal, p);\r\n                if (Array.isArray(targetReal) && p in Array.prototype) {\r\n                    return origin;\r\n                }\r\n                return origin && {\r\n                    // should be configurable as may not exist on proxy target\r\n                    configurable: true, // JSON.stringify() does not work for an object without it\r\n                    enumerable: origin.enumerable,\r\n                    get: () => propertyGetter(targetReal, p),\r\n                    set: undefined\r\n                };\r\n            }\r\n\r\n            if (isValueProxy || targetReal === none) {\r\n                return undefined;\r\n            }\r\n            if (p === 'value') {\r\n                return {\r\n                    // should be configurable as does not exist on proxy target\r\n                    configurable: true,\r\n                    enumerable: true,\r\n                    get: () => targetGetter({ stealth: true }),\r\n                    set: undefined\r\n                };\r\n            }\r\n            if (p === 'path') {\r\n                return {\r\n                    // should be configurable as does not exist on proxy target\r\n                    configurable: true,\r\n                    enumerable: true,\r\n                    get: () => path,\r\n                    set: undefined\r\n                };\r\n            }\r\n            return undefined;\r\n        },\r\n        has: (_target, p) => {\r\n            if (typeof p === 'symbol') {\r\n                return false;\r\n            }\r\n            const targetReal = targetGetter()\r\n            if (Object(targetReal) === targetReal) {\r\n                return p in targetReal;\r\n            }\r\n            if (isValueProxy || targetReal === none) {\r\n                return false;\r\n            }\r\n            return p === 'value' || p === 'path';\r\n        },\r\n        get: propertyGetter,\r\n        set: propertySetter,\r\n        deleteProperty: (_target, p) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.DeleteProperty_State :\r\n                ErrorId.DeleteProperty_Value)\r\n        },\r\n        defineProperty: (_target, p, attributes) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.DefineProperty_State :\r\n                ErrorId.DefineProperty_Value)\r\n        },\r\n        ownKeys: (_target) => {\r\n            const targetReal = targetGetter()\r\n            if (Array.isArray(targetReal)) {\r\n                if (_target.length === undefined) {\r\n                    // an object turned into an array now\r\n                    // inject length property now as it is defined on the array\r\n                    // to enable getOwnPropertyDescriptor for length not throw\r\n                    Object.defineProperty(targetBootstrap, 'length', {\r\n                        value: 0, writable: true, enumerable: false, configurable: false\r\n                    })\r\n                }\r\n            }\r\n            if (Object(targetReal) === targetReal) {\r\n                return Object.getOwnPropertyNames(targetReal);\r\n            }\r\n            if (isValueProxy || targetReal === none) {\r\n                return []\r\n            }\r\n            return ['value', 'path']\r\n        },\r\n        apply: (_target, thisArg, argArray?) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.Apply_State :\r\n                ErrorId.Apply_Value)\r\n        },\r\n        construct: (_target, argArray, newTarget?) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.Construct_State :\r\n                ErrorId.Construct_Value)\r\n        }\r\n    });\r\n}\r\n\r\nfunction createStore<S, E>(initial: SetInitialStateAction<S>): Store {\r\n    let initialValue: S | Promise<S> = initial as (S | Promise<S>);\r\n    if (typeof initial === 'function') {\r\n        initialValue = (initial as (() => S | Promise<S>))();\r\n    }\r\n    if (Object(initialValue) === initialValue && initialValue[SelfMethodsID]) {\r\n        throw new StateInvalidUsageError(RootPath, ErrorId.InitStateToValueFromState)\r\n    }\r\n    return new Store(initialValue);\r\n}\r\n\r\nexport interface Configuration {\r\n    interceptDependencyListsMode: 'always' | 'development' | 'never',\r\n    isDevelopmentMode: boolean,\r\n    promiseDetector: (p: any) => boolean,\r\n}\r\nlet configuration: Configuration & { hiddenInterceptDependencyListsModeDebug: boolean } = {\r\n    interceptDependencyListsMode: 'always',\r\n    // TODO this does not always work, so it is better if it is set by the app explictly. Document this\r\n    isDevelopmentMode: typeof process === 'object' &&\r\n        typeof process.env === 'object' &&\r\n        process.env.NODE_ENV === 'development',\r\n    promiseDetector: (p) => Promise.resolve(p) === p,\r\n    hiddenInterceptDependencyListsModeDebug: false\r\n}\r\n// TODO document\r\nexport function configure(config: Partial<Configuration>) {\r\n    configuration = {\r\n        interceptDependencyListsMode: config.interceptDependencyListsMode ?? configuration.interceptDependencyListsMode,\r\n        isDevelopmentMode: config.isDevelopmentMode ?? configuration.isDevelopmentMode,\r\n        promiseDetector: config.promiseDetector ?? configuration.promiseDetector,\r\n        hiddenInterceptDependencyListsModeDebug: false\r\n    }\r\n\r\n    interceptReactHooks() // not really required, but for safety\r\n\r\n    if (configuration.interceptDependencyListsMode === 'never') {\r\n        configuration.hiddenInterceptDependencyListsModeDebug = false;\r\n        React['useEffect'] = React['useEffect'] && useEffectOrigin;\r\n        React['useLayoutEffect'] = React['useLayoutEffect'] && useLayoutEffectOrigin;\r\n        React['useInsertionEffect'] = React['useInsertionEffect'] && useInsertionEffectOrigin;\r\n        React['useImperativeHandle'] = React['useImperativeHandle'] && useImperativeHandleOrigin;\r\n        React['useMemo'] = React['useMemo'] && useMemoOrigin;\r\n        React['useCallback'] = React['useCallback'] && useCallbackOrigin;\r\n        // the following does not make an effect as memo calls happen on module load\r\n        // so it is always set to memoIntercept\r\n        React['memo'] = React['memo'] && memoOrigin as any;\r\n    } else {\r\n        // do not intercept if a hook is not defined in React\r\n        // otherwise, it will enable 3rd party libs thinking the react runs at version 18\r\n        React['useEffect'] = React['useEffect'] && useEffectIntercept;\r\n        React['useLayoutEffect'] = React['useLayoutEffect'] && useLayoutEffectIntercept;\r\n        React['useInsertionEffect'] = React['useLayoutEffect'] && useInsertionEffectIntercept;\r\n        React['useImperativeHandle'] = React['useImperativeHandle'] && useImperativeHandleIntercept;\r\n        React['useMemo'] = React['useMemo'] && useMemoIntercept;\r\n        React['useCallback'] = React['useCallback'] && useCallbackIntercept;\r\n        // the following does not make an effect as memo calls happen on module load\r\n        // so it is always set to memoIntercept\r\n        React['memo'] = React['memo'] && memoIntercept as any;\r\n        if (configuration.interceptDependencyListsMode === 'development'\r\n            && configuration.isDevelopmentMode) {\r\n            configuration.hiddenInterceptDependencyListsModeDebug = true;\r\n        }\r\n    }\r\n}\r\n\r\nfunction reconnectDependencies(deps?: React.DependencyList, fromIntercept?: boolean): React.DependencyList | undefined {\r\n    for (const i of deps || []) {\r\n        if (i === Object(i)) {\r\n            let state = (i as any)[self] as StateMethodsImpl<StateValueAtPath, {}> | undefined\r\n            if (state) {\r\n                if (fromIntercept && configuration.hiddenInterceptDependencyListsModeDebug) {\r\n                    // TODO document this exception\r\n                    throw new StateInvalidUsageError(state.path, ErrorId.StateUsedInDependencyList)\r\n                }\r\n                state.reconnect()\r\n            }\r\n        }\r\n    }\r\n    return deps;\r\n}\r\n\r\nlet useEffectOrigin: (effect: React.EffectCallback, deps?: React.DependencyList) => void;\r\nexport function useHookstateEffect(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps)\r\n    return useEffectOrigin(effect, deps)\r\n}\r\nfunction useEffectIntercept(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps, true)\r\n    return useEffectOrigin(effect, deps)\r\n}\r\n\r\nlet useLayoutEffectOrigin: (effect: React.EffectCallback, deps?: React.DependencyList) => void;\r\nexport function useHookstateLayoutEffect(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps)\r\n    return useLayoutEffectOrigin(effect, deps)\r\n}\r\nfunction useLayoutEffectIntercept(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps, true)\r\n    return useLayoutEffectOrigin(effect, deps)\r\n}\r\n\r\nlet useInsertionEffectOrigin: (effect: React.EffectCallback, deps?: React.DependencyList) => void;\r\nexport function useHookstateInsertionEffect(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps)\r\n    return useInsertionEffectOrigin(effect, deps)\r\n}\r\nfunction useInsertionEffectIntercept(effect: React.EffectCallback, deps?: React.DependencyList) {\r\n    reconnectDependencies(deps, true)\r\n    return useInsertionEffectOrigin(effect, deps)\r\n}\r\n\r\nlet useImperativeHandleOrigin: <T, R extends T>(ref: React.Ref<T> | undefined, init: () => R, deps?: React.DependencyList) => void;\r\nexport function useHookstateImperativeHandle<T, R extends T>(ref: React.Ref<T> | undefined, init: () => R, deps?: React.DependencyList): void {\r\n    reconnectDependencies(deps)\r\n    return useImperativeHandleOrigin(ref, init, deps)\r\n}\r\nfunction useImperativeHandleIntercept<T, R extends T>(ref: React.Ref<T> | undefined, init: () => R, deps?: React.DependencyList): void {\r\n    reconnectDependencies(deps, true)\r\n    return useImperativeHandleOrigin(ref, init, deps)\r\n}\r\n\r\nlet useMemoOrigin: <T>(factory: () => T, deps: React.DependencyList | undefined) => T;\r\nexport function useHookstateMemo<T>(factory: () => T, deps: React.DependencyList | undefined): T {\r\n    reconnectDependencies(deps)\r\n    return useMemoOrigin(factory, deps)\r\n}\r\nexport function useMemoIntercept<T>(factory: () => T, deps: React.DependencyList | undefined): T {\r\n    reconnectDependencies(deps, true)\r\n    return useMemoOrigin(factory, deps)\r\n}\r\n\r\nlet useCallbackOrigin: <T extends Function>(callback: T, deps: React.DependencyList) => T;\r\nexport function useHookstateCallback<T extends Function>(callback: T, deps: React.DependencyList): T {\r\n    reconnectDependencies(deps)\r\n    return useCallbackOrigin(callback, deps)\r\n}\r\nfunction useCallbackIntercept<T extends Function>(callback: T, deps: React.DependencyList): T {\r\n    reconnectDependencies(deps, true)\r\n    return useCallbackOrigin(callback, deps)\r\n}\r\n\r\nlet memoOrigin: <P extends object>(\r\n    Component: React.FunctionComponent<P>,\r\n    propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean\r\n) => React.NamedExoticComponent<P>;\r\nexport function hookstateMemo<T extends React.ComponentType<any>>(\r\n    Component: T,\r\n    propsAreEqual?: (prevProps: Readonly<React.ComponentProps<T>>, nextProps: Readonly<React.ComponentProps<T>>) => boolean\r\n): React.MemoExoticComponent<T>;\r\nexport function hookstateMemo<P extends object>(\r\n    Component: React.FunctionComponent<P>,\r\n    propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean\r\n): React.NamedExoticComponent<P> {\r\n    return memoOrigin(Component, (prevProps, nextProps) => {\r\n        reconnectDependencies(Object.keys(nextProps).map(i => nextProps[i]))\r\n        return (propsAreEqual || shallowEqual)(prevProps, nextProps)\r\n    })\r\n}\r\nfunction memoIntercept<T extends React.ComponentType<any>>(\r\n    Component: T,\r\n    propsAreEqual?: (prevProps: Readonly<React.ComponentProps<T>>, nextProps: Readonly<React.ComponentProps<T>>) => boolean\r\n): React.MemoExoticComponent<T>;\r\nfunction memoIntercept<P extends object>(\r\n    Component: React.FunctionComponent<P>,\r\n    propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean\r\n): React.NamedExoticComponent<P> {\r\n    return memoOrigin(Component, (prevProps, nextProps) => {\r\n        reconnectDependencies(Object.keys(nextProps).map(i => nextProps[i]), true)\r\n        return (propsAreEqual || shallowEqual)(prevProps, nextProps)\r\n    })\r\n}\r\n\r\nfunction interceptReactHooks() {\r\n    if (!useEffectOrigin && React['useEffect']) {\r\n        useEffectOrigin = React['useEffect'];\r\n        React['useEffect'] = useEffectIntercept;\r\n    }\r\n    if (!useLayoutEffectOrigin && React['useLayoutEffect']) {\r\n        useLayoutEffectOrigin = React['useLayoutEffect'];\r\n        React['useLayoutEffect'] = useLayoutEffectIntercept;\r\n    }\r\n    if (!useInsertionEffectOrigin && React['useInsertionEffect']) {\r\n        useInsertionEffectOrigin = React['useInsertionEffect'];\r\n        React['useInsertionEffect'] = useInsertionEffectIntercept;\r\n    }\r\n    if (!useImperativeHandleOrigin && React['useImperativeHandle']) {\r\n        useImperativeHandleOrigin = React['useImperativeHandle'];\r\n        React['useImperativeHandle'] = useImperativeHandleIntercept;\r\n    }\r\n    if (!useMemoOrigin && React['useMemo']) {\r\n        useMemoOrigin = React['useMemo'];\r\n        React['useMemo'] = useMemoIntercept;\r\n    }\r\n    if (!useCallbackOrigin && React['useCallback']) {\r\n        useCallbackOrigin = React['useCallback'];\r\n        React['useCallback'] = useCallbackIntercept;\r\n    }\r\n    if (!memoOrigin && React['memo']) {\r\n        memoOrigin = React['memo'];\r\n        React['memo'] = memoIntercept;\r\n    }\r\n}\r\ninterceptReactHooks() // TODO defer invoking it until state is created, so the configure had a chance to set it up first\r\n\r\n// Do not try to use useLayoutEffect if DOM not available (SSR)\r\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffectOrigin! : useEffectOrigin!;\r\n"],
  "mappings": "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",
  "names": ["d", "b", "__assign", "state", "React", "ErrorId", "StateInvalidUsageError", "Store", "StateMethodsImpl", "_a"]
}
