diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Assert.d.ts b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.d.ts
new file mode 100644
index 0000000..7f826f8
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.d.ts
@@ -0,0 +1,5 @@
+export declare class Assert {
+    static mustEqual(value: number, mustEqualThisValue: number, msg?: string): void;
+    static mustBeTrue(condition: boolean, msg?: string): void;
+    static mustBeDefined(variable: any, msg?: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js
new file mode 100644
index 0000000..121858f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js
@@ -0,0 +1,18 @@
+export class Assert {
+    static mustEqual(value, mustEqualThisValue, msg = '') {
+        if (value !== mustEqualThisValue) {
+            throw new Error(`failed assertion: ${value} must equal ${mustEqualThisValue}.  ${msg}`);
+        }
+    }
+    static mustBeTrue(condition, msg = '') {
+        if (!condition) {
+            throw new Error(`failed assertion: ${msg}`);
+        }
+    }
+    static mustBeDefined(variable, msg = '') {
+        if (variable === undefined) {
+            throw new Error(`failed assertion: variable must be defined ${msg}`);
+        }
+    }
+}
+//# sourceMappingURL=Assert.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js.map b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js.map
new file mode 100644
index 0000000..42b5376
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Assert.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Assert.js","sourceRoot":"","sources":["../../src/Diagnostics/Assert.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,MAAM;IACjB,MAAM,CAAC,SAAS,CAAC,KAAa,EAAE,kBAA0B,EAAE,GAAG,GAAG,EAAE;QAClE,IAAI,KAAK,KAAK,kBAAkB,EAAE;YAChC,MAAM,IAAI,KAAK,CACb,qBAAqB,KAAK,eAAe,kBAAkB,MAAM,GAAG,EAAE,CACvE,CAAC;SACH;IACH,CAAC;IACD,MAAM,CAAC,UAAU,CAAC,SAAkB,EAAE,GAAG,GAAG,EAAE;QAC5C,IAAI,CAAC,SAAS,EAAE;YACd,MAAM,IAAI,KAAK,CAAC,qBAAqB,GAAG,EAAE,CAAC,CAAC;SAC7C;IACH,CAAC;IACD,MAAM,CAAC,aAAa,CAAC,QAAa,EAAE,GAAG,GAAG,EAAE;QAC1C,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,8CAA8C,GAAG,EAAE,CAAC,CAAC;SACtE;IACH,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Logger.d.ts b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.d.ts
new file mode 100644
index 0000000..9ca4c43
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.d.ts
@@ -0,0 +1,27 @@
+import { EventEmitter } from '../Events/EventEmitter.js';
+import { LogSeverity } from '../index.js';
+export declare enum LogLevel {
+    Verbose = 0,
+    Info = 1,
+    Warning = 2,
+    Error = 3
+}
+export declare function logSeverityToLevel(severity: LogSeverity): LogLevel;
+export declare enum PrefixStyle {
+    None = 0,
+    Time = 1
+}
+export type LogMessage = {
+    severity: LogSeverity;
+    text: string;
+};
+export declare class Logger {
+    static logLevel: LogLevel;
+    static prefixStyle: PrefixStyle;
+    static readonly onLog: EventEmitter<LogMessage>;
+    static log(severity: LogSeverity, text: string): void;
+    static verbose(text: string): void;
+    static info(text: string): void;
+    static warning(text: string): void;
+    static error(text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js
new file mode 100644
index 0000000..6a8ab96
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js
@@ -0,0 +1,67 @@
+/* eslint-disable no-console */
+import { EventEmitter } from '../Events/EventEmitter.js';
+export var LogLevel;
+(function (LogLevel) {
+    LogLevel[LogLevel["Verbose"] = 0] = "Verbose";
+    LogLevel[LogLevel["Info"] = 1] = "Info";
+    LogLevel[LogLevel["Warning"] = 2] = "Warning";
+    LogLevel[LogLevel["Error"] = 3] = "Error";
+})(LogLevel || (LogLevel = {}));
+export function logSeverityToLevel(severity) {
+    switch (severity) {
+        case 'verbose':
+            return LogLevel.Verbose;
+        case 'info':
+            return LogLevel.Info;
+        case 'warning':
+            return LogLevel.Warning;
+        case 'error':
+            return LogLevel.Error;
+    }
+}
+export var PrefixStyle;
+(function (PrefixStyle) {
+    PrefixStyle[PrefixStyle["None"] = 0] = "None";
+    PrefixStyle[PrefixStyle["Time"] = 1] = "Time";
+})(PrefixStyle || (PrefixStyle = {}));
+const Reset = '\x1b[0m';
+const FgRed = '\x1b[31m';
+const BgYellow = '\x1b[43m';
+const Dim = '\x1b[2m';
+class Logger {
+    static log(severity, text) {
+        this.onLog.emit({ severity, text });
+    }
+    static verbose(text) {
+        this.onLog.emit({ severity: 'verbose', text });
+    }
+    static info(text) {
+        this.onLog.emit({ severity: 'info', text });
+    }
+    static warning(text) {
+        this.onLog.emit({ severity: 'warning', text });
+    }
+    static error(text) {
+        this.onLog.emit({ severity: 'error', text });
+    }
+}
+Logger.logLevel = LogLevel.Info;
+Logger.prefixStyle = PrefixStyle.None;
+Logger.onLog = new EventEmitter();
+(() => {
+    const prefix = () => {
+        switch (Logger.prefixStyle) {
+            case PrefixStyle.None:
+                return '';
+            case PrefixStyle.Time:
+                return new Date().toLocaleTimeString().padStart(11, '0') + ' ';
+        }
+    };
+    Logger.onLog.addListener((logMessage) => {
+        if (Logger.logLevel > logSeverityToLevel(logMessage.severity))
+            return;
+        console.log(prefix() + logMessage.text);
+    });
+})();
+export { Logger };
+//# sourceMappingURL=Logger.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js.map b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js.map
new file mode 100644
index 0000000..39c33c2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Diagnostics/Logger.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Logger.js","sourceRoot":"","sources":["../../src/Diagnostics/Logger.ts"],"names":[],"mappings":"AAAA,+BAA+B;AAE/B,OAAO,EAAE,YAAY,EAAE,MAAM,2BAA2B,CAAC;AAGzD,MAAM,CAAN,IAAY,QAKX;AALD,WAAY,QAAQ;IAClB,6CAAW,CAAA;IACX,uCAAQ,CAAA;IACR,6CAAW,CAAA;IACX,yCAAS,CAAA;AACX,CAAC,EALW,QAAQ,KAAR,QAAQ,QAKnB;AAED,MAAM,UAAU,kBAAkB,CAAC,QAAqB;IACtD,QAAQ,QAAQ,EAAE;QAChB,KAAK,SAAS;YACZ,OAAO,QAAQ,CAAC,OAAO,CAAC;QAC1B,KAAK,MAAM;YACT,OAAO,QAAQ,CAAC,IAAI,CAAC;QACvB,KAAK,SAAS;YACZ,OAAO,QAAQ,CAAC,OAAO,CAAC;QAC1B,KAAK,OAAO;YACV,OAAO,QAAQ,CAAC,KAAK,CAAC;KACzB;AACH,CAAC;AACD,MAAM,CAAN,IAAY,WAGX;AAHD,WAAY,WAAW;IACrB,6CAAQ,CAAA;IACR,6CAAQ,CAAA;AACV,CAAC,EAHW,WAAW,KAAX,WAAW,QAGtB;AAED,MAAM,KAAK,GAAG,SAAS,CAAC;AACxB,MAAM,KAAK,GAAG,UAAU,CAAC;AACzB,MAAM,QAAQ,GAAG,UAAU,CAAC;AAC5B,MAAM,GAAG,GAAG,SAAS,CAAC;AAItB,MAAa,MAAM;IAsBjB,MAAM,CAAC,GAAG,CAAC,QAAqB,EAAE,IAAY;QAC5C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;IACtC,CAAC;IAED,MAAM,CAAC,OAAO,CAAC,IAAY;QACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACjD,CAAC;IAED,MAAM,CAAC,IAAI,CAAC,IAAY;QACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9C,CAAC;IAED,MAAM,CAAC,OAAO,CAAC,IAAY;QACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;IACjD,CAAC;IAED,MAAM,CAAC,KAAK,CAAC,IAAY;QACvB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;IAC/C,CAAC;;AAvCM,eAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC;AACzB,kBAAW,GAAG,WAAW,CAAC,IAAI,CAAC;AAEf,YAAK,GAAG,IAAI,YAAY,EAAc,CAAC;AAE9D;IACE,MAAM,MAAM,GAAG,GAAW,EAAE;QAC1B,QAAQ,MAAM,CAAC,WAAW,EAAE;YAC1B,KAAK,WAAW,CAAC,IAAI;gBACnB,OAAO,EAAE,CAAC;YACZ,KAAK,WAAW,CAAC,IAAI;gBACnB,OAAO,IAAI,IAAI,EAAE,CAAC,kBAAkB,EAAE,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;SAClE;IACH,CAAC,CAAC;IAEF,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,UAAsB,EAAE,EAAE;QAClD,IAAI,MAAM,CAAC,QAAQ,GAAG,kBAAkB,CAAC,UAAU,CAAC,QAAQ,CAAC;YAAE,OAAO;QACtE,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC;IAC1C,CAAC,CAAC,CAAC;AACL,CAAC,GAAA,CAAA;SApBU,MAAM"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Easing.d.ts b/node_modules/@behave-graph/core/dist/Easing.d.ts
new file mode 100644
index 0000000..826e88a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Easing.d.ts
@@ -0,0 +1,7 @@
+export type Easing = (t: number) => number;
+export declare const EasingFunctions: {
+    [name: string]: Easing;
+};
+export declare const EasingModes: {
+    [name: string]: (easing: Easing) => Easing;
+};
diff --git a/node_modules/@behave-graph/core/dist/Easing.js b/node_modules/@behave-graph/core/dist/Easing.js
new file mode 100644
index 0000000..5708efa
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Easing.js
@@ -0,0 +1,47 @@
+export const EasingFunctions = {
+    linear: (t) => t,
+    quadratic: (t) => t * t,
+    cubic: (t) => t * t * t,
+    quartric: (t) => t * t * t * t,
+    quintic: (t) => t * t * t * t * t,
+    sine: (t) => 1 - Math.cos((t * Math.PI) / 2),
+    exponential: (t) => Math.pow(2, 10 * (t - 1)),
+    circle: (t) => 1 - Math.sqrt(1 - t * t),
+    back: (t) => {
+        const s = 1.70158;
+        return t * t * ((s + 1) * t - s);
+    },
+    elastic: (t) => 1 - Math.pow(Math.cos((t * Math.PI) / 2), 3) * Math.cos(t * Math.PI),
+    bounce: (t) => {
+        if (t < 1 / 2.75) {
+            return 7.5625 * t * t;
+        }
+        if (t < 2 / 2.75) {
+            const t2 = t - 1.5 / 2.75;
+            return 7.5625 * t2 * t2 + 0.75;
+        }
+        if (t < 2.5 / 2.75) {
+            const t2 = t - 2.25 / 2.75;
+            return 7.5625 * t2 * t2 + 0.9375;
+        }
+        const t2 = t - 2.625 / 2.75;
+        return 7.5625 * t2 * t2 + 0.984375;
+    }
+};
+export const EasingModes = {
+    in: (easing) => {
+        return easing;
+    },
+    out: (easing) => {
+        return (t) => 1 - easing(1 - t);
+    },
+    inOut: (easing) => {
+        return (t) => {
+            if (t < 0.5) {
+                return easing(t * 2) / 2;
+            }
+            return 1 - easing((1 - t) * 2) / 2;
+        };
+    }
+};
+//# sourceMappingURL=Easing.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Easing.js.map b/node_modules/@behave-graph/core/dist/Easing.js.map
new file mode 100644
index 0000000..04d4c45
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Easing.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Easing.js","sourceRoot":"","sources":["../src/Easing.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Events/CustomEvent.d.ts b/node_modules/@behave-graph/core/dist/Events/CustomEvent.d.ts
new file mode 100644
index 0000000..cf1d7e7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/CustomEvent.d.ts
@@ -0,0 +1,14 @@
+import { Metadata } from '../Metadata.js';
+import { Socket } from '../Sockets/Socket.js';
+import { EventEmitter } from './EventEmitter.js';
+export declare class CustomEvent {
+    readonly id: string;
+    readonly name: string;
+    readonly parameters: Socket[];
+    label: string;
+    metadata: Metadata;
+    readonly eventEmitter: EventEmitter<{
+        [parameterName: string]: any;
+    }>;
+    constructor(id: string, name: string, parameters?: Socket[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/Events/CustomEvent.js b/node_modules/@behave-graph/core/dist/Events/CustomEvent.js
new file mode 100644
index 0000000..2e52088
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/CustomEvent.js
@@ -0,0 +1,12 @@
+import { EventEmitter } from './EventEmitter.js';
+export class CustomEvent {
+    constructor(id, name, parameters = []) {
+        this.id = id;
+        this.name = name;
+        this.parameters = parameters;
+        this.label = '';
+        this.metadata = {};
+        this.eventEmitter = new EventEmitter();
+    }
+}
+//# sourceMappingURL=CustomEvent.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Events/CustomEvent.js.map b/node_modules/@behave-graph/core/dist/Events/CustomEvent.js.map
new file mode 100644
index 0000000..22da331
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/CustomEvent.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"CustomEvent.js","sourceRoot":"","sources":["../../src/Events/CustomEvent.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AAEjD,MAAM,OAAO,WAAW;IAOtB,YACkB,EAAU,EACV,IAAY,EACZ,aAAuB,EAAE;QAFzB,OAAE,GAAF,EAAE,CAAQ;QACV,SAAI,GAAJ,IAAI,CAAQ;QACZ,eAAU,GAAV,UAAU,CAAe;QATpC,UAAK,GAAG,EAAE,CAAC;QACX,aAAQ,GAAa,EAAE,CAAC;QACf,iBAAY,GAAG,IAAI,YAAY,EAE3C,CAAC;IAMF,CAAC;CACL"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Events/EventEmitter.d.ts b/node_modules/@behave-graph/core/dist/Events/EventEmitter.d.ts
new file mode 100644
index 0000000..d1fdbfc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/EventEmitter.d.ts
@@ -0,0 +1,8 @@
+export declare class EventEmitter<T> {
+    private readonly listeners;
+    addListener(listener: (t: T) => void): void;
+    removeListener(listener: (t: T) => void): void;
+    clear(): void;
+    emit(event: T): void;
+    get listenerCount(): number;
+}
diff --git a/node_modules/@behave-graph/core/dist/Events/EventEmitter.js b/node_modules/@behave-graph/core/dist/Events/EventEmitter.js
new file mode 100644
index 0000000..5e96ab0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/EventEmitter.js
@@ -0,0 +1,27 @@
+export class EventEmitter {
+    constructor() {
+        this.listeners = [];
+    }
+    addListener(listener) {
+        this.listeners.push(listener);
+    }
+    removeListener(listener) {
+        this.listeners.splice(this.listeners.indexOf(listener), 1);
+    }
+    clear() {
+        this.listeners.splice(0, this.listeners.length);
+    }
+    emit(event) {
+        if (this.listeners.length === 0)
+            return;
+        // copy array before emitting event to ensure even if listener array is modified, everyone listening initially gets the event.
+        // inspired by mrdoob's EventDispatcher
+        this.listeners.slice(0).forEach((listener) => {
+            listener(event);
+        });
+    }
+    get listenerCount() {
+        return this.listeners.length;
+    }
+}
+//# sourceMappingURL=EventEmitter.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Events/EventEmitter.js.map b/node_modules/@behave-graph/core/dist/Events/EventEmitter.js.map
new file mode 100644
index 0000000..9147749
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Events/EventEmitter.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EventEmitter.js","sourceRoot":"","sources":["../../src/Events/EventEmitter.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,YAAY;IAAzB;QACmB,cAAS,GAAuB,EAAE,CAAC;IA0BtD,CAAC;IAxBC,WAAW,CAAC,QAAwB;QAClC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAED,cAAc,CAAC,QAAwB;QACrC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7D,CAAC;IAED,KAAK;QACH,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAClD,CAAC;IAED,IAAI,CAAC,KAAQ;QACX,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO;QACxC,8HAA8H;QAC9H,uCAAuC;QACvC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;YAC3C,QAAQ,CAAC,KAAK,CAAC,CAAC;QAClB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/Engine.d.ts b/node_modules/@behave-graph/core/dist/Execution/Engine.d.ts
new file mode 100644
index 0000000..62e6b03
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Engine.d.ts
@@ -0,0 +1,17 @@
+import { EventEmitter } from '../Events/EventEmitter.js';
+import { GraphNodes } from '../Graphs/Graph.js';
+import { IAsyncNode, IEventNode, INode } from '../Nodes/NodeInstance.js';
+export declare class Engine {
+    readonly nodes: GraphNodes;
+    private readonly fiberQueue;
+    readonly asyncNodes: IAsyncNode[];
+    readonly eventNodes: IEventNode[];
+    readonly onNodeExecutionStart: EventEmitter<INode>;
+    readonly onNodeExecutionEnd: EventEmitter<INode>;
+    executionSteps: number;
+    constructor(nodes: GraphNodes);
+    dispose(): void;
+    commitToNewFiber(node: INode, outputFlowSocketName: string, fiberCompletedListener?: (() => void) | undefined): void;
+    executeAllSync(limitInSeconds?: number, limitInSteps?: number): number;
+    executeAllAsync(limitInSeconds?: number, limitInSteps?: number): Promise<number>;
+}
diff --git a/node_modules/@behave-graph/core/dist/Execution/Engine.js b/node_modules/@behave-graph/core/dist/Execution/Engine.js
new file mode 100644
index 0000000..8f05aaa
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Engine.js
@@ -0,0 +1,100 @@
+/* eslint-disable space-in-parens */
+// fdfdfd
+import { Assert } from '../Diagnostics/Assert.js';
+import { EventEmitter } from '../Events/EventEmitter.js';
+import { isAsyncNode, isEventNode } from '../Nodes/NodeInstance.js';
+import { sleep } from '../sleep.js';
+import { Fiber } from './Fiber.js';
+import { resolveSocketValue } from './resolveSocketValue.js';
+export class Engine {
+    constructor(nodes) {
+        this.nodes = nodes;
+        // tracking the next node+input socket to execute.
+        this.fiberQueue = [];
+        this.asyncNodes = [];
+        this.eventNodes = [];
+        this.onNodeExecutionStart = new EventEmitter();
+        this.onNodeExecutionEnd = new EventEmitter();
+        this.executionSteps = 0;
+        // collect all event nodes
+        Object.values(nodes).forEach((node) => {
+            if (isEventNode(node)) {
+                this.eventNodes.push(node);
+            }
+        });
+        // init all event nodes at startup
+        this.eventNodes.forEach((eventNode) => {
+            // evaluate input parameters
+            eventNode.inputs.forEach((inputSocket) => {
+                Assert.mustBeTrue(inputSocket.valueTypeName !== 'flow');
+                this.executionSteps += resolveSocketValue(this, inputSocket);
+            });
+            this.onNodeExecutionStart.emit(eventNode);
+            eventNode.init(this);
+            this.executionSteps++;
+            this.onNodeExecutionEnd.emit(eventNode);
+        });
+    }
+    dispose() {
+        // dispose all, possibly in-progress, async nodes
+        this.asyncNodes.forEach((asyncNode) => asyncNode.dispose());
+        // dispose all event nodes
+        this.eventNodes.forEach((eventNode) => eventNode.dispose(this));
+    }
+    // asyncCommit
+    commitToNewFiber(node, outputFlowSocketName, fiberCompletedListener = undefined) {
+        Assert.mustBeTrue(isEventNode(node) || isAsyncNode(node));
+        const outputSocket = node.outputs.find((socket) => socket.name === outputFlowSocketName);
+        if (outputSocket === undefined) {
+            throw new Error(`no socket with the name ${outputFlowSocketName}`);
+        }
+        if (outputSocket.links.length > 1) {
+            throw new Error('invalid for an output flow socket to have multiple downstream links:' +
+                `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+        }
+        if (outputSocket.links.length === 1) {
+            const fiber = new Fiber(this, outputSocket.links[0], fiberCompletedListener);
+            this.fiberQueue.push(fiber);
+        }
+    }
+    // NOTE: This does not execute all if there are promises.
+    executeAllSync(limitInSeconds = 100, limitInSteps = 100000000) {
+        const startDateTime = Date.now();
+        let elapsedSeconds = 0;
+        let elapsedSteps = 0;
+        while (elapsedSteps < limitInSteps &&
+            elapsedSeconds < limitInSeconds &&
+            this.fiberQueue.length > 0) {
+            const currentFiber = this.fiberQueue[0];
+            const startingFiberExecutionSteps = currentFiber.executionSteps;
+            currentFiber.executeStep();
+            elapsedSteps += currentFiber.executionSteps - startingFiberExecutionSteps;
+            if (currentFiber.isCompleted()) {
+                // remove first element
+                this.fiberQueue.shift();
+            }
+            elapsedSeconds = (Date.now() - startDateTime) * 0.001;
+        }
+        this.executionSteps += elapsedSteps;
+        return elapsedSteps;
+    }
+    async executeAllAsync(limitInSeconds = 100, limitInSteps = 100000000) {
+        const startDateTime = Date.now();
+        let elapsedSteps = 0;
+        let elapsedTime = 0;
+        let iterations = 0;
+        do {
+            if (iterations > 0) {
+                // eslint-disable-next-line no-await-in-loop
+                await sleep(0);
+            }
+            elapsedSteps += this.executeAllSync(limitInSeconds - elapsedTime, limitInSteps - elapsedSteps);
+            elapsedTime = (Date.now() - startDateTime) * 0.001;
+            iterations += 1;
+        } while ((this.asyncNodes.length > 0 || this.fiberQueue.length > 0) &&
+            elapsedTime < limitInSeconds &&
+            elapsedSteps < limitInSteps);
+        return elapsedSteps;
+    }
+}
+//# sourceMappingURL=Engine.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/Engine.js.map b/node_modules/@behave-graph/core/dist/Execution/Engine.js.map
new file mode 100644
index 0000000..cdab668
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Engine.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Engine.js","sourceRoot":"","sources":["../../src/Execution/Engine.ts"],"names":[],"mappings":"AAAA,oCAAoC;AACpC,SAAS;AACT,OAAO,EAAE,MAAM,EAAE,MAAM,0BAA0B,CAAC;AAClD,OAAO,EAAE,YAAY,EAAE,MAAM,2BAA2B,CAAC;AAEzD,OAAO,EAIL,WAAW,EACX,WAAW,EACZ,MAAM,0BAA0B,CAAC;AAClC,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AACpC,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AACnC,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAE7D,MAAM,OAAO,MAAM;IASjB,YAA4B,KAAiB;QAAjB,UAAK,GAAL,KAAK,CAAY;QAR7C,kDAAkD;QACjC,eAAU,GAAY,EAAE,CAAC;QAC1B,eAAU,GAAiB,EAAE,CAAC;QAC9B,eAAU,GAAiB,EAAE,CAAC;QAC9B,yBAAoB,GAAG,IAAI,YAAY,EAAS,CAAC;QACjD,uBAAkB,GAAG,IAAI,YAAY,EAAS,CAAC;QACxD,mBAAc,GAAG,CAAC,CAAC;QAGxB,0BAA0B;QAC1B,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACpC,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;gBACrB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aAC5B;QACH,CAAC,CAAC,CAAC;QACH,kCAAkC;QAClC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;YACpC,4BAA4B;YAC5B,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;gBACvC,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,aAAa,KAAK,MAAM,CAAC,CAAC;gBACxD,IAAI,CAAC,cAAc,IAAI,kBAAkB,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;YAC/D,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC1C,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACrB,IAAI,CAAC,cAAc,EAAE,CAAC;YACtB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC1C,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,iDAAiD;QACjD,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;QAE5D,0BAA0B;QAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAClE,CAAC;IAED,cAAc;IACd,gBAAgB,CACd,IAAW,EACX,oBAA4B,EAC5B,yBAAmD,SAAS;QAE5D,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1D,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CACpC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAoB,CACjD,CAAC;QACF,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,2BAA2B,oBAAoB,EAAE,CAAC,CAAC;SACpE;QACD,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACjC,MAAM,IAAI,KAAK,CACb,sEAAsE;gBACpE,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,KAAK,CAAC,MAAM,YAAY,CACjG,CAAC;SACH;QACD,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACnC,MAAM,KAAK,GAAG,IAAI,KAAK,CACrB,IAAI,EACJ,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,EACrB,sBAAsB,CACvB,CAAC;YACF,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC7B;IACH,CAAC;IAED,yDAAyD;IACzD,cAAc,CAAC,cAAc,GAAG,GAAG,EAAE,YAAY,GAAG,SAAS;QAC3D,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACjC,IAAI,cAAc,GAAG,CAAC,CAAC;QACvB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,OACE,YAAY,GAAG,YAAY;YAC3B,cAAc,GAAG,cAAc;YAC/B,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAC1B;YACA,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACxC,MAAM,2BAA2B,GAAG,YAAY,CAAC,cAAc,CAAC;YAChE,YAAY,CAAC,WAAW,EAAE,CAAC;YAC3B,YAAY,IAAI,YAAY,CAAC,cAAc,GAAG,2BAA2B,CAAC;YAC1E,IAAI,YAAY,CAAC,WAAW,EAAE,EAAE;gBAC9B,uBAAuB;gBACvB,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;aACzB;YACD,cAAc,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,CAAC,GAAG,KAAK,CAAC;SACvD;QACD,IAAI,CAAC,cAAc,IAAI,YAAY,CAAC;QAEpC,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,eAAe,CACnB,cAAc,GAAG,GAAG,EACpB,YAAY,GAAG,SAAS;QAExB,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACjC,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,WAAW,GAAG,CAAC,CAAC;QACpB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,GAAG;YACD,IAAI,UAAU,GAAG,CAAC,EAAE;gBAClB,4CAA4C;gBAC5C,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;aAChB;YACD,YAAY,IAAI,IAAI,CAAC,cAAc,CACjC,cAAc,GAAG,WAAW,EAC5B,YAAY,GAAG,YAAY,CAC5B,CAAC;YACF,WAAW,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,aAAa,CAAC,GAAG,KAAK,CAAC;YACnD,UAAU,IAAI,CAAC,CAAC;SACjB,QACC,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;YAC1D,WAAW,GAAG,cAAc;YAC5B,YAAY,GAAG,YAAY,EAC3B;QAEF,OAAO,YAAY,CAAC;IACtB,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/Fiber.d.ts b/node_modules/@behave-graph/core/dist/Execution/Fiber.d.ts
new file mode 100644
index 0000000..43a6781
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Fiber.d.ts
@@ -0,0 +1,14 @@
+import { Link } from '../Nodes/Link.js';
+import { INode } from '../Nodes/NodeInstance.js';
+import { Engine } from './Engine.js';
+export declare class Fiber {
+    engine: Engine;
+    nextEval: Link | null;
+    private readonly fiberCompletedListenerStack;
+    private readonly nodes;
+    executionSteps: number;
+    constructor(engine: Engine, nextEval: Link | null, fiberCompletedListener?: (() => void) | undefined);
+    commit(node: INode, outputSocketName: string, fiberCompletedListener?: (() => void) | undefined): void;
+    executeStep(): void;
+    isCompleted(): boolean;
+}
diff --git a/node_modules/@behave-graph/core/dist/Execution/Fiber.js b/node_modules/@behave-graph/core/dist/Execution/Fiber.js
new file mode 100644
index 0000000..cd4cf36
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Fiber.js
@@ -0,0 +1,88 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { isAsyncNode, isFlowNode } from '../Nodes/NodeInstance.js';
+import { resolveSocketValue } from './resolveSocketValue.js';
+export class Fiber {
+    constructor(engine, nextEval, fiberCompletedListener = undefined) {
+        this.engine = engine;
+        this.nextEval = nextEval;
+        this.fiberCompletedListenerStack = [];
+        this.executionSteps = 0;
+        this.nodes = engine.nodes;
+        if (fiberCompletedListener !== undefined) {
+            this.fiberCompletedListenerStack.push(fiberCompletedListener);
+        }
+    }
+    // this is syncCommit.
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars
+    commit(node, outputSocketName, fiberCompletedListener = undefined) {
+        Assert.mustBeTrue(isFlowNode(node));
+        Assert.mustBeTrue(this.nextEval === null);
+        const outputSocket = node.outputs.find((socket) => socket.name === outputSocketName);
+        if (outputSocket === undefined) {
+            throw new Error(`can not find socket with the name ${outputSocketName}`);
+        }
+        if (outputSocket.links.length > 1) {
+            throw new Error('invalid for an output flow socket to have multiple downstream links:' +
+                `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+        }
+        if (outputSocket.links.length === 1) {
+            const link = outputSocket.links[0];
+            if (link === undefined) {
+                throw new Error('link must be defined');
+            }
+            this.nextEval = link;
+        }
+        if (fiberCompletedListener !== undefined) {
+            this.fiberCompletedListenerStack.push(fiberCompletedListener);
+        }
+    }
+    // returns the number of new execution steps created as a result of this one step
+    executeStep() {
+        // pop the next node off the queue
+        const link = this.nextEval;
+        this.nextEval = null;
+        // nothing waiting, thus go back and start to evaluate any callbacks, in stack order.
+        if (link === null) {
+            if (this.fiberCompletedListenerStack.length === 0) {
+                return;
+            }
+            const awaitingCallback = this.fiberCompletedListenerStack.pop();
+            if (awaitingCallback === undefined) {
+                throw new Error('awaitingCallback is empty');
+            }
+            awaitingCallback();
+            return;
+        }
+        const node = this.nodes[link.nodeId];
+        node.inputs.forEach((inputSocket) => {
+            if (inputSocket.valueTypeName !== 'flow') {
+                this.executionSteps += resolveSocketValue(this.engine, inputSocket);
+            }
+        });
+        // first resolve all input values
+        // flow socket is set to true for the one flowing in, while all others are set to false.
+        this.engine.onNodeExecutionStart.emit(node);
+        if (isAsyncNode(node)) {
+            this.engine.asyncNodes.push(node);
+            node.triggered(this.engine, link.socketName, () => {
+                // remove from the list of pending async nodes
+                const index = this.engine.asyncNodes.indexOf(node);
+                this.engine.asyncNodes.splice(index, 1);
+                this.engine.onNodeExecutionEnd.emit(node);
+                this.executionSteps++;
+            });
+            return;
+        }
+        if (isFlowNode(node)) {
+            node.triggered(this, link.socketName);
+            this.engine.onNodeExecutionEnd.emit(node);
+            this.executionSteps++;
+            return;
+        }
+        throw new TypeError(`should not get here, unhandled node ${node.description.typeName}`);
+    }
+    isCompleted() {
+        return (this.fiberCompletedListenerStack.length === 0 && this.nextEval === null);
+    }
+}
+//# sourceMappingURL=Fiber.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/Fiber.js.map b/node_modules/@behave-graph/core/dist/Execution/Fiber.js.map
new file mode 100644
index 0000000..281bde4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/Fiber.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Fiber.js","sourceRoot":"","sources":["../../src/Execution/Fiber.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,0BAA0B,CAAC;AAGlD,OAAO,EAAS,WAAW,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AAE1E,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAE7D,MAAM,OAAO,KAAK;IAKhB,YACS,MAAc,EACd,QAAqB,EAC5B,yBAAmD,SAAS;QAFrD,WAAM,GAAN,MAAM,CAAQ;QACd,aAAQ,GAAR,QAAQ,CAAa;QANb,gCAA2B,GAAmB,EAAE,CAAC;QAE3D,mBAAc,GAAG,CAAC,CAAC;QAOxB,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QAC1B,IAAI,sBAAsB,KAAK,SAAS,EAAE;YACxC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;SAC/D;IACH,CAAC;IAED,sBAAsB;IACtB,6EAA6E;IAC7E,MAAM,CACJ,IAAW,EACX,gBAAwB,EACxB,yBAAmD,SAAS;QAE5D,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,CAAC;QAE1C,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CACpC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,gBAAgB,CAC7C,CAAC;QACF,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,qCAAqC,gBAAgB,EAAE,CAAC,CAAC;SAC1E;QAED,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACjC,MAAM,IAAI,KAAK,CACb,sEAAsE;gBACpE,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,YAAY,CAAC,IAAI,QAAQ,YAAY,CAAC,KAAK,CAAC,MAAM,YAAY,CACjG,CAAC;SACH;QACD,IAAI,YAAY,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACnC,MAAM,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;aACzC;YACD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;SACtB;QAED,IAAI,sBAAsB,KAAK,SAAS,EAAE;YACxC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;SAC/D;IACH,CAAC;IAED,iFAAiF;IACjF,WAAW;QACT,kCAAkC;QAClC,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QAErB,qFAAqF;QACrF,IAAI,IAAI,KAAK,IAAI,EAAE;YACjB,IAAI,IAAI,CAAC,2BAA2B,CAAC,MAAM,KAAK,CAAC,EAAE;gBACjD,OAAO;aACR;YACD,MAAM,gBAAgB,GAAG,IAAI,CAAC,2BAA2B,CAAC,GAAG,EAAE,CAAC;YAChE,IAAI,gBAAgB,KAAK,SAAS,EAAE;gBAClC,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;aAC9C;YACD,gBAAgB,EAAE,CAAC;YACnB,OAAO;SACR;QAED,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAErC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;YAClC,IAAI,WAAW,CAAC,aAAa,KAAK,MAAM,EAAE;gBACxC,IAAI,CAAC,cAAc,IAAI,kBAAkB,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;aACrE;QACH,CAAC,CAAC,CAAC;QAEH,iCAAiC;QACjC,wFAAwF;QACxF,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5C,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;YACrB,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE;gBAChD,8CAA8C;gBAC9C,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;gBACnD,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBACxC,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAC1C,IAAI,CAAC,cAAc,EAAE,CAAC;YACxB,CAAC,CAAC,CAAC;YACH,OAAO;SACR;QACD,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACpB,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YACtC,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1C,IAAI,CAAC,cAAc,EAAE,CAAC;YACtB,OAAO;SACR;QAED,MAAM,IAAI,SAAS,CACjB,uCAAuC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CACnE,CAAC;IACJ,CAAC;IAED,WAAW;QACT,OAAO,CACL,IAAI,CAAC,2BAA2B,CAAC,MAAM,KAAK,CAAC,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CACxE,CAAC;IACJ,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.d.ts b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.d.ts
new file mode 100644
index 0000000..efc72eb
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.d.ts
@@ -0,0 +1,3 @@
+import { Socket } from '../Sockets/Socket.js';
+import { Engine } from './Engine.js';
+export declare function resolveSocketValue(engine: Engine, inputSocket: Socket): number;
diff --git a/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js
new file mode 100644
index 0000000..3def636
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js
@@ -0,0 +1,46 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { isFunctionNode } from '../Nodes/NodeInstance.js';
+export function resolveSocketValue(engine, inputSocket) {
+    // if it has no links, leave value on input socket alone.
+    if (inputSocket.links.length === 0) {
+        return 0;
+    }
+    const nodes = engine.nodes;
+    const upstreamLink = inputSocket.links[0];
+    // caching the target node + socket here increases engine performance by 8% on average.  This is a hotspot.
+    if (upstreamLink._targetNode === undefined ||
+        upstreamLink._targetSocket === undefined) {
+        Assert.mustBeTrue(inputSocket.links.length === 1);
+        // if upstream node is an eval, we just return its last value.
+        upstreamLink._targetNode = nodes[upstreamLink.nodeId];
+        // what is inputSocket connected to?
+        upstreamLink._targetSocket = upstreamLink._targetNode.outputs.find((socket) => socket.name === upstreamLink.socketName);
+        if (upstreamLink._targetSocket === undefined) {
+            throw new Error(`can not find socket with the name ${upstreamLink.socketName}`);
+        }
+    }
+    const upstreamNode = upstreamLink._targetNode;
+    const upstreamOutputSocket = upstreamLink._targetSocket;
+    // if upstream is a flow/event/async node, do not evaluate it rather just use its existing output socket values
+    if (!isFunctionNode(upstreamNode)) {
+        inputSocket.value = upstreamOutputSocket.value;
+        return 0;
+    }
+    let executionSteps = 0;
+    if (isFunctionNode(upstreamNode)) {
+        // resolve all inputs for the upstream node (this is where the recursion happens)
+        // TODO: This is a bit dangerous as if there are loops in the graph, this will blow up the stack
+        for (const upstreamInputSocket of upstreamNode.inputs) {
+            executionSteps += resolveSocketValue(engine, upstreamInputSocket);
+        }
+        engine.onNodeExecutionStart.emit(upstreamNode);
+        upstreamNode.exec(upstreamNode);
+        executionSteps++;
+        engine.onNodeExecutionEnd.emit(upstreamNode);
+        // get the output value we wanted.
+        inputSocket.value = upstreamOutputSocket.value;
+        return executionSteps;
+    }
+    return 0;
+}
+//# sourceMappingURL=resolveSocketValue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js.map b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js.map
new file mode 100644
index 0000000..e96f3b0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Execution/resolveSocketValue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"resolveSocketValue.js","sourceRoot":"","sources":["../../src/Execution/resolveSocketValue.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,0BAA0B,CAAC;AAClD,OAAO,EAAE,cAAc,EAAE,MAAM,0BAA0B,CAAC;AAI1D,MAAM,UAAU,kBAAkB,CAChC,MAAc,EACd,WAAmB;IAEnB,yDAAyD;IACzD,IAAI,WAAW,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;QAClC,OAAO,CAAC,CAAC;KACV;IAED,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;IAE3B,MAAM,YAAY,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC1C,2GAA2G;IAC3G,IACE,YAAY,CAAC,WAAW,KAAK,SAAS;QACtC,YAAY,CAAC,aAAa,KAAK,SAAS,EACxC;QACA,MAAM,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;QAElD,8DAA8D;QAC9D,YAAY,CAAC,WAAW,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QACtD,oCAAoC;QACpC,YAAY,CAAC,aAAa,GAAG,YAAY,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAChE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,YAAY,CAAC,UAAU,CACpD,CAAC;QACF,IAAI,YAAY,CAAC,aAAa,KAAK,SAAS,EAAE;YAC5C,MAAM,IAAI,KAAK,CACb,qCAAqC,YAAY,CAAC,UAAU,EAAE,CAC/D,CAAC;SACH;KACF;IAED,MAAM,YAAY,GAAG,YAAY,CAAC,WAAW,CAAC;IAC9C,MAAM,oBAAoB,GAAG,YAAY,CAAC,aAAa,CAAC;IAExD,+GAA+G;IAC/G,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;QACjC,WAAW,CAAC,KAAK,GAAG,oBAAoB,CAAC,KAAK,CAAC;QAC/C,OAAO,CAAC,CAAC;KACV;IAED,IAAI,cAAc,GAAG,CAAC,CAAC;IAEvB,IAAI,cAAc,CAAC,YAAY,CAAC,EAAE;QAChC,iFAAiF;QACjF,gGAAgG;QAChG,KAAK,MAAM,mBAAmB,IAAI,YAAY,CAAC,MAAM,EAAE;YACrD,cAAc,IAAI,kBAAkB,CAAC,MAAM,EAAE,mBAAmB,CAAC,CAAC;SACnE;QAED,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC/C,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAChC,cAAc,EAAE,CAAC;QACjB,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAE7C,kCAAkC;QAClC,WAAW,CAAC,KAAK,GAAG,oBAAoB,CAAC,KAAK,CAAC;QAC/C,OAAO,cAAc,CAAC;KACvB;IAED,OAAO,CAAC,CAAC;AACX,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Graph.d.ts b/node_modules/@behave-graph/core/dist/Graphs/Graph.d.ts
new file mode 100644
index 0000000..0a68ce5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Graph.d.ts
@@ -0,0 +1,46 @@
+import { CustomEvent } from '../Events/CustomEvent.js';
+import { Metadata } from '../Metadata.js';
+import { NodeConfiguration } from '../Nodes/Node.js';
+import { Dependencies } from '../Nodes/NodeDefinitions.js';
+import { INode } from '../Nodes/NodeInstance.js';
+import { IRegistry } from '../Registry.js';
+import { ValueTypeMap } from '../Values/ValueTypeMap.js';
+import { Variable } from '../Values/Variables/Variable.js';
+export interface IGraph {
+    readonly variables: {
+        [id: string]: Variable;
+    };
+    readonly customEvents: {
+        [id: string]: CustomEvent;
+    };
+    readonly values: ValueTypeMap;
+    readonly getDependency: <T>(id: string) => T | undefined;
+}
+export type GraphNodes = {
+    [id: string]: INode;
+};
+export type GraphVariables = {
+    [id: string]: Variable;
+};
+export type GraphCustomEvents = {
+    [id: string]: CustomEvent;
+};
+export type GraphInstance = {
+    name: string;
+    metadata: Metadata;
+    nodes: GraphNodes;
+    customEvents: GraphCustomEvents;
+    variables: GraphVariables;
+};
+export declare const createNode: ({ graph, registry, nodeTypeName, nodeConfiguration }: {
+    graph: IGraph;
+    registry: IRegistry;
+    nodeTypeName: string;
+    nodeConfiguration?: NodeConfiguration | undefined;
+}) => INode;
+export declare const makeGraphApi: ({ variables, customEvents, values, dependencies }: {
+    customEvents?: GraphCustomEvents | undefined;
+    variables?: GraphVariables | undefined;
+    values: ValueTypeMap;
+    dependencies: Dependencies;
+}) => IGraph;
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Graph.js b/node_modules/@behave-graph/core/dist/Graphs/Graph.js
new file mode 100644
index 0000000..fd76eff
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Graph.js
@@ -0,0 +1,30 @@
+import { Logger } from '../index.js';
+export const createNode = ({ graph, registry, nodeTypeName, nodeConfiguration = {} }) => {
+    let nodeDefinition = undefined;
+    if (registry.nodes[nodeTypeName]) {
+        nodeDefinition = registry.nodes[nodeTypeName];
+    }
+    if (nodeDefinition === undefined) {
+        Logger.verbose('known nodes: ' + Object.keys(registry.nodes).join(', '));
+        throw new Error(`no registered node descriptions with the typeName ${nodeTypeName}`);
+    }
+    const node = nodeDefinition.nodeFactory(graph, nodeConfiguration);
+    node.inputs.forEach((socket) => {
+        if (socket.valueTypeName !== 'flow' && socket.value === undefined) {
+            socket.value = registry.values[socket.valueTypeName]?.creator();
+        }
+    });
+    return node;
+};
+export const makeGraphApi = ({ variables = {}, customEvents = {}, values, dependencies = {} }) => ({
+    variables,
+    customEvents,
+    values,
+    getDependency: (id) => {
+        const result = dependencies[id];
+        if (!result)
+            console.error(`Dependency not found ${id}.  Did you register it? Existing dependencies: ${Object.keys(dependencies)}`);
+        return result;
+    }
+});
+//# sourceMappingURL=Graph.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Graph.js.map b/node_modules/@behave-graph/core/dist/Graphs/Graph.js.map
new file mode 100644
index 0000000..055dd72
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Graph.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Graph.js","sourceRoot":"","sources":["../../src/Graphs/Graph.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAC;AAgCrC,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,EACzB,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,iBAAiB,GAAG,EAAE,EAMvB,EAAE,EAAE;IACH,IAAI,cAAc,GAAG,SAAS,CAAC;IAC/B,IAAI,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE;QAChC,cAAc,GAAG,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;KAC/C;IACD,IAAI,cAAc,KAAK,SAAS,EAAE;QAChC,MAAM,CAAC,OAAO,CAAC,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACzE,MAAM,IAAI,KAAK,CACb,qDAAqD,YAAY,EAAE,CACpE,CAAC;KACH;IAED,MAAM,IAAI,GAAG,cAAc,CAAC,WAAW,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC;IAElE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAc,EAAE,EAAE;QACrC,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,IAAI,MAAM,CAAC,KAAK,KAAK,SAAS,EAAE;YACjE,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,OAAO,EAAE,CAAC;SACjE;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,EAC3B,SAAS,GAAG,EAAE,EACd,YAAY,GAAG,EAAE,EACjB,MAAM,EACN,YAAY,GAAG,EAAE,EAMlB,EAAU,EAAE,CAAC,CAAC;IACb,SAAS;IACT,YAAY;IACZ,MAAM;IACN,aAAa,EAAE,CAAC,EAAU,EAAE,EAAE;QAC5B,MAAM,MAAM,GAAG,YAAY,CAAC,EAAE,CAAC,CAAC;QAChC,IAAI,CAAC,MAAM;YACT,OAAO,CAAC,KAAK,CACX,wBAAwB,EAAE,kDAAkD,MAAM,CAAC,IAAI,CACrF,YAAY,CACb,EAAE,CACJ,CAAC;QACJ,OAAO,MAAM,CAAC;IAChB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.d.ts b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.d.ts
new file mode 100644
index 0000000..3cb7d21
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.d.ts
@@ -0,0 +1,58 @@
+import { Metadata } from '../../Metadata.js';
+export type ValueJSON = string | boolean | number | number[];
+export type LinkJSON = {
+    nodeId: string;
+    socket: string;
+};
+export type NodeParameterValueJSON = {
+    value: ValueJSON;
+};
+export type NodeParameterLinkJSON = {
+    link: LinkJSON;
+};
+export type NodeParameterJSON = NodeParameterValueJSON | NodeParameterLinkJSON;
+export type NodeParametersJSON = {
+    [key: string]: NodeParameterJSON;
+};
+export type FlowsJSON = {
+    [key: string]: LinkJSON;
+};
+export type NodeConfigurationJSON = {
+    [key: string]: ValueJSON;
+};
+export type NodeJSON = {
+    label?: string;
+    type: string;
+    id: string;
+    configuration?: NodeConfigurationJSON;
+    parameters?: NodeParametersJSON;
+    flows?: FlowsJSON;
+    metadata?: Metadata;
+};
+export type VariableJSON = {
+    label?: string;
+    id: string;
+    name: string;
+    valueTypeName: string;
+    initialValue: ValueJSON;
+    metadata?: Metadata;
+};
+export type CustomEventParameterJSON = {
+    name: string;
+    valueTypeName: string;
+    defaultValue: ValueJSON;
+};
+export type CustomEventJSON = {
+    label?: string;
+    id: string;
+    name: string;
+    parameters?: CustomEventParameterJSON[];
+    metadata?: Metadata;
+};
+export type GraphJSON = {
+    name?: string;
+    nodes?: NodeJSON[];
+    variables?: VariableJSON[];
+    customEvents?: CustomEventJSON[];
+    metadata?: Metadata;
+};
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js
new file mode 100644
index 0000000..68c8d8f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=GraphJSON.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js.map b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js.map
new file mode 100644
index 0000000..fc0e6a5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/GraphJSON.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"GraphJSON.js","sourceRoot":"","sources":["../../../src/Graphs/IO/GraphJSON.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.d.ts b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.d.ts
new file mode 100644
index 0000000..2c20961
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.d.ts
@@ -0,0 +1,29 @@
+import { NodeCategory } from '../../Nodes/Registry/NodeCategory.js';
+import { ValueJSON } from './GraphJSON.js';
+export type ChoiceJSON = {
+    text: string;
+    value: any;
+}[];
+export type InputSocketSpecJSON = {
+    name: string;
+    valueType: string;
+    defaultValue?: ValueJSON;
+    choices?: ChoiceJSON;
+};
+export type OutputSocketSpecJSON = {
+    name: string;
+    valueType: string;
+};
+export type ConfigurationSpecJSON = {
+    name: string;
+    valueType: string;
+    defaultValue: ValueJSON;
+};
+export type NodeSpecJSON = {
+    type: string;
+    category: NodeCategory;
+    label: string;
+    configuration: ConfigurationSpecJSON[];
+    inputs: InputSocketSpecJSON[];
+    outputs: OutputSocketSpecJSON[];
+};
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js
new file mode 100644
index 0000000..41d1ec9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=NodeSpecJSON.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js.map b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js.map
new file mode 100644
index 0000000..aed2e35
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/NodeSpecJSON.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeSpecJSON.js","sourceRoot":"","sources":["../../../src/Graphs/IO/NodeSpecJSON.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.d.ts b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.d.ts
new file mode 100644
index 0000000..fc2587b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.d.ts
@@ -0,0 +1,7 @@
+import { IRegistry } from '../../Registry.js';
+import { GraphInstance } from '../Graph.js';
+import { GraphJSON } from './GraphJSON.js';
+export declare function readGraphFromJSON({ graphJson, registry }: {
+    graphJson: GraphJSON;
+    registry: IRegistry;
+}): GraphInstance;
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js
new file mode 100644
index 0000000..eb8dac3
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js
@@ -0,0 +1,198 @@
+import { Logger } from '../../Diagnostics/Logger.js';
+import { CustomEvent } from '../../Events/CustomEvent.js';
+import { Link } from '../../Nodes/Link.js';
+import { Socket } from '../../Sockets/Socket.js';
+import { Variable } from '../../Values/Variables/Variable.js';
+import { createNode, makeGraphApi } from '../Graph.js';
+// Purpose:
+//  - loads a node graph
+export function readGraphFromJSON({ graphJson, registry }) {
+    const graphName = graphJson?.name || '';
+    const graphMetadata = graphJson?.metadata || {};
+    let variables = {};
+    let customEvents = {};
+    if ('variables' in graphJson) {
+        variables = readVariablesJSON(registry.values, graphJson.variables ?? []);
+    }
+    if ('customEvents' in graphJson) {
+        customEvents = readCustomEventsJSON(registry.values, graphJson.customEvents ?? []);
+    }
+    const nodesJson = graphJson?.nodes ?? [];
+    if (nodesJson.length === 0) {
+        Logger.warning('readGraphFromJSON: no nodes specified');
+    }
+    const graphApi = makeGraphApi({
+        ...registry,
+        variables,
+        customEvents
+    });
+    const nodes = {};
+    // create new BehaviorNode instances for each node in the json.
+    for (let i = 0; i < nodesJson.length; i += 1) {
+        const nodeJson = nodesJson[i];
+        const node = readNodeJSON({
+            graph: graphApi,
+            registry,
+            nodeJson
+        });
+        const id = nodeJson.id;
+        if (id in nodes) {
+            throw new Error(`can not create new node with id ${id} as one with that id already exists.`);
+        }
+        nodes[id] = node;
+    }
+    // connect up the graph edges from BehaviorNode inputs to outputs.  This is required to follow execution
+    Object.entries(nodes).forEach(([nodeId, node]) => {
+        // initialize the inputs by resolving to the reference nodes.
+        node.inputs.forEach((inputSocket) => {
+            inputSocket.links.forEach((link) => {
+                if (!(link.nodeId in nodes)) {
+                    throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` +
+                        `a nonexistent upstream node id: ${link.nodeId}`);
+                }
+                const upstreamNode = nodes[link.nodeId];
+                const upstreamOutputSocket = upstreamNode.outputs.find((socket) => socket.name === link.socketName);
+                if (upstreamOutputSocket === undefined) {
+                    throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` +
+                        `a nonexistent output '${link.socketName}' on upstream node '${upstreamNode.description.typeName}'`);
+                }
+                // add, only if unique
+                const upstreamLink = new Link(nodeId, inputSocket.name);
+                if (upstreamOutputSocket.links.findIndex((value) => value.nodeId == upstreamLink.nodeId &&
+                    value.socketName == upstreamLink.socketName) < 0) {
+                    upstreamOutputSocket.links.push(upstreamLink);
+                }
+            });
+        });
+        node.outputs.forEach((outputSocket) => {
+            outputSocket.links.forEach((link) => {
+                if (!(link.nodeId in nodes)) {
+                    throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` +
+                        `a nonexistent downstream node id ${link.nodeId}`);
+                }
+                const downstreamNode = nodes[link.nodeId];
+                const downstreamInputSocket = downstreamNode.inputs.find((socket) => socket.name === link.socketName);
+                if (downstreamInputSocket === undefined) {
+                    throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` +
+                        `a nonexistent input '${link.socketName}' on downstream node '${downstreamNode.description.typeName}'`);
+                }
+                // add, only if unique
+                const downstreamLink = new Link(nodeId, outputSocket.name);
+                if (downstreamInputSocket.links.findIndex((value) => value.nodeId == downstreamLink.nodeId &&
+                    value.socketName == downstreamLink.socketName) < 0) {
+                    downstreamInputSocket.links.push(downstreamLink);
+                }
+            });
+        });
+    });
+    return {
+        name: graphName,
+        metadata: graphMetadata,
+        nodes: nodes,
+        customEvents,
+        variables
+    };
+}
+function readNodeJSON({ graph, registry, nodeJson }) {
+    if (nodeJson.type === undefined) {
+        throw new Error('readGraphFromJSON: no type for node');
+    }
+    const nodeName = nodeJson.type;
+    const nodeConfigurationJson = nodeJson.configuration;
+    const nodeConfiguration = {};
+    if (nodeConfigurationJson !== undefined) {
+        Object.keys(nodeConfigurationJson).forEach((key) => {
+            nodeConfiguration[key] = nodeConfigurationJson[key];
+        });
+    }
+    const node = createNode({
+        graph,
+        registry,
+        nodeTypeName: nodeName,
+        nodeConfiguration
+    });
+    node.label = nodeJson?.label ?? node.label;
+    node.metadata = nodeJson?.metadata ?? node.metadata;
+    if (nodeJson.parameters !== undefined) {
+        readNodeParameterJSON(registry.values, node, nodeJson.parameters);
+    }
+    if (nodeJson.flows !== undefined) {
+        readNodeFlowsJSON(node, nodeJson.flows);
+    }
+    return node;
+}
+function readNodeParameterJSON(valuesRegistry, node, parametersJson) {
+    node.inputs.forEach((socket) => {
+        if (!(socket.name in parametersJson)) {
+            return;
+        }
+        const inputJson = parametersJson[socket.name];
+        if ('value' in inputJson) {
+            // eslint-disable-next-line no-param-reassign
+            socket.value = valuesRegistry[socket.valueTypeName]?.deserialize(inputJson.value);
+        }
+        if ('link' in inputJson) {
+            const linkJson = inputJson.link;
+            socket.links.push(new Link(linkJson.nodeId, linkJson.socket));
+        }
+    });
+    // validate that there are no additional input sockets specified that were not read.
+    for (const inputName in parametersJson) {
+        const inputSocket = node.inputs.find((socket) => socket.name === inputName);
+        if (inputSocket === undefined) {
+            throw new Error(`node '${node.description.typeName}' specifies an input '${inputName}' that doesn't exist on its node type, available inputs are: ${node.inputs
+                .map((input) => input.name)
+                .join(', ')}`);
+        }
+    }
+}
+function readNodeFlowsJSON(node, flowsJson) {
+    node.outputs.forEach((socket) => {
+        if (socket.name in flowsJson) {
+            const outputLinkJson = flowsJson[socket.name];
+            socket.links.push(new Link(outputLinkJson.nodeId, outputLinkJson.socket));
+        }
+    });
+    // validate that there are no additional input sockets specified that were not read.
+    for (const outputName in flowsJson) {
+        const outputSocket = node.outputs.find((socket) => socket.name === outputName);
+        if (outputSocket === undefined) {
+            throw new Error(`node '${node.description.typeName}' specifies an output '${outputName}' that doesn't exist on its node type, available outputs are: ${node.outputs
+                .map((output) => output.name)
+                .join(', ')}`);
+        }
+    }
+}
+function readVariablesJSON(valuesRegistry, variablesJson) {
+    const variables = {};
+    for (let i = 0; i < variablesJson.length; i += 1) {
+        const variableJson = variablesJson[i];
+        const variable = new Variable(variableJson.id, variableJson.name, variableJson.valueTypeName, valuesRegistry[variableJson.valueTypeName]?.deserialize(variableJson.initialValue));
+        variable.label = variableJson?.label ?? variable.label;
+        variable.metadata = variableJson?.metadata ?? variable.metadata;
+        if (variableJson.id in variables) {
+            throw new Error(`duplicate variable id ${variable.id}`);
+        }
+        variables[variableJson.id] = variable;
+    }
+    return variables;
+}
+function readCustomEventsJSON(valuesRegistry, customEventsJson) {
+    const customEvents = {};
+    for (let i = 0; i < customEventsJson.length; i += 1) {
+        const customEventJson = customEventsJson[i];
+        const parameters = [];
+        (customEventJson.parameters ?? []).forEach((parameterJson) => {
+            parameters.push(new Socket(parameterJson.valueTypeName, parameterJson.name, valuesRegistry[parameterJson.valueTypeName]?.deserialize(parameterJson.defaultValue)));
+        });
+        const customEvent = new CustomEvent(customEventJson.id, customEventJson.name, parameters);
+        customEvent.label = customEventJson?.label ?? customEvent.label;
+        customEvent.metadata = customEventJson?.metadata ?? customEvent.metadata;
+        if (customEvent.id in customEvents) {
+            throw new Error(`duplicate variable id ${customEvent.id}`);
+        }
+        customEvents[customEvent.id] = customEvent;
+    }
+    return customEvents;
+}
+//# sourceMappingURL=readGraphFromJSON.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js.map b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js.map
new file mode 100644
index 0000000..8b72982
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/readGraphFromJSON.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"readGraphFromJSON.js","sourceRoot":"","sources":["../../../src/Graphs/IO/readGraphFromJSON.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.d.ts b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.d.ts
new file mode 100644
index 0000000..188172b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.d.ts
@@ -0,0 +1,4 @@
+import { IRegistry } from '../../Registry.js';
+import { GraphInstance } from '../Graph.js';
+import { GraphJSON } from './GraphJSON.js';
+export declare function writeGraphToJSON(graph: GraphInstance, registry: IRegistry): GraphJSON;
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js
new file mode 100644
index 0000000..b0decfb
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js
@@ -0,0 +1,121 @@
+export function writeGraphToJSON(graph, registry) {
+    const graphJson = {};
+    if (Object.keys(graph.metadata).length > 0) {
+        graphJson.metadata = graph.metadata;
+    }
+    // save custom events
+    Object.values(graph.customEvents).forEach((customEvent) => {
+        const customEventJson = {
+            name: customEvent.name,
+            id: customEvent.id
+        };
+        if (customEvent.label.length > 0) {
+            customEventJson.label = customEvent.label;
+        }
+        if (customEvent.parameters.length > 0) {
+            const parametersJson = [];
+            customEvent.parameters.forEach((parameter) => {
+                parametersJson.push({
+                    name: parameter.name,
+                    valueTypeName: parameter.valueTypeName,
+                    defaultValue: parameter.value
+                });
+            });
+            customEventJson.parameters = parametersJson;
+        }
+        if (Object.keys(customEvent.metadata).length > 0) {
+            customEventJson.metadata = customEvent.metadata;
+        }
+        if (graphJson.customEvents === undefined) {
+            graphJson.customEvents = [];
+        }
+        graphJson.customEvents.push(customEventJson);
+    });
+    // save variables
+    Object.values(graph.variables).forEach((variable) => {
+        const variableJson = {
+            valueTypeName: variable.valueTypeName,
+            name: variable.name,
+            id: variable.id,
+            initialValue: registry.values[variable.valueTypeName]?.serialize(variable.initialValue)
+        };
+        if (variable.label.length > 0) {
+            variableJson.label = variable.label;
+        }
+        if (Object.keys(variable.metadata).length > 0) {
+            variableJson.metadata = variable.metadata;
+        }
+        if (graphJson.variables === undefined) {
+            graphJson.variables = [];
+        }
+        graphJson.variables.push(variableJson);
+    });
+    // save nodes
+    Object.entries(graph.nodes).forEach(([id, node]) => {
+        const nodeJson = {
+            type: node.description.typeName,
+            id
+        };
+        if (node.label && node.label.length > 0) {
+            nodeJson.label = node.label;
+        }
+        if (Object.keys(node.metadata).length > 0) {
+            nodeJson.metadata = node.metadata;
+        }
+        if (Object.keys(node.description.configuration).length > 0) {
+            const configurationJson = {};
+            Object.keys(node.configuration).forEach((key) => {
+                configurationJson[key] = node.configuration[key];
+            });
+            nodeJson.configuration = configurationJson;
+        }
+        const parametersJson = {};
+        node.inputs.forEach((inputSocket) => {
+            if (inputSocket.valueTypeName === 'flow')
+                return;
+            let parameterJson = undefined;
+            if (inputSocket.links.length === 0) {
+                parameterJson = {
+                    value: registry.values[inputSocket.valueTypeName]?.serialize(inputSocket.value)
+                };
+            }
+            else if (inputSocket.links.length === 1) {
+                const link = inputSocket.links[0];
+                parameterJson = {
+                    link: {
+                        nodeId: link.nodeId,
+                        socket: link.socketName
+                    }
+                };
+            }
+            else {
+                throw new Error(`should not get here, inputSocket.links.length = ${inputSocket.links.length} > 1`);
+            }
+            parametersJson[inputSocket.name] = parameterJson;
+        });
+        if (Object.keys(parametersJson).length > 0) {
+            nodeJson.parameters = parametersJson;
+        }
+        const flowsJson = {};
+        node.outputs.forEach((outputSocket) => {
+            if (outputSocket.valueTypeName !== 'flow')
+                return;
+            if (outputSocket.links.length === 0)
+                return;
+            const linkJson = {
+                nodeId: outputSocket.links[0].nodeId,
+                socket: outputSocket.links[0].socketName
+            };
+            flowsJson[outputSocket.name] = linkJson;
+        });
+        if (Object.keys(flowsJson).length > 0) {
+            nodeJson.flows = flowsJson;
+        }
+        if (graphJson.nodes === undefined) {
+            graphJson.nodes = [];
+        }
+        graphJson.nodes.push(nodeJson);
+    });
+    return graphJson;
+}
+//# sourceMappingURL=writeGraphToJSON.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js.map b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js.map
new file mode 100644
index 0000000..28a62a3
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeGraphToJSON.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"writeGraphToJSON.js","sourceRoot":"","sources":["../../../src/Graphs/IO/writeGraphToJSON.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.d.ts b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.d.ts
new file mode 100644
index 0000000..5ba295a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.d.ts
@@ -0,0 +1,5 @@
+import { IRegistry } from '../../Registry.js';
+import { NodeConfigurationJSON } from './GraphJSON.js';
+import { NodeSpecJSON } from './NodeSpecJSON.js';
+export declare function writeNodeSpecToJSON(registry: IRegistry, nodeTypeName: string, configuration: NodeConfigurationJSON): NodeSpecJSON;
+export declare function writeDefaultNodeSpecsToJSON(registry: IRegistry): NodeSpecJSON[];
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js
new file mode 100644
index 0000000..063d9dd
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js
@@ -0,0 +1,83 @@
+import { createNode, makeGraphApi } from '../Graph.js';
+function toChoices(valueChoices) {
+    return valueChoices?.map((choice) => {
+        if (typeof choice === 'string')
+            return { text: choice, value: choice };
+        return choice;
+    });
+}
+// create JSON specs for a single node based on given configuration
+export function writeNodeSpecToJSON(registry, nodeTypeName, configuration) {
+    const graph = makeGraphApi({
+        ...registry,
+        customEvents: {},
+        variables: {}
+    });
+    const node = createNode({
+        graph,
+        registry,
+        nodeTypeName,
+        nodeConfiguration: configuration
+    });
+    const nodeDefinition = registry.nodes[nodeTypeName];
+    const nodeSpecJSON = {
+        type: nodeTypeName,
+        category: node.description.category,
+        label: node.description.label,
+        inputs: [],
+        outputs: [],
+        configuration: []
+    };
+    if (nodeDefinition.configuration) {
+        Object.entries(nodeDefinition.configuration).forEach(([configName, configSpec]) => {
+            nodeSpecJSON.configuration.push({
+                name: configName,
+                valueType: configSpec.valueType,
+                defaultValue: configSpec.defaultValue
+            });
+        });
+    }
+    node.inputs.forEach((inputSocket) => {
+        const valueType = inputSocket.valueTypeName === 'flow'
+            ? undefined
+            : registry.values[inputSocket.valueTypeName];
+        let defaultValue = inputSocket.value;
+        if (valueType !== undefined) {
+            defaultValue = valueType.serialize(defaultValue);
+        }
+        if (defaultValue === undefined && valueType !== undefined) {
+            defaultValue = valueType.serialize(valueType.creator());
+        }
+        const socketSpecJSON = {
+            name: inputSocket.name,
+            valueType: inputSocket.valueTypeName,
+            defaultValue,
+            choices: toChoices(inputSocket.valueChoices)
+        };
+        nodeSpecJSON.inputs.push(socketSpecJSON);
+    });
+    node.outputs.forEach((outputSocket) => {
+        const socketSpecJSON = {
+            name: outputSocket.name,
+            valueType: outputSocket.valueTypeName
+        };
+        nodeSpecJSON.outputs.push(socketSpecJSON);
+    });
+    Object.entries(node.description.configuration).forEach(([configName, configSpec]) => {
+        nodeSpecJSON.configuration.push({
+            name: configName,
+            valueType: configSpec.valueType,
+            defaultValue: configSpec.defaultValue
+        });
+    });
+    return nodeSpecJSON;
+}
+// create JSON specs for all nodes with empty configuration
+export function writeDefaultNodeSpecsToJSON(registry) {
+    const nodeSpecsJSON = [];
+    Object.keys(registry.nodes).forEach((nodeTypeName) => {
+        nodeSpecsJSON.push(writeNodeSpecToJSON(registry, nodeTypeName, {}));
+    });
+    return nodeSpecsJSON;
+}
+//# sourceMappingURL=writeNodeSpecsToJSON.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js.map b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js.map
new file mode 100644
index 0000000..01206f5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/IO/writeNodeSpecsToJSON.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"writeNodeSpecsToJSON.js","sourceRoot":"","sources":["../../../src/Graphs/IO/writeNodeSpecsToJSON.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.d.ts b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.d.ts
new file mode 100644
index 0000000..50677b4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.d.ts
@@ -0,0 +1,2 @@
+import { GraphInstance } from '../Graph.js';
+export declare function validateGraph(graph: GraphInstance): string[];
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js
new file mode 100644
index 0000000..db52120
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js
@@ -0,0 +1,8 @@
+import { validateGraphAcyclic } from './validateGraphAcyclic.js';
+import { validateGraphLinks } from './validateGraphLinks.js';
+export function validateGraph(graph) {
+    const errorList = [];
+    errorList.push(...validateGraphAcyclic(graph.nodes), ...validateGraphLinks(graph.nodes));
+    return errorList;
+}
+//# sourceMappingURL=validateGraph.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js.map b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js.map
new file mode 100644
index 0000000..46f7bcd
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraph.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateGraph.js","sourceRoot":"","sources":["../../../src/Graphs/Validation/validateGraph.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,2BAA2B,CAAC;AACjE,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AAE7D,MAAM,UAAU,aAAa,CAAC,KAAoB;IAChD,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,SAAS,CAAC,IAAI,CACZ,GAAG,oBAAoB,CAAC,KAAK,CAAC,KAAK,CAAC,EACpC,GAAG,kBAAkB,CAAC,KAAK,CAAC,KAAK,CAAC,CACnC,CAAC;IACF,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.d.ts b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.d.ts
new file mode 100644
index 0000000..f482488
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.d.ts
@@ -0,0 +1,2 @@
+import { GraphNodes } from '../Graph.js';
+export declare function validateGraphAcyclic(nodes: GraphNodes): string[];
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js
new file mode 100644
index 0000000..34d2b40
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js
@@ -0,0 +1,49 @@
+export function validateGraphAcyclic(nodes) {
+    // apparently if you can topological sort, it is a DAG according to: https://stackoverflow.com/questions/4168/graph-serialization/4577#4577
+    // instead of modifying the graph, I will use metadata to mark it in place.
+    Object.values(nodes).forEach((node) => {
+        // eslint-disable-next-line no-param-reassign
+        node.metadata['dag.marked'] = 'false';
+    });
+    // it appears that we can just keep trimming nodes whose input sockets have no connections.
+    // if we can remove all nodes, that means that there are no cycles.
+    const nodesToMark = [];
+    do {
+        // clear array: https://stackoverflow.com/a/1232046
+        nodesToMark.length = 0;
+        Object.values(nodes).forEach((node) => {
+            // ignore existing marked nodes.
+            if (node.metadata['dag.marked'] === 'true') {
+                return;
+            }
+            let inputsConnected = false;
+            node.inputs.forEach((inputSocket) => {
+                inputSocket.links.forEach((link) => {
+                    // is the other end marked?  If not, then it is still connected.
+                    if (nodes[link.nodeId].metadata['dag.marked'] === 'false') {
+                        inputsConnected = true;
+                    }
+                });
+            });
+            if (!inputsConnected) {
+                nodesToMark.push(node);
+            }
+        });
+        nodesToMark.forEach((node) => {
+            // eslint-disable-next-line no-param-reassign
+            node.metadata['dag.marked'] = 'true';
+        });
+    } while (nodesToMark.length > 0);
+    const errorList = [];
+    // output errors for each unmarked node
+    // also remove the metadata related to DAG marking
+    Object.values(nodes).forEach((node) => {
+        if (node.metadata['dag.marked'] === 'false') {
+            errorList.push(`node ${node.description.typeName} is part of a cycle, not a directed acyclic graph`);
+        }
+        // eslint-disable-next-line no-param-reassign
+        delete node.metadata['dag.marked'];
+    });
+    return errorList;
+}
+//# sourceMappingURL=validateGraphAcyclic.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js.map b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js.map
new file mode 100644
index 0000000..015a6b0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphAcyclic.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateGraphAcyclic.js","sourceRoot":"","sources":["../../../src/Graphs/Validation/validateGraphAcyclic.ts"],"names":[],"mappings":"AAGA,MAAM,UAAU,oBAAoB,CAAC,KAAiB;IACpD,2IAA2I;IAE3I,2EAA2E;IAC3E,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACpC,6CAA6C;QAC7C,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,OAAO,CAAC;IACxC,CAAC,CAAC,CAAC;IAEH,2FAA2F;IAC3F,mEAAmE;IAEnE,MAAM,WAAW,GAAY,EAAE,CAAC;IAEhC,GAAG;QACD,mDAAmD;QACnD,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;QAEvB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YACpC,gCAAgC;YAChC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,MAAM,EAAE;gBAC1C,OAAO;aACR;YAED,IAAI,eAAe,GAAG,KAAK,CAAC;YAC5B,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;gBAClC,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;oBACjC,gEAAgE;oBAChE,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,OAAO,EAAE;wBACzD,eAAe,GAAG,IAAI,CAAC;qBACxB;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,eAAe,EAAE;gBACpB,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACxB;QACH,CAAC,CAAC,CAAC;QACH,WAAW,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;YAC3B,6CAA6C;YAC7C,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC;QACvC,CAAC,CAAC,CAAC;KACJ,QAAQ,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;IAEjC,MAAM,SAAS,GAAa,EAAE,CAAC;IAE/B,uCAAuC;IACvC,kDAAkD;IAClD,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACpC,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,OAAO,EAAE;YAC3C,SAAS,CAAC,IAAI,CACZ,QAAQ,IAAI,CAAC,WAAW,CAAC,QAAQ,mDAAmD,CACrF,CAAC;SACH;QACD,6CAA6C;QAC7C,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;IAEH,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.d.ts b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.d.ts
new file mode 100644
index 0000000..717dfed
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.d.ts
@@ -0,0 +1,2 @@
+import { GraphNodes } from '../Graph.js';
+export declare function validateGraphLinks(nodes: GraphNodes): string[];
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js
new file mode 100644
index 0000000..0aca89d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js
@@ -0,0 +1,32 @@
+export function validateGraphLinks(nodes) {
+    const errorList = [];
+    // for each node
+    Object.values(nodes).forEach((node) => {
+        // for each input socket
+        node.inputs.forEach((inputSocket) => {
+            // ensure that connected output sockets are the same type
+            inputSocket.links.forEach((link) => {
+                // check if the node id is correct
+                if (!(link.nodeId in nodes)) {
+                    errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using invalid nodeId: ${link.nodeId}`);
+                    return;
+                }
+                // check if the socketName is correct
+                const upstreamNode = nodes[link.nodeId];
+                const outputSocket = upstreamNode.outputs.find((socket) => socket.name === link.socketName);
+                if (outputSocket === undefined) {
+                    errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using a non-existent socket name: ` +
+                        `${link.socketName}, it can not be found on upstream output node: ${upstreamNode.description.typeName}`);
+                    return;
+                }
+                // check if the socket types align
+                if (inputSocket.valueTypeName !== outputSocket.valueTypeName) {
+                    errorList.push(`type mismatch between ${node.description.typeName}.${inputSocket.name} [${inputSocket.valueTypeName}] ` +
+                        `and ${upstreamNode.description.typeName}.${outputSocket.name} [${outputSocket.valueTypeName}]`);
+                }
+            });
+        });
+    });
+    return errorList;
+}
+//# sourceMappingURL=validateGraphLinks.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js.map b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js.map
new file mode 100644
index 0000000..57a9bd7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Graphs/Validation/validateGraphLinks.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateGraphLinks.js","sourceRoot":"","sources":["../../../src/Graphs/Validation/validateGraphLinks.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,kBAAkB,CAAC,KAAiB;IAClD,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,gBAAgB;IAChB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACpC,wBAAwB;QACxB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,EAAE;YAClC,yDAAyD;YACzD,WAAW,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;gBACjC,kCAAkC;gBAClC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC,EAAE;oBAC3B,SAAS,CAAC,IAAI,CACZ,QAAQ,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,IAAI,mCAAmC,IAAI,CAAC,MAAM,EAAE,CACtG,CAAC;oBACF,OAAO;iBACR;gBAED,qCAAqC;gBACrC,MAAM,YAAY,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACxC,MAAM,YAAY,GAAG,YAAY,CAAC,OAAO,CAAC,IAAI,CAC5C,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,IAAI,CAAC,UAAU,CAC5C,CAAC;gBACF,IAAI,YAAY,KAAK,SAAS,EAAE;oBAC9B,SAAS,CAAC,IAAI,CACZ,QAAQ,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,IAAI,8CAA8C;wBACjG,GAAG,IAAI,CAAC,UAAU,kDAAkD,YAAY,CAAC,WAAW,CAAC,QAAQ,EAAE,CAC1G,CAAC;oBACF,OAAO;iBACR;gBAED,kCAAkC;gBAClC,IAAI,WAAW,CAAC,aAAa,KAAK,YAAY,CAAC,aAAa,EAAE;oBAC5D,SAAS,CAAC,IAAI,CACZ,yBAAyB,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,WAAW,CAAC,IAAI,KAAK,WAAW,CAAC,aAAa,IAAI;wBACtG,OAAO,YAAY,CAAC,WAAW,CAAC,QAAQ,IAAI,YAAY,CAAC,IAAI,KAAK,YAAY,CAAC,aAAa,GAAG,CAClG,CAAC;iBACH;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Metadata.d.ts b/node_modules/@behave-graph/core/dist/Metadata.d.ts
new file mode 100644
index 0000000..e737107
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Metadata.d.ts
@@ -0,0 +1,3 @@
+export type Metadata = {
+    [key: string]: string;
+};
diff --git a/node_modules/@behave-graph/core/dist/Metadata.js b/node_modules/@behave-graph/core/dist/Metadata.js
new file mode 100644
index 0000000..28ff047
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Metadata.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=Metadata.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Metadata.js.map b/node_modules/@behave-graph/core/dist/Metadata.js.map
new file mode 100644
index 0000000..5be6a92
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Metadata.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Metadata.js","sourceRoot":"","sources":["../src/Metadata.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.d.ts b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.d.ts
new file mode 100644
index 0000000..e2799a7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.d.ts
@@ -0,0 +1,28 @@
+import { Engine } from '../Execution/Engine.js';
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { Node, NodeConfiguration } from './Node.js';
+import { IAsyncNodeDefinition } from './NodeDefinitions.js';
+import { IAsyncNode, INode, NodeType } from './NodeInstance.js';
+import { NodeDescription } from './Registry/NodeDescription.js';
+export declare class AsyncNode extends Node<NodeType.Async> {
+    constructor(description: NodeDescription, graph: IGraph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
+export declare class AsyncNode2 extends AsyncNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: IGraph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+    });
+}
+export declare class AsyncNodeInstance<TAsyncNodeDef extends IAsyncNodeDefinition> extends Node<NodeType.Async> implements IAsyncNode {
+    private triggeredInner;
+    private disposeInner;
+    private state;
+    constructor(node: Omit<INode, 'nodeType'> & Pick<TAsyncNodeDef, 'triggered' | 'initialState' | 'dispose'>);
+    triggered: (engine: Pick<Engine, 'commitToNewFiber'>, triggeringSocketName: string, finished: () => void) => void;
+    dispose: () => void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js
new file mode 100644
index 0000000..3fe322c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js
@@ -0,0 +1,60 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { Node } from './Node.js';
+import { NodeType } from './NodeInstance.js';
+// async flow node with only a single flow input
+export class AsyncNode extends Node {
+    constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+        super({
+            description: {
+                ...description,
+                category: description.category
+            },
+            inputs,
+            outputs,
+            graph,
+            nodeType: NodeType.Async,
+            configuration
+        });
+        // must have at least one input flow socket
+        Assert.mustBeTrue(this.inputs.some((socket) => socket.valueTypeName === 'flow'));
+        // must have at least one output flow socket
+        Assert.mustBeTrue(this.outputs.some((socket) => socket.valueTypeName === 'flow'));
+    }
+    // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+    triggered(engine, triggeringSocketName, finished) {
+        throw new Error('not implemented');
+    }
+    dispose() {
+        throw new Error('not implemented');
+    }
+}
+export class AsyncNode2 extends AsyncNode {
+    constructor(props) {
+        super(props.description, props.graph, props.inputs, props.outputs);
+    }
+}
+export class AsyncNodeInstance extends Node {
+    constructor(node) {
+        super({ ...node, nodeType: NodeType.Async });
+        this.triggered = (engine, triggeringSocketName, finished) => {
+            this.triggeredInner({
+                read: this.readInput,
+                write: this.writeOutput,
+                commit: (outFlowname, fiberCompletedListener) => engine.commitToNewFiber(this, outFlowname, fiberCompletedListener),
+                configuration: this.configuration,
+                graph: this.graph,
+                finished,
+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                // @ts-ignore
+                triggeringSocketName
+            });
+        };
+        this.dispose = () => {
+            this.state = this.disposeInner({ state: this.state, graph: this.graph });
+        };
+        this.triggeredInner = node.triggered;
+        this.disposeInner = node.dispose;
+        this.state = node.initialState;
+    }
+}
+//# sourceMappingURL=AsyncNode.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js.map b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js.map
new file mode 100644
index 0000000..52a04c4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/AsyncNode.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"AsyncNode.js","sourceRoot":"","sources":["../../src/Nodes/AsyncNode.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,0BAA0B,CAAC;AAIlD,OAAO,EAAE,IAAI,EAAqB,MAAM,WAAW,CAAC;AAEpD,OAAO,EAAqB,QAAQ,EAAE,MAAM,mBAAmB,CAAC;AAGhE,gDAAgD;AAChD,MAAM,OAAO,SAAU,SAAQ,IAAoB;IACjD,YACE,WAA4B,EAC5B,KAAa,EACb,SAAmB,EAAE,EACrB,UAAoB,EAAE,EACtB,gBAAmC,EAAE;QAErC,KAAK,CAAC;YACJ,WAAW,EAAE;gBACX,GAAG,WAAW;gBACd,QAAQ,EAAE,WAAW,CAAC,QAAwB;aAC/C;YACD,MAAM;YACN,OAAO;YACP,KAAK;YACL,QAAQ,EAAE,QAAQ,CAAC,KAAK;YACxB,aAAa;SACd,CAAC,CAAC;QAEH,2CAA2C;QAC3C,MAAM,CAAC,UAAU,CACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,CAC9D,CAAC;QAEF,4CAA4C;QAC5C,MAAM,CAAC,UAAU,CACf,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,CAC/D,CAAC;IACJ,CAAC;IAED,4FAA4F;IAC5F,SAAS,CACP,MAAc,EACd,oBAA4B,EAC5B,QAAoB;QAEpB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;IAED,OAAO;QACL,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;CACF;AAED,MAAM,OAAO,UAAW,SAAQ,SAAS;IACvC,YAAY,KAKX;QACC,KAAK,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;IACrE,CAAC;CACF;AAED,MAAM,OAAO,iBACX,SAAQ,IAAoB;IAO5B,YACE,IAC+D;QAE/D,KAAK,CAAC,EAAE,GAAG,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;QAO/C,cAAS,GAAG,CACV,MAAwC,EACxC,oBAA4B,EAC5B,QAAoB,EACpB,EAAE;YACF,IAAI,CAAC,cAAc,CAAC;gBAClB,IAAI,EAAE,IAAI,CAAC,SAAS;gBACpB,KAAK,EAAE,IAAI,CAAC,WAAW;gBACvB,MAAM,EAAE,CAAC,WAAW,EAAE,sBAAsB,EAAE,EAAE,CAC9C,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,WAAW,EAAE,sBAAsB,CAAC;gBACpE,aAAa,EAAE,IAAI,CAAC,aAAa;gBACjC,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,QAAQ;gBACR,6DAA6D;gBAC7D,aAAa;gBACb,oBAAoB;aACrB,CAAC,CAAC;QACL,CAAC,CAAC;QACF,YAAO,GAAG,GAAG,EAAE;YACb,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QAC3E,CAAC,CAAC;QAzBA,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;IACjC,CAAC;CAuBF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/EventNode.d.ts b/node_modules/@behave-graph/core/dist/Nodes/EventNode.d.ts
new file mode 100644
index 0000000..dc6c15d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/EventNode.d.ts
@@ -0,0 +1,30 @@
+import { Engine } from '../Execution/Engine.js';
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { Node, NodeConfiguration } from './Node.js';
+import { IEventNodeDefinition } from './NodeDefinitions.js';
+import { IEventNode, INode, NodeType } from './NodeInstance.js';
+import { NodeDescription } from './Registry/NodeDescription.js';
+export declare class EventNode extends Node<NodeType.Event> implements IEventNode {
+    constructor(description: NodeDescription, graph: IGraph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
+export declare class EventNode2 extends EventNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: IGraph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+        configuration?: NodeConfiguration;
+    });
+}
+export declare class EventNodeInstance<TEventNodeDef extends IEventNodeDefinition> extends Node<NodeType.Event> implements IEventNode {
+    private initInner;
+    private disposeInner;
+    private state;
+    private readonly outputSocketKeys;
+    constructor(nodeProps: Omit<INode, 'nodeType'> & Pick<TEventNodeDef, 'init' | 'dispose' | 'initialState'>);
+    init: (engine: Engine) => any;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/EventNode.js b/node_modules/@behave-graph/core/dist/Nodes/EventNode.js
new file mode 100644
index 0000000..60e69d2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/EventNode.js
@@ -0,0 +1,67 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { Node } from './Node.js';
+import { NodeType } from './NodeInstance.js';
+// no flow inputs, always evaluated on startup
+export class EventNode extends Node {
+    constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+        super({
+            ...description,
+            description: {
+                ...description,
+                category: description.category
+            },
+            inputs,
+            outputs,
+            graph,
+            configuration,
+            nodeType: NodeType.Event
+        });
+        // no input flow sockets allowed.
+        Assert.mustBeTrue(!this.inputs.some((socket) => socket.valueTypeName === 'flow'));
+        // must have at least one output flow socket
+        Assert.mustBeTrue(this.outputs.some((socket) => socket.valueTypeName === 'flow'));
+    }
+    // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+    init(engine) {
+        throw new Error('not implemented');
+    }
+    // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+    dispose(engine) {
+        throw new Error('not implemented');
+    }
+}
+export class EventNode2 extends EventNode {
+    constructor(props) {
+        super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+    }
+}
+export class EventNodeInstance extends Node {
+    constructor(nodeProps) {
+        super({ ...nodeProps, nodeType: NodeType.Event });
+        this.init = (engine) => {
+            this.state = this.initInner({
+                read: this.readInput,
+                write: this.writeOutput,
+                state: this.state,
+                outputSocketKeys: this.outputSocketKeys,
+                commit: (outFlowname, fiberCompletedListener) => {
+                    engine.commitToNewFiber(this, outFlowname, fiberCompletedListener);
+                    engine.executeAllSync(1);
+                },
+                configuration: this.configuration,
+                graph: this.graph
+            });
+        };
+        this.initInner = nodeProps.init;
+        this.disposeInner = nodeProps.dispose;
+        this.state = nodeProps.initialState;
+        this.outputSocketKeys = nodeProps.outputs.map((s) => s.name);
+    }
+    dispose() {
+        this.disposeInner({
+            state: this.state,
+            graph: this.graph
+        });
+    }
+}
+//# sourceMappingURL=EventNode.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/EventNode.js.map b/node_modules/@behave-graph/core/dist/Nodes/EventNode.js.map
new file mode 100644
index 0000000..04ac77c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/EventNode.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"EventNode.js","sourceRoot":"","sources":["../../src/Nodes/EventNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FlowNode.d.ts b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.d.ts
new file mode 100644
index 0000000..cf13215
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.d.ts
@@ -0,0 +1,27 @@
+import { Fiber } from '../Execution/Fiber.js';
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { Node, NodeConfiguration } from './Node.js';
+import { IFlowNodeDefinition } from './NodeDefinitions.js';
+import { IFlowNode, INode, NodeType } from './NodeInstance.js';
+import { NodeDescription } from './Registry/NodeDescription.js';
+export declare class FlowNode extends Node<NodeType.Flow> implements IFlowNode {
+    constructor(description: NodeDescription, graph: IGraph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
+export declare class FlowNode2 extends FlowNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: IGraph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+        configuration?: NodeConfiguration;
+    });
+}
+export declare class FlowNodeInstance<TFlowNodeDefinition extends IFlowNodeDefinition> extends Node<NodeType.Flow> implements IFlowNode {
+    private triggeredInner;
+    private state;
+    private readonly outputSocketKeys;
+    constructor(nodeProps: Omit<INode, 'nodeType'> & Pick<TFlowNodeDefinition, 'triggered' | 'initialState'>);
+    triggered: (fiber: Fiber, triggeringSocketName: string) => void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js
new file mode 100644
index 0000000..358aa16
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js
@@ -0,0 +1,53 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { Node } from './Node.js';
+import { NodeType } from './NodeInstance.js';
+export class FlowNode extends Node {
+    constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+        // determine if this is an eval node
+        super({
+            description: {
+                ...description,
+                category: description.category
+            },
+            inputs,
+            outputs,
+            graph,
+            configuration,
+            nodeType: NodeType.Flow
+        });
+        // must have at least one input flow socket
+        Assert.mustBeTrue(this.inputs.some((socket) => socket.valueTypeName === 'flow'));
+    }
+    // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+    triggered(fiber, triggeringSocketName) {
+        throw new Error('not implemented');
+    }
+}
+export class FlowNode2 extends FlowNode {
+    constructor(props) {
+        super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+    }
+}
+export class FlowNodeInstance extends Node {
+    constructor(nodeProps) {
+        super({ ...nodeProps, nodeType: NodeType.Flow });
+        this.triggered = (fiber, triggeringSocketName) => {
+            this.state = this.triggeredInner({
+                commit: (outFlowName, fiberCompletedListener) => fiber.commit(this, outFlowName, fiberCompletedListener),
+                read: this.readInput,
+                write: this.writeOutput,
+                graph: this.graph,
+                state: this.state,
+                configuration: this.configuration,
+                outputSocketKeys: this.outputSocketKeys,
+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
+                // @ts-ignore
+                triggeringSocketName
+            });
+        };
+        this.triggeredInner = nodeProps.triggered;
+        this.state = nodeProps.initialState;
+        this.outputSocketKeys = nodeProps.outputs.map((s) => s.name);
+    }
+}
+//# sourceMappingURL=FlowNode.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js.map b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js.map
new file mode 100644
index 0000000..0836abc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FlowNode.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FlowNode.js","sourceRoot":"","sources":["../../src/Nodes/FlowNode.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,0BAA0B,CAAC;AAIlD,OAAO,EAAE,IAAI,EAAqB,MAAM,WAAW,CAAC;AAEpD,OAAO,EAAoB,QAAQ,EAAE,MAAM,mBAAmB,CAAC;AAG/D,MAAM,OAAO,QAAS,SAAQ,IAAmB;IAC/C,YACE,WAA4B,EAC5B,KAAa,EACb,SAAmB,EAAE,EACrB,UAAoB,EAAE,EACtB,gBAAmC,EAAE;QAErC,oCAAoC;QACpC,KAAK,CAAC;YACJ,WAAW,EAAE;gBACX,GAAG,WAAW;gBACd,QAAQ,EAAE,WAAW,CAAC,QAAwB;aAC/C;YACD,MAAM;YACN,OAAO;YACP,KAAK;YACL,aAAa;YACb,QAAQ,EAAE,QAAQ,CAAC,IAAI;SACxB,CAAC,CAAC;QAEH,2CAA2C;QAC3C,MAAM,CAAC,UAAU,CACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,CAC9D,CAAC;IACJ,CAAC;IAED,4FAA4F;IAC5F,SAAS,CAAC,KAAY,EAAE,oBAA4B;QAClD,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IACrC,CAAC;CACF;AAED,MAAM,OAAO,SAAU,SAAQ,QAAQ;IACrC,YAAY,KAMX;QACC,KAAK,CACH,KAAK,CAAC,WAAW,EACjB,KAAK,CAAC,KAAK,EACX,KAAK,CAAC,MAAM,EACZ,KAAK,CAAC,OAAO,EACb,KAAK,CAAC,aAAa,CACpB,CAAC;IACJ,CAAC;CACF;AAED,MAAM,OAAO,gBACX,SAAQ,IAAmB;IAO3B,YACE,SACyD;QAEzD,KAAK,CAAC,EAAE,GAAG,SAAS,EAAE,QAAQ,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;QAM5C,cAAS,GAAG,CAAC,KAAY,EAAE,oBAA4B,EAAE,EAAE;YAChE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC;gBAC/B,MAAM,EAAE,CAAC,WAAW,EAAE,sBAAsB,EAAE,EAAE,CAC9C,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,WAAW,EAAE,sBAAsB,CAAC;gBACzD,IAAI,EAAE,IAAI,CAAC,SAAS;gBACpB,KAAK,EAAE,IAAI,CAAC,WAAW;gBACvB,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,aAAa,EAAE,IAAI,CAAC,aAAa;gBACjC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;gBACvC,6DAA6D;gBAC7D,aAAa;gBACb,oBAAoB;aACrB,CAAC,CAAC;QACL,CAAC,CAAC;QAnBA,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC,SAAS,CAAC;QAC1C,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,YAAY,CAAC;QACpC,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IAC/D,CAAC;CAiBF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.d.ts b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.d.ts
new file mode 100644
index 0000000..b10c88a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.d.ts
@@ -0,0 +1,28 @@
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { Node, NodeConfiguration } from './Node.js';
+import { IFunctionNodeDefinition, NodeCategory, SocketsList } from './NodeDefinitions.js';
+import { IFunctionNode, INode, NodeType } from './NodeInstance.js';
+import { NodeDescription } from './Registry/NodeDescription.js';
+export declare abstract class FunctionNode extends Node<NodeType.Function> implements IFunctionNode {
+    readonly exec: (node: INode) => void;
+    constructor(description: NodeDescription, graph: IGraph, inputs: Socket[] | undefined, outputs: Socket[] | undefined, exec: (node: INode) => void, configuration?: NodeConfiguration);
+}
+export declare class FunctionNodeInstance<TFunctionNodeDef extends IFunctionNodeDefinition> extends Node<NodeType.Function> implements IFunctionNode {
+    private execInner;
+    constructor(nodeProps: Omit<INode, 'nodeType'> & Pick<TFunctionNodeDef, 'exec'>);
+    exec: (node: INode) => void;
+}
+export declare function makeInNOutFunctionDesc({ in: inputs, out, exec, category, ...rest }: {
+    name: string;
+    label: string;
+    aliases?: string[];
+    in?: (string | {
+        [key: string]: string;
+    })[];
+    out: (string | {
+        [key: string]: string;
+    })[] | string;
+    category?: NodeCategory;
+    exec: (...args: any[]) => any;
+}): IFunctionNodeDefinition<() => SocketsList, () => SocketsList, import("./Registry/NodeDescription.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js
new file mode 100644
index 0000000..f04703f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js
@@ -0,0 +1,88 @@
+import { Assert } from '../Diagnostics/Assert.js';
+import { Node } from './Node.js';
+import { makeFunctionNodeDefinition } from './NodeDefinitions.js';
+import { NodeType } from './NodeInstance.js';
+import { readInputFromSockets, writeOutputsToSocket } from './NodeSockets.js';
+export class FunctionNode extends Node {
+    constructor(description, graph, inputs = [], outputs = [], exec, configuration = {}) {
+        super({
+            description: {
+                ...description,
+                category: description.category
+            },
+            inputs,
+            outputs,
+            graph,
+            configuration,
+            nodeType: NodeType.Function
+        });
+        this.exec = exec;
+        // must have no input flow sockets
+        Assert.mustBeTrue(!this.inputs.some((socket) => socket.valueTypeName === 'flow'));
+        // must have no output flow sockets
+        Assert.mustBeTrue(!this.outputs.some((socket) => socket.valueTypeName === 'flow'));
+    }
+}
+export class FunctionNodeInstance extends Node {
+    constructor(nodeProps) {
+        super({ ...nodeProps, nodeType: NodeType.Function });
+        this.exec = (node) => {
+            this.execInner({
+                read: (name) => readInputFromSockets(node.inputs, name, node.description.typeName),
+                write: (name, value) => writeOutputsToSocket(node.outputs, name, value, node.description.typeName),
+                configuration: this.configuration,
+                graph: this.graph
+            });
+        };
+        this.execInner = nodeProps.exec;
+    }
+}
+const alpha = 'abcdefghijklmnop';
+const getAlphabeticalKey = (index) => alpha[index];
+/** Converts list of sockets specifying value type names to an ordeered list of sockets,
+ */
+function makeSocketsList(sockets, getKey) {
+    if (!sockets || sockets.length === 0)
+        return [];
+    return sockets.map((x, i) => {
+        if (typeof x === 'string') {
+            return {
+                key: getKey(i),
+                valueType: x
+            };
+        }
+        return {
+            key: Object.keys(x)[0],
+            valueType: x[Object.keys(x)[0]]
+        };
+    });
+}
+export function makeInNOutFunctionDesc({ in: inputs, out, exec, category, ...rest }) {
+    const inputSockets = makeSocketsList(inputs, getAlphabeticalKey);
+    const outputKeyFunc = typeof out === 'string' || out.length > 1
+        ? () => 'result'
+        : getAlphabeticalKey;
+    const outList = typeof out === 'string' ? [out] : out;
+    const outputSockets = makeSocketsList(outList, outputKeyFunc);
+    const definition = makeFunctionNodeDefinition({
+        typeName: rest.name,
+        label: rest.label,
+        in: () => inputSockets,
+        out: () => outputSockets,
+        category,
+        exec: ({ read, write }) => {
+            const args = inputSockets.map(({ key }) => read(key));
+            const results = exec(...args);
+            if (outputSockets.length === 1 && outputSockets[0].key === 'result') {
+                write('result', results);
+            }
+            else {
+                outputSockets.forEach(({ key }) => {
+                    write(key, results[key]);
+                });
+            }
+        }
+    });
+    return definition;
+}
+//# sourceMappingURL=FunctionNode.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js.map b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js.map
new file mode 100644
index 0000000..30bf236
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/FunctionNode.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FunctionNode.js","sourceRoot":"","sources":["../../src/Nodes/FunctionNode.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Link.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Link.d.ts
new file mode 100644
index 0000000..21499f4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Link.d.ts
@@ -0,0 +1,9 @@
+import { Socket } from '../Sockets/Socket.js';
+import { INode } from './NodeInstance.js';
+export declare class Link {
+    nodeId: string;
+    socketName: string;
+    _targetNode: INode | undefined;
+    _targetSocket: Socket | undefined;
+    constructor(nodeId?: string, socketName?: string);
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Link.js b/node_modules/@behave-graph/core/dist/Nodes/Link.js
new file mode 100644
index 0000000..5decacf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Link.js
@@ -0,0 +1,9 @@
+export class Link {
+    constructor(nodeId = '', socketName = '') {
+        this.nodeId = nodeId;
+        this.socketName = socketName;
+        this._targetNode = undefined;
+        this._targetSocket = undefined;
+    }
+}
+//# sourceMappingURL=Link.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Link.js.map b/node_modules/@behave-graph/core/dist/Nodes/Link.js.map
new file mode 100644
index 0000000..b90f547
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Link.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Link.js","sourceRoot":"","sources":["../../src/Nodes/Link.ts"],"names":[],"mappings":"AAGA,MAAM,OAAO,IAAI;IAIf,YAAmB,SAAiB,EAAE,EAAS,aAAqB,EAAE;QAAnD,WAAM,GAAN,MAAM,CAAa;QAAS,eAAU,GAAV,UAAU,CAAa;QAH/D,gBAAW,GAAsB,SAAS,CAAC;QAC3C,kBAAa,GAAuB,SAAS,CAAC;IAEoB,CAAC;CAC3E"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Node.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Node.d.ts
new file mode 100644
index 0000000..2e0f6c6
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Node.d.ts
@@ -0,0 +1,23 @@
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { INode, NodeType } from './NodeInstance.js';
+import { INodeDescription } from './Registry/NodeDescription.js';
+export type NodeConfiguration = {
+    [key: string]: any;
+};
+export declare abstract class Node<TNodeType extends NodeType> implements INode {
+    readonly inputs: Socket[];
+    readonly outputs: Socket[];
+    readonly description: INodeDescription;
+    nodeType: TNodeType;
+    readonly otherTypeNames: string[] | undefined;
+    graph: IGraph;
+    label?: string;
+    metadata: any;
+    readonly configuration: NodeConfiguration;
+    constructor(node: Omit<INode, 'nodeType' | 'id'> & {
+        nodeType: TNodeType;
+    });
+    readInput: <T>(inputName: string) => T;
+    writeOutput: <T>(outputName: string, value: T) => void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Node.js b/node_modules/@behave-graph/core/dist/Nodes/Node.js
new file mode 100644
index 0000000..8dc0f76
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Node.js
@@ -0,0 +1,19 @@
+import { readInputFromSockets, writeOutputsToSocket } from './NodeSockets.js';
+export class Node {
+    constructor(node) {
+        this.readInput = (inputName) => {
+            return readInputFromSockets(this.inputs, inputName, this.description.typeName);
+        };
+        this.writeOutput = (outputName, value) => {
+            writeOutputsToSocket(this.outputs, outputName, value, this.description.typeName);
+        };
+        this.inputs = node.inputs;
+        this.outputs = node.outputs;
+        this.description = node.description;
+        this.nodeType = node.nodeType;
+        this.graph = node.graph;
+        this.configuration = node.configuration;
+        this.metadata = node.metadata || {};
+    }
+}
+//# sourceMappingURL=Node.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Node.js.map b/node_modules/@behave-graph/core/dist/Nodes/Node.js.map
new file mode 100644
index 0000000..31e6036
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Node.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Node.js","sourceRoot":"","sources":["../../src/Nodes/Node.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAO9E,MAAM,OAAgB,IAAI;IAYxB,YAAY,IAA8D;QAU1E,cAAS,GAAG,CAAI,SAAiB,EAAK,EAAE;YACtC,OAAO,oBAAoB,CACzB,IAAI,CAAC,MAAM,EACX,SAAS,EACT,IAAI,CAAC,WAAW,CAAC,QAAQ,CAC1B,CAAC;QACJ,CAAC,CAAC;QAEF,gBAAW,GAAG,CAAI,UAAkB,EAAE,KAAQ,EAAE,EAAE;YAChD,oBAAoB,CAClB,IAAI,CAAC,OAAO,EACZ,UAAU,EACV,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,QAAQ,CAC1B,CAAC;QACJ,CAAC,CAAC;QAxBA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACpC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;QACxB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,IAAI,EAAE,CAAC;IACtC,CAAC;CAkBF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.d.ts b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.d.ts
new file mode 100644
index 0000000..6bef0af
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.d.ts
@@ -0,0 +1,87 @@
+import { IGraph } from '../Graphs/Graph.js';
+import { Choices } from '../Sockets/Socket.js';
+import { NodeConfiguration } from './Node.js';
+import { INode } from './NodeInstance.js';
+import { NodeCategory } from './Registry/NodeCategory.js';
+import { NodeConfigurationDescription } from './Registry/NodeDescription.js';
+export interface SocketDefinition {
+    valueType: string;
+    defaultValue?: any;
+    choices?: Choices;
+    label?: string;
+}
+export type SocketsMap = Record<string, SocketDefinition | string | ((nodeConfig: NodeConfiguration, graph: IGraph) => SocketDefinition)>;
+export type SocketListDefinition = SocketDefinition & {
+    key: string;
+};
+export type SocketsList = SocketListDefinition[];
+export type SocketsGeneratorFromConfig = (nodeConfig: NodeConfiguration, graph: IGraph) => SocketsList;
+export type SocketsDefinition = SocketsMap | SocketsGeneratorFromConfig;
+export type NodeFactory = (graph: IGraph, config: NodeConfiguration) => INode;
+export interface IHasNodeFactory {
+    readonly nodeFactory: NodeFactory;
+}
+export interface INodeDefinition<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TConfig extends NodeConfigurationDescription = NodeConfigurationDescription> extends IHasNodeFactory {
+    category?: NodeCategory;
+    typeName: string;
+    otherTypeNames?: string[];
+    aliases?: string[];
+    helpDescription?: string;
+    label?: string;
+    in: TInput;
+    out: TOutput;
+    configuration?: TConfig;
+}
+export type SocketNames<TSockets extends SocketsDefinition> = TSockets extends SocketsMap ? keyof TSockets : any;
+export type Dependencies = Record<string, any>;
+export type TriggeredFn<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TState = any> = (params: {
+    read<T>(inValueName: SocketNames<TInput>): T;
+    write<T>(outValueName: SocketNames<TOutput>, value: T): void;
+    commit(outFlowName: SocketNames<TOutput>, fiberCompletedListener?: () => void): void;
+    outputSocketKeys: SocketNames<TOutput>[];
+    triggeringSocketName: keyof TInput;
+    state: TState;
+    graph: IGraph;
+    configuration: NodeConfiguration;
+    finished?: () => void;
+}) => StateReturn<TState>;
+/** Flow Node Definition */
+export type TriggeredParams<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TState> = Parameters<TriggeredFn<TInput, TOutput, TState>>[0];
+export interface IHasInitialState<TState> {
+    initialState: TState;
+}
+export interface IHasTriggered<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TState> extends IHasInitialState<TState> {
+    triggered: TriggeredFn<TInput, TOutput, TState>;
+}
+export type StateReturn<TState> = TState extends undefined ? void : TState;
+export type EventNodeSetupParams<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TState> = Omit<TriggeredParams<TInput, TOutput, TState>, 'triggeringSocketName'>;
+export interface IHasInit<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TState> {
+    init: (params: EventNodeSetupParams<TInput, TOutput, TState>) => StateReturn<TState>;
+}
+export interface IHasDispose<TState> {
+    dispose: (params: {
+        state: TState;
+        graph: IGraph;
+    }) => StateReturn<TState>;
+}
+export interface IFlowNodeDefinition<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TConfig extends NodeConfigurationDescription = NodeConfigurationDescription, TState = any> extends INodeDefinition<TInput, TOutput, TConfig>, IHasInitialState<TState>, IHasTriggered<TInput, TOutput, TState> {
+}
+export interface IAsyncNodeDefinition<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TConfig extends NodeConfigurationDescription = NodeConfigurationDescription, TState = any> extends INodeDefinition<TInput, TOutput, TConfig>, IHasInitialState<TState>, IHasTriggered<TInput, TOutput, TState>, IHasDispose<TState> {
+}
+type OmitFactoryAndType<T extends INodeDefinition> = Omit<T, 'nodeFactory' | 'nodeType'>;
+export interface FunctionNodeExecParams<TInput extends SocketsDefinition, TOutput extends SocketsDefinition> {
+    read<T>(inValueName: SocketNames<TInput>): T;
+    write<T>(outValueName: SocketNames<TOutput>, value: T): void;
+    graph: IGraph;
+    configuration: NodeConfiguration;
+}
+export interface IFunctionNodeDefinition<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TConfig extends NodeConfigurationDescription = NodeConfigurationDescription> extends INodeDefinition<TInput, TOutput, TConfig> {
+    exec: (params: FunctionNodeExecParams<TInput, TOutput>) => void;
+}
+export interface IEventNodeDefinition<TInput extends SocketsDefinition = SocketsDefinition, TOutput extends SocketsDefinition = SocketsDefinition, TConfig extends NodeConfigurationDescription = NodeConfigurationDescription, TState = any> extends INodeDefinition<TInput, TOutput, TConfig>, IHasInitialState<TState>, IHasInit<TInput, TOutput, TState>, IHasDispose<TState> {
+}
+export declare function makeFlowNodeDefinition<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TConfig extends NodeConfigurationDescription, TState>(definition: OmitFactoryAndType<IFlowNodeDefinition<TInput, TOutput, TConfig, TState>>): IFlowNodeDefinition<TInput, TOutput, TConfig, TState>;
+export declare function makeAsyncNodeDefinition<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TConfig extends NodeConfigurationDescription, TState>(definition: OmitFactoryAndType<IAsyncNodeDefinition<TInput, TOutput, TConfig, TState>>): IAsyncNodeDefinition<TInput, TOutput, TConfig, TState>;
+export declare function makeFunctionNodeDefinition<TInput extends SocketsDefinition, TOutput extends SocketsDefinition>(definition: OmitFactoryAndType<IFunctionNodeDefinition<TInput, TOutput>>): IFunctionNodeDefinition<TInput, TOutput>;
+export declare function makeEventNodeDefinition<TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TConfig extends NodeConfigurationDescription, TState>(definition: OmitFactoryAndType<IEventNodeDefinition<TInput, TOutput, TConfig, TState>>): IEventNodeDefinition<TInput, TOutput, TConfig, TState>;
+export { NodeCategory } from './Registry/NodeCategory.js';
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js
new file mode 100644
index 0000000..6c8fa9b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js
@@ -0,0 +1,53 @@
+import { AsyncNodeInstance } from './AsyncNode.js';
+import { EventNodeInstance } from './EventNode.js';
+import { FlowNodeInstance } from './FlowNode.js';
+import { FunctionNodeInstance } from './FunctionNode.js';
+import { makeCommonProps } from './nodeFactory.js';
+import { NodeType } from './NodeInstance.js';
+// HELPER FUNCTIONS
+// helper function to not require you to define generics when creating a node def:
+export function makeFlowNodeDefinition(definition) {
+    return {
+        ...definition,
+        nodeFactory: (graph, config) => new FlowNodeInstance({
+            ...makeCommonProps(NodeType.Flow, definition, config, graph),
+            initialState: definition.initialState,
+            triggered: definition.triggered
+        })
+    };
+}
+export function makeAsyncNodeDefinition(definition) {
+    return {
+        ...definition,
+        nodeFactory: (graph, config) => new AsyncNodeInstance({
+            ...makeCommonProps(NodeType.Async, definition, config, graph),
+            initialState: definition.initialState,
+            triggered: definition.triggered,
+            dispose: definition.dispose
+        })
+    };
+}
+// helper function to not require you to define generics when creating a node def,
+// and generates a factory for a node instance
+export function makeFunctionNodeDefinition(definition) {
+    return {
+        ...definition,
+        nodeFactory: (graph, nodeConfig) => new FunctionNodeInstance({
+            ...makeCommonProps(NodeType.Function, definition, nodeConfig, graph),
+            exec: definition.exec
+        })
+    };
+}
+export function makeEventNodeDefinition(definition) {
+    return {
+        ...definition,
+        nodeFactory: (graph, config) => new EventNodeInstance({
+            ...makeCommonProps(NodeType.Event, definition, config, graph),
+            initialState: definition.initialState,
+            init: definition.init,
+            dispose: definition.dispose
+        })
+    };
+}
+export { NodeCategory } from './Registry/NodeCategory.js';
+//# sourceMappingURL=NodeDefinitions.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js.map b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js.map
new file mode 100644
index 0000000..846cf65
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeDefinitions.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeDefinitions.js","sourceRoot":"","sources":["../../src/Nodes/NodeDefinitions.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAE,iBAAiB,EAAE,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AACjD,OAAO,EAAE,oBAAoB,EAAE,MAAM,mBAAmB,CAAC;AAEzD,OAAO,EAAE,eAAe,EAAE,MAAM,kBAAkB,CAAC;AACnD,OAAO,EAAS,QAAQ,EAAE,MAAM,mBAAmB,CAAC;AA8KpD,mBAAmB;AAEnB,kFAAkF;AAClF,MAAM,UAAU,sBAAsB,CAMpC,UAEC;IAED,OAAO;QACL,GAAG,UAAU;QACb,WAAW,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAC7B,IAAI,gBAAgB,CAAC;YACnB,GAAG,eAAe,CAAC,QAAQ,CAAC,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC;YAC5D,YAAY,EAAE,UAAU,CAAC,YAAY;YACrC,SAAS,EAAE,UAAU,CAAC,SAAS;SAChC,CAAC;KACL,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,uBAAuB,CAMrC,UAEC;IAED,OAAO;QACL,GAAG,UAAU;QACb,WAAW,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAC7B,IAAI,iBAAiB,CAAC;YACpB,GAAG,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC;YAC7D,YAAY,EAAE,UAAU,CAAC,YAAY;YACrC,SAAS,EAAE,UAAU,CAAC,SAAS;YAC/B,OAAO,EAAE,UAAU,CAAC,OAAO;SAC5B,CAAC;KACL,CAAC;AACJ,CAAC;AAED,kFAAkF;AAClF,8CAA8C;AAC9C,MAAM,UAAU,0BAA0B,CAIxC,UAAwE;IAExE,OAAO;QACL,GAAG,UAAU;QACb,WAAW,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE,CACjC,IAAI,oBAAoB,CAAC;YACvB,GAAG,eAAe,CAAC,QAAQ,CAAC,QAAQ,EAAE,UAAU,EAAE,UAAU,EAAE,KAAK,CAAC;YACpE,IAAI,EAAE,UAAU,CAAC,IAAI;SACtB,CAAC;KACL,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,uBAAuB,CAMrC,UAEC;IAED,OAAO;QACL,GAAG,UAAU;QACb,WAAW,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAC7B,IAAI,iBAAiB,CAAC;YACpB,GAAG,eAAe,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC;YAC7D,YAAY,EAAE,UAAU,CAAC,YAAY;YACrC,IAAI,EAAE,UAAU,CAAC,IAAI;YACrB,OAAO,EAAE,UAAU,CAAC,OAAO;SAC5B,CAAC;KACL,CAAC;AACJ,CAAC;AAED,OAAO,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.d.ts b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.d.ts
new file mode 100644
index 0000000..cdc9474
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.d.ts
@@ -0,0 +1,56 @@
+import { Engine } from '../Execution/Engine.js';
+import { Fiber } from '../Execution/Fiber.js';
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { NodeConfiguration } from './Node.js';
+import { INodeDescription } from './Registry/NodeDescription.js';
+export declare enum NodeType {
+    Event = "Event",
+    Flow = "Flow",
+    Async = "Async",
+    Function = "Function"
+}
+export interface INode {
+    readonly inputs: Socket[];
+    readonly outputs: Socket[];
+    readonly graph: IGraph;
+    description: INodeDescription;
+    configuration: NodeConfiguration;
+    nodeType: NodeType;
+    label?: string;
+    metadata?: any;
+}
+export interface IFunctionNode extends INode {
+    nodeType: NodeType.Function;
+    exec: (node: INode) => void;
+}
+export interface IEventNode extends INode {
+    nodeType: NodeType.Event;
+    init: (engine: Engine) => void;
+    dispose: (engine: Engine) => void;
+}
+export interface IFlowNode extends INode {
+    nodeType: NodeType.Flow;
+    triggered: (fiber: Fiber, triggeringSocketName: string) => void;
+}
+export interface IAsyncNode extends INode {
+    nodeType: NodeType.Async;
+    triggered: (engine: Engine, triggeringSocketName: string, finished: () => void) => void;
+    dispose: () => void;
+}
+export declare const isFlowNode: (node: INode) => node is IFlowNode;
+export declare const isEventNode: (node: INode) => node is IEventNode;
+export declare const isAsyncNode: (node: INode) => node is IAsyncNode;
+export declare const isFunctionNode: (node: INode) => node is IFunctionNode;
+export declare const makeNodeInstance: (node: INode) => {
+    readInput: <T>(inputName: string) => T;
+    writeOutput: <T_1>(outputName: string, value: T_1) => void;
+    inputs: Socket[];
+    outputs: Socket[];
+    graph: IGraph;
+    description: INodeDescription;
+    configuration: NodeConfiguration;
+    nodeType: NodeType;
+    label?: string | undefined;
+    metadata?: any;
+};
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js
new file mode 100644
index 0000000..a57d01b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js
@@ -0,0 +1,26 @@
+import { readInputFromSockets, writeOutputsToSocket } from './NodeSockets.js';
+export var NodeType;
+(function (NodeType) {
+    NodeType["Event"] = "Event";
+    NodeType["Flow"] = "Flow";
+    NodeType["Async"] = "Async";
+    NodeType["Function"] = "Function";
+})(NodeType || (NodeType = {}));
+export const isFlowNode = (node) => node.nodeType === NodeType.Flow;
+export const isEventNode = (node) => node.nodeType === NodeType.Event;
+export const isAsyncNode = (node) => node.nodeType === NodeType.Async;
+export const isFunctionNode = (node) => node.nodeType === NodeType.Function;
+export const makeNodeInstance = (node) => {
+    const readInput = (inputName) => {
+        return readInputFromSockets(node.inputs, inputName, node.description.typeName);
+    };
+    const writeOutput = (outputName, value) => {
+        writeOutputsToSocket(node.outputs, outputName, value, node.description.typeName);
+    };
+    return {
+        ...node,
+        readInput,
+        writeOutput
+    };
+};
+//# sourceMappingURL=NodeInstance.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js.map b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js.map
new file mode 100644
index 0000000..c699674
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeInstance.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeInstance.js","sourceRoot":"","sources":["../../src/Nodes/NodeInstance.ts"],"names":[],"mappings":"AAKA,OAAO,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAG9E,MAAM,CAAN,IAAY,QAKX;AALD,WAAY,QAAQ;IAClB,2BAAe,CAAA;IACf,yBAAa,CAAA;IACb,2BAAe,CAAA;IACf,iCAAqB,CAAA;AACvB,CAAC,EALW,QAAQ,KAAR,QAAQ,QAKnB;AAuCD,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,IAAW,EAAqB,EAAE,CAC3D,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,IAAI,CAAC;AAElC,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,IAAW,EAAsB,EAAE,CAC7D,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,KAAK,CAAC;AAEnC,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,IAAW,EAAsB,EAAE,CAC7D,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,KAAK,CAAC;AAEnC,MAAM,CAAC,MAAM,cAAc,GAAG,CAAC,IAAW,EAAyB,EAAE,CACnE,IAAI,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,CAAC;AAEtC,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAAC,IAAW,EAAE,EAAE;IAC9C,MAAM,SAAS,GAAG,CAAI,SAAiB,EAAK,EAAE;QAC5C,OAAO,oBAAoB,CACzB,IAAI,CAAC,MAAM,EACX,SAAS,EACT,IAAI,CAAC,WAAW,CAAC,QAAQ,CAC1B,CAAC;IACJ,CAAC,CAAC;IAEF,MAAM,WAAW,GAAG,CAAI,UAAkB,EAAE,KAAQ,EAAE,EAAE;QACtD,oBAAoB,CAClB,IAAI,CAAC,OAAO,EACZ,UAAU,EACV,KAAK,EACL,IAAI,CAAC,WAAW,CAAC,QAAQ,CAC1B,CAAC;IACJ,CAAC,CAAC;IAEF,OAAO;QACL,GAAG,IAAI;QACP,SAAS;QACT,WAAW;KACZ,CAAC;AACJ,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.d.ts b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.d.ts
new file mode 100644
index 0000000..34260aa
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.d.ts
@@ -0,0 +1,3 @@
+import { Socket } from '../Sockets/Socket.js';
+export declare const readInputFromSockets: <T>(inputs: Socket[], inputName: string, nodeTypeName: string) => T;
+export declare const writeOutputsToSocket: <T>(outputs: Socket[], outputName: string, value: T, nodeTypeName: string) => void;
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js
new file mode 100644
index 0000000..629e282
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js
@@ -0,0 +1,15 @@
+export const readInputFromSockets = (inputs, inputName, nodeTypeName) => {
+    const inputSocket = inputs.find((socket) => socket.name === inputName);
+    if (inputSocket === undefined) {
+        throw new Error(`can not find input socket with name ${inputName} on node of type ${nodeTypeName}`);
+    }
+    return inputSocket.value;
+};
+export const writeOutputsToSocket = (outputs, outputName, value, nodeTypeName) => {
+    const outputSocket = outputs.find((socket) => socket.name === outputName);
+    if (outputSocket === undefined) {
+        throw new Error(`can not find output socket with name ${outputName} on node of type ${nodeTypeName}`);
+    }
+    outputSocket.value = value;
+};
+//# sourceMappingURL=NodeSockets.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js.map b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js.map
new file mode 100644
index 0000000..5ce3c41
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/NodeSockets.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeSockets.js","sourceRoot":"","sources":["../../src/Nodes/NodeSockets.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,MAAgB,EAChB,SAAiB,EACjB,YAAoB,EACpB,EAAE;IACF,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC;IACvE,IAAI,WAAW,KAAK,SAAS,EAAE;QAC7B,MAAM,IAAI,KAAK,CACb,uCAAuC,SAAS,oBAAoB,YAAY,EAAE,CACnF,CAAC;KACH;IACD,OAAO,WAAW,CAAC,KAAU,CAAC;AAChC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,OAAiB,EACjB,UAAkB,EAClB,KAAQ,EACR,YAAoB,EACpB,EAAE;IACF,MAAM,YAAY,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC;IAC1E,IAAI,YAAY,KAAK,SAAS,EAAE;QAC9B,MAAM,IAAI,KAAK,CACb,wCAAwC,UAAU,oBAAoB,YAAY,EAAE,CACrF,CAAC;KACH;IACD,YAAY,CAAC,KAAK,GAAG,KAAK,CAAC;AAC7B,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.d.ts
new file mode 100644
index 0000000..c4d198f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.d.ts
@@ -0,0 +1,4 @@
+export type Dependencies = Record<string, any>;
+export declare const registerDependency: (dependencies: Dependencies, key: string, dependency: any) => {
+    [x: string]: any;
+};
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js
new file mode 100644
index 0000000..6fd13f5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js
@@ -0,0 +1,5 @@
+export const registerDependency = (dependencies, key, dependency) => ({
+    ...dependencies,
+    [key]: dependency
+});
+//# sourceMappingURL=DependenciesRegistry.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js.map b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js.map
new file mode 100644
index 0000000..9ae9d20
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/DependenciesRegistry.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DependenciesRegistry.js","sourceRoot":"","sources":["../../../src/Nodes/Registry/DependenciesRegistry.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAChC,YAA0B,EAC1B,GAAW,EACX,UAAe,EACf,EAAE,CAAC,CAAC;IACJ,GAAG,YAAY;IACf,CAAC,GAAG,CAAC,EAAE,UAAU;CAClB,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.d.ts
new file mode 100644
index 0000000..a051dcc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.d.ts
@@ -0,0 +1,11 @@
+export declare enum NodeCategory {
+    Action = "Action",
+    Query = "Query",
+    Logic = "Logic",
+    Event = "Event",
+    Variable = "Variable",
+    Flow = "Flow",
+    Time = "Time",
+    None = "None",
+    Effect = "Effect"
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js
new file mode 100644
index 0000000..91229a0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js
@@ -0,0 +1,13 @@
+export var NodeCategory;
+(function (NodeCategory) {
+    NodeCategory["Action"] = "Action";
+    NodeCategory["Query"] = "Query";
+    NodeCategory["Logic"] = "Logic";
+    NodeCategory["Event"] = "Event";
+    NodeCategory["Variable"] = "Variable";
+    NodeCategory["Flow"] = "Flow";
+    NodeCategory["Time"] = "Time";
+    NodeCategory["None"] = "None";
+    NodeCategory["Effect"] = "Effect";
+})(NodeCategory || (NodeCategory = {}));
+//# sourceMappingURL=NodeCategory.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js.map b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js.map
new file mode 100644
index 0000000..5e15c8f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeCategory.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeCategory.js","sourceRoot":"","sources":["../../../src/Nodes/Registry/NodeCategory.ts"],"names":[],"mappings":"AAAA,MAAM,CAAN,IAAY,YAUX;AAVD,WAAY,YAAY;IACtB,iCAAiB,CAAA;IACjB,+BAAe,CAAA;IACf,+BAAe,CAAA;IACf,+BAAe,CAAA;IACf,qCAAqB,CAAA;IACrB,6BAAa,CAAA;IACb,6BAAa,CAAA;IACb,6BAAa,CAAA;IACb,iCAAiB,CAAA;AACnB,CAAC,EAVW,YAAY,KAAZ,YAAY,QAUvB"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.d.ts
new file mode 100644
index 0000000..147b366
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.d.ts
@@ -0,0 +1,5 @@
+import { IHasNodeFactory, INodeDefinition } from '../NodeDefinitions.js';
+export type NodeDefinition = IHasNodeFactory & Pick<INodeDefinition, 'typeName' | 'otherTypeNames'>;
+export type NodeDefinitionsMap = {
+    readonly [type: string]: NodeDefinition;
+};
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js
new file mode 100644
index 0000000..2441299
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=NodeDefinitionsMap.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js.map b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js.map
new file mode 100644
index 0000000..edc53d2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDefinitionsMap.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeDefinitionsMap.js","sourceRoot":"","sources":["../../../src/Nodes/Registry/NodeDefinitionsMap.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.d.ts
new file mode 100644
index 0000000..9141582
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.d.ts
@@ -0,0 +1,53 @@
+import { IGraph } from '../../Graphs/Graph.js';
+import { IHasNodeFactory, INodeDefinition, NodeFactory } from '../NodeDefinitions.js';
+import { INode } from '../NodeInstance.js';
+import { NodeConfiguration } from './../Node.js';
+import { NodeCategory } from './NodeCategory.js';
+export type NodeConfigurationDescription = {
+    [key: string]: {
+        valueType: string;
+        defaultValue?: any;
+    };
+};
+export declare function getNodeDescriptions(importWildcard: {
+    [key: string]: INodeDefinition;
+}): INodeDefinition[];
+export interface INodeDescription {
+    readonly typeName: string;
+    readonly category: NodeCategory | string;
+    readonly label: string;
+    readonly otherTypeNames: string[];
+    readonly helpDescription: string;
+    readonly configuration: NodeConfigurationDescription;
+}
+export type NodeFactoryWithDescription = (entry: NodeDescription, graph: IGraph, config: NodeConfiguration) => INode;
+export declare class NodeDescription implements INodeDescription, IHasNodeFactory {
+    readonly typeName: string;
+    readonly category: NodeCategory | string;
+    readonly label: string;
+    readonly otherTypeNames: string[];
+    readonly helpDescription: string;
+    readonly configuration: NodeConfigurationDescription;
+    nodeFactory: NodeFactory;
+    constructor(typeName: string, category: NodeCategory | string, label: string, factory: NodeFactoryWithDescription, otherTypeNames?: string[], helpDescription?: string, configuration?: NodeConfigurationDescription);
+}
+export declare class NodeDescription2 extends NodeDescription {
+    properties: {
+        typeName: string;
+        category: NodeCategory | string;
+        label?: string;
+        configuration?: NodeConfigurationDescription;
+        factory: NodeFactoryWithDescription;
+        otherTypeNames?: string[];
+        helpDescription?: string;
+    };
+    constructor(properties: {
+        typeName: string;
+        category: NodeCategory | string;
+        label?: string;
+        configuration?: NodeConfigurationDescription;
+        factory: NodeFactoryWithDescription;
+        otherTypeNames?: string[];
+        helpDescription?: string;
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js
new file mode 100644
index 0000000..6e6e983
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js
@@ -0,0 +1,21 @@
+export function getNodeDescriptions(importWildcard) {
+    return Object.values(importWildcard);
+}
+export class NodeDescription {
+    constructor(typeName, category, label = '', factory, otherTypeNames = [], helpDescription = '', configuration = {}) {
+        this.typeName = typeName;
+        this.category = category;
+        this.label = label;
+        this.otherTypeNames = otherTypeNames;
+        this.helpDescription = helpDescription;
+        this.configuration = configuration;
+        this.nodeFactory = (graph, config) => factory(this, graph, config);
+    }
+}
+export class NodeDescription2 extends NodeDescription {
+    constructor(properties) {
+        super(properties.typeName, properties.category, properties.label, properties.factory, properties.otherTypeNames, properties.helpDescription, properties.configuration);
+        this.properties = properties;
+    }
+}
+//# sourceMappingURL=NodeDescription.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js.map b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js.map
new file mode 100644
index 0000000..f68013d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Registry/NodeDescription.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"NodeDescription.js","sourceRoot":"","sources":["../../../src/Nodes/Registry/NodeDescription.ts"],"names":[],"mappings":"AAiBA,MAAM,UAAU,mBAAmB,CAAC,cAEnC;IACC,OAAO,MAAM,CAAC,MAAM,CAAC,cAAc,CAAsB,CAAC;AAC5D,CAAC;AAiBD,MAAM,OAAO,eAAe;IAG1B,YACkB,QAAgB,EAChB,QAA+B,EAC/B,QAAgB,EAAE,EAClC,OAAmC,EACnB,iBAA2B,EAAE,EAC7B,kBAA0B,EAAE,EAE5B,gBAA8C,EAAE;QAPhD,aAAQ,GAAR,QAAQ,CAAQ;QAChB,aAAQ,GAAR,QAAQ,CAAuB;QAC/B,UAAK,GAAL,KAAK,CAAa;QAElB,mBAAc,GAAd,cAAc,CAAe;QAC7B,oBAAe,GAAf,eAAe,CAAa;QAE5B,kBAAa,GAAb,aAAa,CAAmC;QAEhE,IAAI,CAAC,WAAW,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;IACrE,CAAC;CACF;AAED,MAAM,OAAO,gBAAiB,SAAQ,eAAe;IACnD,YACS,UAQN;QAED,KAAK,CACH,UAAU,CAAC,QAAQ,EACnB,UAAU,CAAC,QAAQ,EACnB,UAAU,CAAC,KAAK,EAChB,UAAU,CAAC,OAAO,EAClB,UAAU,CAAC,cAAc,EACzB,UAAU,CAAC,eAAe,EAC1B,UAAU,CAAC,aAAa,CACzB,CAAC;QAlBK,eAAU,GAAV,UAAU,CAQhB;IAWH,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.d.ts b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.d.ts
new file mode 100644
index 0000000..819c394
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.d.ts
@@ -0,0 +1,2 @@
+import { IRegistry } from '../../Registry.js';
+export declare function validateNodeRegistry(registry: IRegistry): string[];
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js
new file mode 100644
index 0000000..21b4454
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js
@@ -0,0 +1,50 @@
+import { createNode, makeGraphApi } from '../../Graphs/Graph.js';
+const nodeTypeNameRegex = /^\w+(\/\w+)*$/;
+const socketNameRegex = /^\w+$/;
+export function validateNodeRegistry(registry) {
+    const errorList = [];
+    // const graph = new Graph(registry);
+    const graph = makeGraphApi({
+        ...registry
+    });
+    Object.keys(registry.nodes).forEach((nodeTypeName) => {
+        const node = createNode({ graph, registry, nodeTypeName });
+        // ensure node is registered correctly.
+        if (node.description.typeName !== nodeTypeName) {
+            if (!node.description.otherTypeNames?.includes(nodeTypeName)) {
+                errorList.push(`node with typeName '${node.description.typeName}' is registered under a different name '${nodeTypeName}'`);
+            }
+        }
+        if (!nodeTypeNameRegex.test(node.description.typeName)) {
+            errorList.push(`invalid node type name on node ${node.description.typeName}`);
+        }
+        node.inputs.forEach((socket) => {
+            if (!socketNameRegex.test(socket.name)) {
+                errorList.push(`invalid socket name for input socket ${socket.name} on node ${node.description.typeName}`);
+            }
+            if (socket.valueTypeName === 'flow') {
+                return;
+            }
+            const valueType = registry.values[socket.valueTypeName];
+            // check to ensure all value types are supported.
+            if (valueType === undefined) {
+                errorList.push(`node '${node.description.typeName}' has on input socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+            }
+        });
+        node.outputs.forEach((socket) => {
+            if (!socketNameRegex.test(socket.name)) {
+                errorList.push(`invalid socket name for output socket ${socket.name} on node ${node.description.typeName}`);
+            }
+            if (socket.valueTypeName === 'flow') {
+                return;
+            }
+            const valueType = registry.values[socket.valueTypeName];
+            // check to ensure all value types are supported.
+            if (valueType === undefined) {
+                errorList.push(`node '${node.description.typeName}' has on output socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+            }
+        });
+    });
+    return errorList;
+}
+//# sourceMappingURL=validateNodeRegistry.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js.map b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js.map
new file mode 100644
index 0000000..8839664
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/Validation/validateNodeRegistry.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateNodeRegistry.js","sourceRoot":"","sources":["../../../src/Nodes/Validation/validateNodeRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,MAAM,uBAAuB,CAAC;AAGjE,MAAM,iBAAiB,GAAG,eAAe,CAAC;AAC1C,MAAM,eAAe,GAAG,OAAO,CAAC;AAEhC,MAAM,UAAU,oBAAoB,CAAC,QAAmB;IACtD,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,qCAAqC;IACrC,MAAM,KAAK,GAAG,YAAY,CAAC;QACzB,GAAG,QAAQ;KACZ,CAAC,CAAC;IACH,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,EAAE;QACnD,MAAM,IAAI,GAAG,UAAU,CAAC,EAAE,KAAK,EAAE,QAAQ,EAAE,YAAY,EAAE,CAAC,CAAC;QAE3D,uCAAuC;QACvC,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,KAAK,YAAY,EAAE;YAC9C,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,QAAQ,CAAC,YAAY,CAAC,EAAE;gBAC5D,SAAS,CAAC,IAAI,CACZ,uBAAuB,IAAI,CAAC,WAAW,CAAC,QAAQ,2CAA2C,YAAY,GAAG,CAC3G,CAAC;aACH;SACF;QAED,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;YACtD,SAAS,CAAC,IAAI,CACZ,kCAAkC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAC9D,CAAC;SACH;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAC7B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;gBACtC,SAAS,CAAC,IAAI,CACZ,wCAAwC,MAAM,CAAC,IAAI,YAAY,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAC3F,CAAC;aACH;YAED,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,EAAE;gBACnC,OAAO;aACR;YACD,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YACxD,iDAAiD;YACjD,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,SAAS,CAAC,IAAI,CACZ,SAAS,IAAI,CAAC,WAAW,CAAC,QAAQ,0BAA0B,MAAM,CAAC,IAAI,iCAAiC,MAAM,CAAC,aAAa,GAAG,CAChI,CAAC;aACH;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAC9B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;gBACtC,SAAS,CAAC,IAAI,CACZ,yCAAyC,MAAM,CAAC,IAAI,YAAY,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,CAC5F,CAAC;aACH;YACD,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,EAAE;gBACnC,OAAO;aACR;YACD,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YACxD,iDAAiD;YACjD,IAAI,SAAS,KAAK,SAAS,EAAE;gBAC3B,SAAS,CAAC,IAAI,CACZ,SAAS,IAAI,CAAC,WAAW,CAAC,QAAQ,2BAA2B,MAAM,CAAC,IAAI,iCAAiC,MAAM,CAAC,aAAa,GAAG,CACjI,CAAC;aACH;QACH,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IACH,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.d.ts b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.d.ts
new file mode 100644
index 0000000..a27f1c7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.d.ts
@@ -0,0 +1,7 @@
+import { IGraph } from '../Graphs/Graph.js';
+import { Socket } from '../Sockets/Socket.js';
+import { NodeConfiguration } from './Node.js';
+import { INodeDefinition, SocketsDefinition } from './NodeDefinitions.js';
+import { INode, NodeType } from './NodeInstance.js';
+export declare function makeOrGenerateSockets(socketConfigOrFactory: SocketsDefinition, nodeConfig: NodeConfiguration, graph: IGraph): Socket[];
+export declare const makeCommonProps: (nodeType: NodeType, { typeName, in: inputs, out, otherTypeNames, category, configuration: nodeDefinitionConfiguration, helpDescription, label }: Pick<INodeDefinition, 'typeName' | 'in' | 'out' | 'otherTypeNames' | 'category' | 'configuration' | 'helpDescription' | 'label'>, configuration: NodeConfiguration, graph: IGraph) => INode;
diff --git a/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js
new file mode 100644
index 0000000..d867a0a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js
@@ -0,0 +1,44 @@
+import { Socket } from '../Sockets/Socket.js';
+import { NodeCategory } from './NodeDefinitions.js';
+const makeSocketFromDefinition = (key, { valueType, defaultValue, choices }) => new Socket(valueType, key, defaultValue, undefined, choices);
+const makeSocketsFromMap = (socketConfig, keys, configuration, graphApi) => {
+    return keys.map((key) => {
+        const definition = socketConfig[key];
+        if (typeof definition === 'string') {
+            return new Socket(definition, key);
+        }
+        if (typeof definition === 'function') {
+            const socketDef = definition(configuration, graphApi);
+            return makeSocketFromDefinition(key, socketDef);
+        }
+        return makeSocketFromDefinition(key, definition);
+    });
+};
+const makeSocketsFromArray = (sockets) => sockets.map((socket) => {
+    return new Socket(socket.valueType, socket.key, socket.defaultValue, undefined, socket.choices);
+});
+export function makeOrGenerateSockets(socketConfigOrFactory, nodeConfig, graph) {
+    // if sockets definition is dynamic, then use the node config to generate it;
+    // otherwise, use the static definition
+    if (typeof socketConfigOrFactory === 'function') {
+        const socketsConfig = socketConfigOrFactory(nodeConfig, graph);
+        return makeSocketsFromArray(socketsConfig);
+    }
+    return makeSocketsFromMap(socketConfigOrFactory, Object.keys(socketConfigOrFactory), nodeConfig, graph);
+}
+export const makeCommonProps = (nodeType, { typeName, in: inputs, out, otherTypeNames = [], category = NodeCategory.None, configuration: nodeDefinitionConfiguration, helpDescription = '', label = '' }, configuration, graph) => ({
+    description: {
+        typeName: typeName,
+        configuration: nodeDefinitionConfiguration || {},
+        category,
+        otherTypeNames,
+        helpDescription,
+        label
+    },
+    nodeType: nodeType,
+    inputs: makeOrGenerateSockets(inputs, configuration, graph),
+    outputs: makeOrGenerateSockets(out, configuration, graph),
+    configuration,
+    graph
+});
+//# sourceMappingURL=nodeFactory.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js.map b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js.map
new file mode 100644
index 0000000..b287d84
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/nodeFactory.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"nodeFactory.js","sourceRoot":"","sources":["../../src/Nodes/nodeFactory.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAE9C,OAAO,EAEL,YAAY,EAKb,MAAM,sBAAsB,CAAC;AAG9B,MAAM,wBAAwB,GAAG,CAC/B,GAAW,EACX,EAAE,SAAS,EAAE,YAAY,EAAE,OAAO,EAAoB,EACtD,EAAE,CAAC,IAAI,MAAM,CAAC,SAAS,EAAE,GAAa,EAAE,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;AAE5E,MAAM,kBAAkB,GAAG,CACzB,YAAsB,EACtB,IAAwB,EACxB,aAAgC,EAChC,QAAgB,EACN,EAAE;IACZ,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;QACtB,MAAM,UAAU,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;QACrC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;YAClC,OAAO,IAAI,MAAM,CAAC,UAAU,EAAE,GAAa,CAAC,CAAC;SAC9C;QACD,IAAI,OAAO,UAAU,KAAK,UAAU,EAAE;YACpC,MAAM,SAAS,GAAG,UAAU,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;YAEtD,OAAO,wBAAwB,CAAC,GAAa,EAAE,SAAS,CAAC,CAAC;SAC3D;QACD,OAAO,wBAAwB,CAAC,GAAa,EAAE,UAAU,CAAC,CAAC;IAC7D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF,MAAM,oBAAoB,GAAG,CAAC,OAAoB,EAAE,EAAE,CACpD,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE;IACrB,OAAO,IAAI,MAAM,CACf,MAAM,CAAC,SAAS,EAChB,MAAM,CAAC,GAAG,EACV,MAAM,CAAC,YAAY,EACnB,SAAS,EACT,MAAM,CAAC,OAAO,CACf,CAAC;AACJ,CAAC,CAAC,CAAC;AAEL,MAAM,UAAU,qBAAqB,CACnC,qBAAwC,EACxC,UAA6B,EAC7B,KAAa;IAEb,6EAA6E;IAC7E,uCAAuC;IACvC,IAAI,OAAO,qBAAqB,KAAK,UAAU,EAAE;QAC/C,MAAM,aAAa,GAAG,qBAAqB,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;QAE/D,OAAO,oBAAoB,CAAC,aAAa,CAAC,CAAC;KAC5C;IAED,OAAO,kBAAkB,CACvB,qBAAqB,EACrB,MAAM,CAAC,IAAI,CAAC,qBAAqB,CAAC,EAClC,UAAU,EACV,KAAK,CACN,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,MAAM,eAAe,GAAG,CAC7B,QAAkB,EAClB,EACE,QAAQ,EACR,EAAE,EAAE,MAAM,EACV,GAAG,EACH,cAAc,GAAG,EAAE,EACnB,QAAQ,GAAG,YAAY,CAAC,IAAI,EAC5B,aAAa,EAAE,2BAA2B,EAC1C,eAAe,GAAG,EAAE,EACpB,KAAK,GAAG,EAAE,EAWX,EACD,aAAgC,EAChC,KAAa,EACN,EAAE,CAAC,CAAC;IACX,WAAW,EAAE;QACX,QAAQ,EAAE,QAAQ;QAClB,aAAa,EAAE,2BAA2B,IAAI,EAAE;QAChD,QAAQ;QACR,cAAc;QACd,eAAe;QACf,KAAK;KACN;IACD,QAAQ,EAAE,QAAQ;IAClB,MAAM,EAAE,qBAAqB,CAAC,MAAM,EAAE,aAAa,EAAE,KAAK,CAAC;IAC3D,OAAO,EAAE,qBAAqB,CAAC,GAAG,EAAE,aAAa,EAAE,KAAK,CAAC;IACzD,aAAa;IACb,KAAK;CACN,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/testUtils.d.ts b/node_modules/@behave-graph/core/dist/Nodes/testUtils.d.ts
new file mode 100644
index 0000000..f42af32
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/testUtils.d.ts
@@ -0,0 +1,50 @@
+import { IGraph } from '../Graphs/Graph.js';
+import { NodeConfiguration } from './Node.js';
+import { IFunctionNodeDefinition, IHasTriggered, SocketNames, SocketsDefinition } from './NodeDefinitions.js';
+import { NodeConfigurationDescription } from './Registry/NodeDescription.js';
+export type SocketValues<TSockets extends SocketsDefinition> = {
+    [key in SocketNames<TSockets>]?: any;
+};
+/** Helper function to test an function node's exec and get the resulting outputs.
+ * Can simulate the input socket values. Returns the output socket values
+ */
+export declare const testExec: <TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TConfig extends NodeConfigurationDescription>({ nodeInputVals, configuration, exec, makeGraph }: {
+    /** Exec function from the node defintion */
+    exec: (params: import("./NodeDefinitions.js").FunctionNodeExecParams<TInput, TOutput>) => void;
+    /** Runtime configuration of the node */
+    configuration?: NodeConfiguration | undefined;
+    /** Simulated input values the input sockets have */
+    nodeInputVals?: SocketValues<TInput> | undefined;
+    makeGraph?: (() => IGraph) | undefined;
+}) => SocketValues<TOutput>;
+export declare enum RecordedOutputType {
+    write = "write",
+    commit = "commit"
+}
+export type RecordedWritesOrCommits<TOutput extends SocketsDefinition> = ({
+    outputType: RecordedOutputType.write;
+    socketName: SocketNames<TOutput>;
+    value: any;
+} | {
+    outputType: RecordedOutputType.commit;
+    socketName: SocketNames<TOutput>;
+})[];
+/**
+ * Generates a function that can be used to test the triggered function of a node.
+ * The trigger function will maintain state between each invokation, and returns a list
+ * the recorded outputs, including the commits to flow outputs.
+ * @returns
+ */
+export declare const generateTriggerTester: <TInput extends SocketsDefinition, TOutput extends SocketsDefinition, TState>({ triggered, initialState, out }: {
+    /** Triggered function from the node defintion */
+    /** Runtime configuration of the node */
+    configuration?: NodeConfiguration | undefined;
+    makeGraph?: (() => IGraph) | undefined;
+} & Pick<IHasTriggered<TInput, TOutput, TState>, "triggered" | "initialState"> & {
+    out: TOutput;
+}, configuration?: NodeConfiguration, makeGraph?: () => IGraph) => ({ inputVals, triggeringSocketName }: {
+    /** input values to simulate on the input sockets */
+    inputVals?: SocketValues<TInput> | undefined;
+    /** name of the flow socket that is to be triggered */
+    triggeringSocketName: SocketNames<TInput>;
+}) => RecordedWritesOrCommits<TOutput>;
diff --git a/node_modules/@behave-graph/core/dist/Nodes/testUtils.js b/node_modules/@behave-graph/core/dist/Nodes/testUtils.js
new file mode 100644
index 0000000..546144c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/testUtils.js
@@ -0,0 +1,85 @@
+import { makeGraphApi } from '../Graphs/Graph.js';
+import { makeOrGenerateSockets } from './nodeFactory.js';
+const makeEmptyGraph = () => {
+    return makeGraphApi({
+        dependencies: {},
+        values: {}
+    });
+};
+/** Helper function to test an function node's exec and get the resulting outputs.
+ * Can simulate the input socket values. Returns the output socket values
+ */
+export const testExec = ({ nodeInputVals = {}, configuration = {}, exec, makeGraph = makeEmptyGraph }) => {
+    const outputs = {};
+    exec({
+        read: (socketName) => nodeInputVals[socketName],
+        write: (outputValueName, value) => {
+            outputs[outputValueName] = value;
+        },
+        configuration,
+        graph: makeGraph()
+    });
+    return outputs;
+};
+export var RecordedOutputType;
+(function (RecordedOutputType) {
+    RecordedOutputType["write"] = "write";
+    RecordedOutputType["commit"] = "commit";
+})(RecordedOutputType || (RecordedOutputType = {}));
+/**
+ * Generates a function that can be used to test the triggered function of a node.
+ * The trigger function will maintain state between each invokation, and returns a list
+ * the recorded outputs, including the commits to flow outputs.
+ * @returns
+ */
+export const generateTriggerTester = ({ triggered, initialState, out }, configuration = {}, makeGraph = makeEmptyGraph) => {
+    let state = initialState;
+    const graph = makeGraph();
+    const outputSocketKeys = getOutputSocketKeys({
+        outputs: out,
+        config: configuration,
+        graph
+    });
+    /** Triggers the `triggered` function, and updates internal state. Returns a
+     * list of the recorded outputs, including the commits to flow outputs.
+     */
+    const trigger = ({ inputVals = {}, triggeringSocketName }) => {
+        const recordedOutputs = [];
+        // call the triggered function with the current state and
+        // simulated input vals, and udpate the state with the result.
+        state = triggered({
+            triggeringSocketName,
+            read: (socketName) => inputVals[socketName],
+            write: (outputValueName, value) => {
+                recordedOutputs.push({
+                    outputType: RecordedOutputType.write,
+                    socketName: outputValueName,
+                    value: value
+                });
+            },
+            commit: (outputFlowName, fiberCompletedListener) => {
+                recordedOutputs.push({
+                    outputType: RecordedOutputType.commit,
+                    socketName: outputFlowName
+                });
+                if (fiberCompletedListener) {
+                    fiberCompletedListener();
+                }
+            },
+            configuration,
+            graph,
+            state: state,
+            finished: () => {
+                return;
+            },
+            outputSocketKeys
+        });
+        return recordedOutputs;
+    };
+    return trigger;
+};
+function getOutputSocketKeys({ outputs, config, graph }) {
+    const sockets = makeOrGenerateSockets(outputs, config, graph);
+    return sockets.map((x) => x.name);
+}
+//# sourceMappingURL=testUtils.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Nodes/testUtils.js.map b/node_modules/@behave-graph/core/dist/Nodes/testUtils.js.map
new file mode 100644
index 0000000..709ed3b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Nodes/testUtils.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"testUtils.js","sourceRoot":"","sources":["../../src/Nodes/testUtils.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts
new file mode 100644
index 0000000..4c8480e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts
@@ -0,0 +1,4 @@
+import { ILogger, LogSeverity } from '../ILogger.js';
+export declare class DefaultLogger implements ILogger {
+    log(severity: LogSeverity, text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js
new file mode 100644
index 0000000..282b5f7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js
@@ -0,0 +1,8 @@
+/* eslint-disable class-methods-use-this */
+import { Logger } from '../../../../Diagnostics/Logger.js';
+export class DefaultLogger {
+    log(severity, text) {
+        Logger.log(severity, text);
+    }
+}
+//# sourceMappingURL=DefaultLogger.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js.map
new file mode 100644
index 0000000..c6bcb20
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/DefaultLogger.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DefaultLogger.js","sourceRoot":"","sources":["../../../../../src/Profiles/Core/Abstractions/Drivers/DefaultLogger.ts"],"names":[],"mappings":"AAAA,2CAA2C;AAC3C,OAAO,EAAE,MAAM,EAAE,MAAM,mCAAmC,CAAC;AAG3D,MAAM,OAAO,aAAa;IACxB,GAAG,CAAC,QAAqB,EAAE,IAAY;QACrC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC7B,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts
new file mode 100644
index 0000000..1a48866
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts
@@ -0,0 +1,7 @@
+import { EventEmitter } from '../../../../Events/EventEmitter.js';
+import { ILifecycleEventEmitter } from '../ILifecycleEventEmitter.js';
+export declare class ManualLifecycleEventEmitter implements ILifecycleEventEmitter {
+    readonly startEvent: EventEmitter<void>;
+    readonly endEvent: EventEmitter<void>;
+    readonly tickEvent: EventEmitter<void>;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js
new file mode 100644
index 0000000..f981e33
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js
@@ -0,0 +1,9 @@
+import { EventEmitter } from '../../../../Events/EventEmitter.js';
+export class ManualLifecycleEventEmitter {
+    constructor() {
+        this.startEvent = new EventEmitter();
+        this.endEvent = new EventEmitter();
+        this.tickEvent = new EventEmitter();
+    }
+}
+//# sourceMappingURL=ManualLifecycleEventEmitter.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js.map
new file mode 100644
index 0000000..e1a5900
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ManualLifecycleEventEmitter.js","sourceRoot":"","sources":["../../../../../src/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,oCAAoC,CAAC;AAGlE,MAAM,OAAO,2BAA2B;IAAxC;QACkB,eAAU,GAAG,IAAI,YAAY,EAAQ,CAAC;QACtC,aAAQ,GAAG,IAAI,YAAY,EAAQ,CAAC;QACpC,cAAS,GAAG,IAAI,YAAY,EAAQ,CAAC;IACvD,CAAC;CAAA"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts
new file mode 100644
index 0000000..fc77907
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts
@@ -0,0 +1,6 @@
+import { EventEmitter } from '../../../Events/EventEmitter.js';
+export interface ILifecycleEventEmitter {
+    startEvent: EventEmitter<void>;
+    endEvent: EventEmitter<void>;
+    tickEvent: EventEmitter<void>;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js
new file mode 100644
index 0000000..3061f1c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=ILifecycleEventEmitter.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js.map
new file mode 100644
index 0000000..b5d8813
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILifecycleEventEmitter.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ILifecycleEventEmitter.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Abstractions/ILifecycleEventEmitter.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.d.ts
new file mode 100644
index 0000000..d346c4e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.d.ts
@@ -0,0 +1,4 @@
+export type LogSeverity = 'verbose' | 'info' | 'warning' | 'error';
+export interface ILogger {
+    log(severity: LogSeverity, text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js
new file mode 100644
index 0000000..7804f55
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=ILogger.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js.map
new file mode 100644
index 0000000..9368984
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Abstractions/ILogger.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ILogger.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Abstractions/ILogger.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.d.ts
new file mode 100644
index 0000000..c5d8210
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.d.ts
@@ -0,0 +1,13 @@
+import { Engine } from '../../../Execution/Engine.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { EventNode2 } from '../../../Nodes/EventNode.js';
+import { NodeConfiguration } from '../../../Nodes/Node.js';
+import { NodeDescription, NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class OnCustomEvent extends EventNode2 {
+    static Description: NodeDescription2;
+    private readonly customEvent;
+    constructor(description: NodeDescription, graph: IGraph, configuration: NodeConfiguration);
+    private onCustomEvent;
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js
new file mode 100644
index 0000000..a9cd1a2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js
@@ -0,0 +1,56 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { CustomEvent } from '../../../Events/CustomEvent.js';
+import { EventNode2 } from '../../../Nodes/EventNode.js';
+import { NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+class OnCustomEvent extends EventNode2 {
+    constructor(description, graph, configuration) {
+        const customEvent = graph.customEvents[configuration.customEventId] ||
+            new CustomEvent('-1', 'undefined');
+        super({
+            description,
+            graph,
+            outputs: [
+                new Socket('flow', 'flow'),
+                ...customEvent.parameters.map((parameter) => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))
+            ],
+            configuration
+        });
+        this.onCustomEvent = undefined;
+        this.customEvent = customEvent;
+        graph.customEvents[configuration.customEventId] = customEvent;
+    }
+    init(engine) {
+        Assert.mustBeTrue(this.onCustomEvent === undefined);
+        this.onCustomEvent = (parameters) => {
+            this.customEvent.parameters.forEach((parameterSocket) => {
+                if (!(parameterSocket.name in parameters)) {
+                    throw new Error(`parameters of custom event do not align with parameters of custom event node, missing ${parameterSocket.name}`);
+                }
+                this.writeOutput(parameterSocket.name, parameters[parameterSocket.name]);
+            });
+            engine.commitToNewFiber(this, 'flow');
+        };
+        this.customEvent.eventEmitter.addListener(this.onCustomEvent);
+    }
+    dispose(engine) {
+        Assert.mustBeTrue(this.onCustomEvent !== undefined);
+        if (this.onCustomEvent !== undefined) {
+            this.customEvent.eventEmitter.removeListener(this.onCustomEvent);
+        }
+    }
+}
+OnCustomEvent.Description = new NodeDescription2({
+    typeName: 'customEvent/onTriggered',
+    category: 'Event',
+    label: 'On Triggered',
+    configuration: {
+        customEventId: {
+            valueType: 'string',
+            defaultValue: '-1'
+        }
+    },
+    factory: (description, graph, configuration) => new OnCustomEvent(description, graph, configuration)
+});
+export { OnCustomEvent };
+//# sourceMappingURL=OnCustomEvent.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js.map
new file mode 100644
index 0000000..5ced5c2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/OnCustomEvent.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"OnCustomEvent.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/CustomEvents/OnCustomEvent.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AACxD,OAAO,EAAE,WAAW,EAAE,MAAM,gCAAgC,CAAC;AAG7D,OAAO,EAAE,UAAU,EAAE,MAAM,6BAA6B,CAAC;AAEzD,OAAO,EAEL,gBAAgB,EACjB,MAAM,4CAA4C,CAAC;AACpD,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,MAAa,aAAc,SAAQ,UAAU;IAiB3C,YACE,WAA4B,EAC5B,KAAa,EACb,aAAgC;QAEhC,MAAM,WAAW,GACf,KAAK,CAAC,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC;YAC/C,IAAI,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;QACrC,KAAK,CAAC;YACJ,WAAW;YACX,KAAK;YACL,OAAO,EAAE;gBACP,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;gBAC1B,GAAG,WAAW,CAAC,UAAU,CAAC,GAAG,CAC3B,CAAC,SAAS,EAAE,EAAE,CACZ,IAAI,MAAM,CACR,SAAS,CAAC,aAAa,EACvB,SAAS,CAAC,IAAI,EACd,SAAS,CAAC,KAAK,EACf,SAAS,CAAC,KAAK,CAChB,CACJ;aACF;YACD,aAAa;SACd,CAAC,CAAC;QAIG,kBAAa,GAEL,SAAS,CAAC;QALxB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,KAAK,CAAC,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,WAAW,CAAC;IAChE,CAAC;IAKD,IAAI,CAAC,MAAc;QACjB,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC;QAEpD,IAAI,CAAC,aAAa,GAAG,CAAC,UAAU,EAAE,EAAE;YAClC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,eAAe,EAAE,EAAE;gBACtD,IAAI,CAAC,CAAC,eAAe,CAAC,IAAI,IAAI,UAAU,CAAC,EAAE;oBACzC,MAAM,IAAI,KAAK,CACb,yFAAyF,eAAe,CAAC,IAAI,EAAE,CAChH,CAAC;iBACH;gBACD,IAAI,CAAC,WAAW,CACd,eAAe,CAAC,IAAI,EACpB,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,CACjC,CAAC;YACJ,CAAC,CAAC,CAAC;YACH,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QACxC,CAAC,CAAC;QACF,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IAChE,CAAC;IAED,OAAO,CAAC,MAAc;QACpB,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,KAAK,SAAS,CAAC,CAAC;QAEpD,IAAI,IAAI,CAAC,aAAa,KAAK,SAAS,EAAE;YACpC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;SAClE;IACH,CAAC;;AA1Ea,yBAAW,GAAG,IAAI,gBAAgB,CAAC;IAC/C,QAAQ,EAAE,yBAAyB;IACnC,QAAQ,EAAE,OAAO;IACjB,KAAK,EAAE,cAAc;IACrB,aAAa,EAAE;QACb,aAAa,EAAE;YACb,SAAS,EAAE,QAAQ;YACnB,YAAY,EAAE,IAAI;SACnB;KACF;IACD,OAAO,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE,CAC7C,IAAI,aAAa,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,CAAC;CACvD,CAAC,AAZuB,CAYtB;SAbQ,aAAa"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts
new file mode 100644
index 0000000..3964e70
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts
@@ -0,0 +1,11 @@
+import { Fiber } from '../../../Execution/Fiber.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { FlowNode2 } from '../../../Nodes/FlowNode.js';
+import { NodeConfiguration } from '../../../Nodes/Node.js';
+import { NodeDescription, NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class TriggerCustomEvent extends FlowNode2 {
+    static Description: NodeDescription2;
+    private readonly customEvent;
+    constructor(description: NodeDescription, graph: IGraph, configuration: NodeConfiguration);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js
new file mode 100644
index 0000000..dff7d30
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js
@@ -0,0 +1,44 @@
+import { CustomEvent } from '../../../Events/CustomEvent.js';
+import { FlowNode2 } from '../../../Nodes/FlowNode.js';
+import { NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+class TriggerCustomEvent extends FlowNode2 {
+    constructor(description, graph, configuration) {
+        const customEvent = graph.customEvents[configuration.customEventId] ||
+            new CustomEvent('-1', 'undefined');
+        super({
+            description,
+            graph,
+            inputs: [
+                new Socket('flow', 'flow'),
+                ...customEvent.parameters.map((parameter) => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))
+            ],
+            outputs: [new Socket('flow', 'flow')],
+            configuration
+        });
+        this.customEvent = customEvent;
+        graph.customEvents[configuration.customEventId] = customEvent;
+    }
+    triggered(fiber, triggeringSocketName) {
+        const parameters = {};
+        this.customEvent.parameters.forEach((parameterSocket) => {
+            parameters[parameterSocket.name] = this.readInput(parameterSocket.name);
+        });
+        this.customEvent.eventEmitter.emit(parameters);
+        fiber.commit(this, 'flow');
+    }
+}
+TriggerCustomEvent.Description = new NodeDescription2({
+    typeName: 'customEvent/trigger',
+    category: 'Action',
+    label: 'Trigger',
+    configuration: {
+        customEventId: {
+            valueType: 'string',
+            defaultValue: '-1'
+        }
+    },
+    factory: (description, graph, configuration) => new TriggerCustomEvent(description, graph, configuration)
+});
+export { TriggerCustomEvent };
+//# sourceMappingURL=TriggerCustomEvent.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js.map
new file mode 100644
index 0000000..2fbf5d5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/CustomEvents/TriggerCustomEvent.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"TriggerCustomEvent.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,gCAAgC,CAAC;AAG7D,OAAO,EAAE,SAAS,EAAE,MAAM,4BAA4B,CAAC;AAEvD,OAAO,EAEL,gBAAgB,EACjB,MAAM,4CAA4C,CAAC;AACpD,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,MAAa,kBAAmB,SAAQ,SAAS;IAiB/C,YACE,WAA4B,EAC5B,KAAa,EACb,aAAgC;QAEhC,MAAM,WAAW,GACf,KAAK,CAAC,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC;YAC/C,IAAI,WAAW,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;QACrC,KAAK,CAAC;YACJ,WAAW;YACX,KAAK;YACL,MAAM,EAAE;gBACN,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;gBAC1B,GAAG,WAAW,CAAC,UAAU,CAAC,GAAG,CAC3B,CAAC,SAAS,EAAE,EAAE,CACZ,IAAI,MAAM,CACR,SAAS,CAAC,aAAa,EACvB,SAAS,CAAC,IAAI,EACd,SAAS,CAAC,KAAK,EACf,SAAS,CAAC,KAAK,CAChB,CACJ;aACF;YACD,OAAO,EAAE,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YACrC,aAAa;SACd,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,KAAK,CAAC,YAAY,CAAC,aAAa,CAAC,aAAa,CAAC,GAAG,WAAW,CAAC;IAChE,CAAC;IAED,SAAS,CAAC,KAAY,EAAE,oBAA4B;QAClD,MAAM,UAAU,GAAqC,EAAE,CAAC;QACxD,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,eAAe,EAAE,EAAE;YACtD,UAAU,CAAC,eAAe,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC1E,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC/C,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IAC7B,CAAC;;AAtDa,8BAAW,GAAG,IAAI,gBAAgB,CAAC;IAC/C,QAAQ,EAAE,qBAAqB;IAC/B,QAAQ,EAAE,QAAQ;IAClB,KAAK,EAAE,SAAS;IAChB,aAAa,EAAE;QACb,aAAa,EAAE;YACb,SAAS,EAAE,QAAQ;YACnB,YAAY,EAAE,IAAI;SACnB;KACF;IACD,OAAO,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE,CAC7C,IAAI,kBAAkB,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,CAAC;CAC5D,CAAC,CAAC;SAbQ,kBAAkB"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.d.ts
new file mode 100644
index 0000000..24bfec9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.d.ts
@@ -0,0 +1,6 @@
+export declare const ExpectTrue: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<() => {
+    key: string;
+    valueType: string;
+}[], {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js
new file mode 100644
index 0000000..4359286
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js
@@ -0,0 +1,30 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const ExpectTrue = makeFlowNodeDefinition({
+    typeName: 'debug/expectTrue',
+    category: NodeCategory.Action,
+    label: 'Assert Expect True',
+    in: () => {
+        return [
+            {
+                key: 'flow',
+                valueType: 'flow'
+            },
+            {
+                key: 'condition',
+                valueType: 'boolean'
+            },
+            {
+                key: 'description',
+                valueType: 'string'
+            }
+        ];
+    },
+    initialState: undefined,
+    out: { flow: 'flow' },
+    triggered: ({ read, commit }) => {
+        Assert.mustBeTrue(read('condition'), read('description'));
+        commit('flow');
+    }
+});
+//# sourceMappingURL=AssertExpectTrue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js.map
new file mode 100644
index 0000000..1dcf096
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/AssertExpectTrue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"AssertExpectTrue.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Debug/AssertExpectTrue.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AACxD,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,UAAU,GAAG,sBAAsB,CAAC;IAC/C,QAAQ,EAAE,kBAAkB;IAC5B,QAAQ,EAAE,YAAY,CAAC,MAAM;IAC7B,KAAK,EAAE,oBAAoB;IAC3B,EAAE,EAAE,GAAG,EAAE;QACP,OAAO;YACL;gBACE,GAAG,EAAE,MAAM;gBACX,SAAS,EAAE,MAAM;aAClB;YACD;gBACE,GAAG,EAAE,WAAW;gBAChB,SAAS,EAAE,SAAS;aACrB;YACD;gBACE,GAAG,EAAE,aAAa;gBAClB,SAAS,EAAE,QAAQ;aACpB;SACF,CAAC;IACJ,CAAC;IACD,YAAY,EAAE,SAAS;IACvB,GAAG,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE;IACrB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE;QAC9B,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;QAC1D,MAAM,CAAC,MAAM,CAAC,CAAC;IACjB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.d.ts
new file mode 100644
index 0000000..7fdbe47
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.d.ts
@@ -0,0 +1,12 @@
+export declare const Log: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    text: string;
+    severity: {
+        valueType: string;
+        defaultValue: string;
+        choices: string[];
+        label: string;
+    };
+}, {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js
new file mode 100644
index 0000000..aa41fd4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js
@@ -0,0 +1,24 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const Log = makeFlowNodeDefinition({
+    typeName: 'debug/log',
+    category: NodeCategory.Action,
+    label: 'Debug Log',
+    in: {
+        flow: 'flow',
+        text: 'string',
+        severity: {
+            valueType: 'string',
+            defaultValue: 'info',
+            choices: ['verbose', 'info', 'warning', 'error'],
+            label: 'severity'
+        }
+    },
+    out: { flow: 'flow' },
+    initialState: undefined,
+    triggered: ({ read, commit, graph: { getDependency } }) => {
+        const logger = getDependency('ILogger');
+        logger?.log(read('severity'), read('text'));
+        commit('flow');
+    }
+});
+//# sourceMappingURL=DebugLog.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js.map
new file mode 100644
index 0000000..25af35b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Debug/DebugLog.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DebugLog.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Debug/DebugLog.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAG3C,MAAM,CAAC,MAAM,GAAG,GAAG,sBAAsB,CAAC;IACxC,QAAQ,EAAE,WAAW;IACrB,QAAQ,EAAE,YAAY,CAAC,MAAM;IAC7B,KAAK,EAAE,WAAW;IAClB,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,QAAQ;QACd,QAAQ,EAAE;YACR,SAAS,EAAE,QAAQ;YACnB,YAAY,EAAE,MAAM;YACpB,OAAO,EAAE,CAAC,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC;YAChD,KAAK,EAAE,UAAU;SAClB;KACF;IACD,GAAG,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE;IACrB,YAAY,EAAE,SAAS;IACvB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QACxD,MAAM,MAAM,GAAG,aAAa,CAAU,SAAS,CAAC,CAAC;QACjD,MAAM,EAAE,GAAG,CAAC,IAAI,CAAc,UAAU,CAAC,EAAE,IAAI,CAAS,MAAM,CAAC,CAAC,CAAC;QACjE,MAAM,CAAC,MAAM,CAAC,CAAC;IACjB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.d.ts
new file mode 100644
index 0000000..eec0c10
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.d.ts
@@ -0,0 +1,7 @@
+export declare const Branch: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    condition: string;
+}, {
+    true: string;
+    false: string;
+}, import("../../../index.js").NodeConfigurationDescription, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js
new file mode 100644
index 0000000..c08f783
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js
@@ -0,0 +1,20 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const Branch = makeFlowNodeDefinition({
+    typeName: 'flow/branch',
+    category: NodeCategory.Flow,
+    label: 'Branch',
+    helpDescription: "Checks the value of the 'condition' input and if true, executes the 'true' branch, otherwise it executes the 'false' branch.",
+    in: {
+        flow: 'flow',
+        condition: 'boolean'
+    },
+    out: {
+        true: 'flow',
+        false: 'flow'
+    },
+    triggered: ({ read, commit }) => {
+        commit(read('condition') === true ? 'true' : 'false');
+    },
+    initialState: undefined
+});
+//# sourceMappingURL=Branch.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js.map
new file mode 100644
index 0000000..e491224
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Branch.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Branch.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Branch.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,MAAM,GAAG,sBAAsB,CAAC;IAC3C,QAAQ,EAAE,aAAa;IACvB,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,KAAK,EAAE,QAAQ;IACf,eAAe,EACb,8HAA8H;IAChI,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,SAAS,EAAE,SAAS;KACrB;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,MAAM;KACd;IACD,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE;QAC9B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;IACxD,CAAC;IACD,YAAY,EAAE,SAAS;CACxB,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.d.ts
new file mode 100644
index 0000000..4faca62
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.d.ts
@@ -0,0 +1,9 @@
+export declare const Counter: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    reset: string;
+}, {
+    flow: string;
+    count: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    count: number;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js
new file mode 100644
index 0000000..f5b21fd
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js
@@ -0,0 +1,40 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const Counter = makeFlowNodeDefinition({
+    typeName: 'flow/counter',
+    label: 'Counter',
+    in: {
+        flow: 'flow',
+        reset: 'flow'
+    },
+    out: {
+        flow: 'flow',
+        count: 'integer'
+    },
+    initialState: {
+        count: 0
+    },
+    category: NodeCategory.Flow,
+    triggered: ({ commit, write, triggeringSocketName, state }) => {
+        let count = state.count;
+        switch (triggeringSocketName) {
+            case 'flow': {
+                count++;
+                // through type enforcement, write and commit can only write to one of the keys of `out`
+                write('count', count);
+                commit('flow');
+                break;
+            }
+            case 'reset': {
+                count = 0;
+                break;
+            }
+            default:
+                throw new Error('should not get here');
+        }
+        // return updated state
+        return {
+            count
+        };
+    }
+});
+//# sourceMappingURL=Counter.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js.map
new file mode 100644
index 0000000..4cf3292
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Counter.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Counter.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Counter.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,OAAO,GAAG,sBAAsB,CAAC;IAC5C,QAAQ,EAAE,cAAc;IACxB,KAAK,EAAE,SAAS;IAChB,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,MAAM;KACd;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,SAAS;KACjB;IACD,YAAY,EAAE;QACZ,KAAK,EAAE,CAAC;KACT;IACD,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,oBAAoB,EAAE,KAAK,EAAE,EAAE,EAAE;QAC5D,IAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;QACxB,QAAQ,oBAAoB,EAAE;YAC5B,KAAK,MAAM,CAAC,CAAC;gBACX,KAAK,EAAE,CAAC;gBACR,wFAAwF;gBACxF,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gBACtB,MAAM,CAAC,MAAM,CAAC,CAAC;gBACf,MAAM;aACP;YACD,KAAK,OAAO,CAAC,CAAC;gBACZ,KAAK,GAAG,CAAC,CAAC;gBACV,MAAM;aACP;YACD;gBACE,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;SAC1C;QAED,uBAAuB;QACvB,OAAO;YACL,KAAK;SACN,CAAC;IACJ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.d.ts
new file mode 100644
index 0000000..bfb225f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.d.ts
@@ -0,0 +1,11 @@
+import { Engine } from '../../../Execution/Engine.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class Debounce extends AsyncNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: IGraph);
+    private triggerVersion;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js
new file mode 100644
index 0000000..a7713ad
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js
@@ -0,0 +1,37 @@
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+// as long as this continues to be triggered within the duration period, it will not fire.
+// based lousy on https://www.npmjs.com/package/debounce
+class Debounce extends AsyncNode {
+    constructor(description, graph) {
+        super(description, graph, [
+            new Socket('flow', 'flow'),
+            new Socket('float', 'waitDuration'),
+            new Socket('flow', 'cancel')
+        ], [new Socket('flow', 'flow')]);
+        this.triggerVersion = 0;
+    }
+    triggered(engine, triggeringSocketName, finished) {
+        this.triggerVersion++;
+        // if cancelling, just increment triggerVersion and do not set a timer. :)
+        if (triggeringSocketName === 'cancel') {
+            return;
+        }
+        const localTriggerCount = this.triggerVersion;
+        setTimeout(() => {
+            if (this.triggerVersion >= localTriggerCount) {
+                // ignore this timer, as it isn't for the most recent trigger
+                return;
+            }
+            engine.commitToNewFiber(this, 'flow');
+            finished();
+        }, this.readInput('waitDuration') * 1000);
+    }
+    dispose() {
+        this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+    }
+}
+Debounce.Description = new NodeDescription('flow/debounce', 'Flow', 'Debounce', (description, graph) => new Debounce(description, graph));
+export { Debounce };
+//# sourceMappingURL=Debounce.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js.map
new file mode 100644
index 0000000..a5ca529
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Debounce.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Debounce.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Debounce.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,MAAM,4CAA4C,CAAC;AAC7E,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,0FAA0F;AAC1F,wDAAwD;AAExD,MAAa,QAAS,SAAQ,SAAS;IAQrC,YAAY,WAA4B,EAAE,KAAa;QACrD,KAAK,CACH,WAAW,EACX,KAAK,EACL;YACE,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;YAC1B,IAAI,MAAM,CAAC,OAAO,EAAE,cAAc,CAAC;YACnC,IAAI,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC;SAC7B,EACD,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAC7B,CAAC;QAGI,mBAAc,GAAG,CAAC,CAAC;IAF3B,CAAC;IAID,SAAS,CACP,MAAc,EACd,oBAA4B,EAC5B,QAAoB;QAEpB,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,0EAA0E;QAC1E,IAAI,oBAAoB,KAAK,QAAQ,EAAE;YACrC,OAAO;SACR;QAED,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;QAC9C,UAAU,CAAC,GAAG,EAAE;YACd,IAAI,IAAI,CAAC,cAAc,IAAI,iBAAiB,EAAE;gBAC5C,6DAA6D;gBAC7D,OAAO;aACR;YAED,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACtC,QAAQ,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC,SAAS,CAAS,cAAc,CAAC,GAAG,IAAI,CAAC,CAAC;IACpD,CAAC;IAED,OAAO;QACL,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,2CAA2C;IACpE,CAAC;;AAhDa,oBAAW,GAAG,IAAI,eAAe,CAC7C,eAAe,EACf,MAAM,EACN,UAAU,EACV,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CACzD,AALwB,CAKvB;SANS,QAAQ"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.d.ts
new file mode 100644
index 0000000..8e264ae
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.d.ts
@@ -0,0 +1,13 @@
+export declare const DoN: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    n: {
+        valueType: string;
+        defaultValue: number;
+    };
+    reset: string;
+}, {
+    flow: string;
+    count: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    count: number;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js
new file mode 100644
index 0000000..e979237
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js
@@ -0,0 +1,34 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+// based on Unreal Engine Blueprint DoN node
+export const DoN = makeFlowNodeDefinition({
+    typeName: 'flow/doN',
+    label: 'DoN',
+    category: NodeCategory.Flow,
+    in: {
+        flow: 'flow',
+        n: {
+            valueType: 'integer',
+            defaultValue: 1
+        },
+        reset: 'flow'
+    },
+    out: {
+        flow: 'flow',
+        count: 'integer'
+    },
+    initialState: {
+        count: 0
+    },
+    triggered: ({ commit, read, write, triggeringSocketName, state }) => {
+        if (triggeringSocketName === 'reset') {
+            return { count: 0 };
+        }
+        if (state.count < Number(read('n'))) {
+            write('count', state.count);
+            commit('flow');
+            return { count: state.count + 1 };
+        }
+        return state;
+    }
+});
+//# sourceMappingURL=DoN.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js.map
new file mode 100644
index 0000000..f6104e4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoN.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DoN.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/DoN.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,4CAA4C;AAE5C,MAAM,CAAC,MAAM,GAAG,GAAG,sBAAsB,CAAC;IACxC,QAAQ,EAAE,UAAU;IACpB,KAAK,EAAE,KAAK;IACZ,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,CAAC,EAAE;YACD,SAAS,EAAE,SAAS;YACpB,YAAY,EAAE,CAAC;SAChB;QACD,KAAK,EAAE,MAAM;KACd;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,SAAS;KACjB;IACD,YAAY,EAAE;QACZ,KAAK,EAAE,CAAC;KACT;IACD,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,oBAAoB,EAAE,KAAK,EAAE,EAAE,EAAE;QAClE,IAAI,oBAAoB,KAAK,OAAO,EAAE;YACpC,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;SACrB;QAED,IAAI,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;YACnC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;YAC5B,MAAM,CAAC,MAAM,CAAC,CAAC;YACf,OAAO,EAAE,KAAK,EAAE,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC;SACnC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.d.ts
new file mode 100644
index 0000000..246ddc4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.d.ts
@@ -0,0 +1,8 @@
+export declare const DoOnce: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    reset: string;
+}, {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    firedOnce: boolean;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js
new file mode 100644
index 0000000..9a796a6
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js
@@ -0,0 +1,28 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+// based on Unreal Engine Blueprint DoN node
+export const DoOnce = makeFlowNodeDefinition({
+    typeName: 'flow/doOnce',
+    label: 'DoOnce',
+    category: NodeCategory.Flow,
+    in: {
+        flow: 'flow',
+        reset: 'flow'
+    },
+    out: {
+        flow: 'flow'
+    },
+    initialState: {
+        firedOnce: false
+    },
+    triggered: ({ commit, triggeringSocketName, state }) => {
+        if (triggeringSocketName === 'reset') {
+            return { firedOnce: false };
+        }
+        if (!state.firedOnce) {
+            commit('flow');
+            return { firedOnce: true };
+        }
+        return state;
+    }
+});
+//# sourceMappingURL=DoOnce.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js.map
new file mode 100644
index 0000000..dde7732
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/DoOnce.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"DoOnce.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/DoOnce.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAC3C,4CAA4C;AAE5C,MAAM,CAAC,MAAM,MAAM,GAAG,sBAAsB,CAAC;IAC3C,QAAQ,EAAE,aAAa;IACvB,KAAK,EAAE,QAAQ;IACf,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,MAAM;KACd;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;KACb;IACD,YAAY,EAAE;QACZ,SAAS,EAAE,KAAK;KACjB;IACD,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,oBAAoB,EAAE,KAAK,EAAE,EAAE,EAAE;QACrD,IAAI,oBAAoB,KAAK,OAAO,EAAE;YACpC,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;SAC7B;QAED,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;YACpB,MAAM,CAAC,MAAM,CAAC,CAAC;YACf,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;SAC5B;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.d.ts
new file mode 100644
index 0000000..dc94211
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.d.ts
@@ -0,0 +1,9 @@
+export declare const FlipFlop: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+}, {
+    on: string;
+    off: string;
+    isOn: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    isOn: boolean;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js
new file mode 100644
index 0000000..3bfae68
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js
@@ -0,0 +1,23 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const FlipFlop = makeFlowNodeDefinition({
+    typeName: 'flow/flipFlop',
+    category: NodeCategory.Flow,
+    label: 'Flip Flop',
+    in: {
+        flow: 'flow'
+    },
+    out: {
+        on: 'flow',
+        off: 'flow',
+        isOn: 'boolean'
+    },
+    initialState: {
+        isOn: true
+    },
+    triggered: ({ commit, write, state }) => {
+        write('isOn', state.isOn);
+        commit(state.isOn ? 'on' : 'off');
+        return { isOn: !state.isOn };
+    }
+});
+//# sourceMappingURL=FlipFlop.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js.map
new file mode 100644
index 0000000..f26ddcf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/FlipFlop.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FlipFlop.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/FlipFlop.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;IAC7C,QAAQ,EAAE,eAAe;IACzB,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,KAAK,EAAE,WAAW;IAClB,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;KACb;IACD,GAAG,EAAE;QACH,EAAE,EAAE,MAAM;QACV,GAAG,EAAE,MAAM;QACX,IAAI,EAAE,SAAS;KAChB;IACD,YAAY,EAAE;QACZ,IAAI,EAAE,IAAI;KACX;IACD,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE;QACtC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;QAC1B,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAClC,OAAO,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;IAC/B,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.d.ts
new file mode 100644
index 0000000..122aba7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.d.ts
@@ -0,0 +1,9 @@
+export declare const ForLoop: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    startIndex: string;
+    endIndex: string;
+}, {
+    loopBody: string;
+    index: string;
+    completed: string;
+}, import("../../../index.js").NodeConfigurationDescription, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js
new file mode 100644
index 0000000..945f012
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js
@@ -0,0 +1,34 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const ForLoop = makeFlowNodeDefinition({
+    typeName: 'flow/forLoop',
+    category: NodeCategory.Flow,
+    label: 'For Loop',
+    in: {
+        flow: 'flow',
+        startIndex: 'integer',
+        endIndex: 'integer'
+    },
+    out: {
+        loopBody: 'flow',
+        index: 'integer',
+        completed: 'flow'
+    },
+    initialState: undefined,
+    triggered: ({ read, write, commit }) => {
+        const startIndex = read('startIndex');
+        const endIndex = read('endIndex');
+        const loopBodyIteration = (i) => {
+            if (i < endIndex) {
+                write('index', i);
+                commit('loopBody', () => {
+                    loopBodyIteration(i + BigInt(1));
+                });
+            }
+            else {
+                commit('completed');
+            }
+        };
+        loopBodyIteration(startIndex);
+    }
+});
+//# sourceMappingURL=ForLoop.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js.map
new file mode 100644
index 0000000..e4bb356
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/ForLoop.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ForLoop.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/ForLoop.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,OAAO,GAAG,sBAAsB,CAAC;IAC5C,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,KAAK,EAAE,UAAU;IACjB,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,UAAU,EAAE,SAAS;QACrB,QAAQ,EAAE,SAAS;KACpB;IACD,GAAG,EAAE;QACH,QAAQ,EAAE,MAAM;QAChB,KAAK,EAAE,SAAS;QAChB,SAAS,EAAE,MAAM;KAClB;IACD,YAAY,EAAE,SAAS;IACvB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAE,EAAE,EAAE;QACrC,MAAM,UAAU,GAAG,IAAI,CAAS,YAAY,CAAC,CAAC;QAC9C,MAAM,QAAQ,GAAG,IAAI,CAAS,UAAU,CAAC,CAAC;QAC1C,MAAM,iBAAiB,GAAG,CAAC,CAAS,EAAE,EAAE;YACtC,IAAI,CAAC,GAAG,QAAQ,EAAE;gBAChB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBAClB,MAAM,CAAC,UAAU,EAAE,GAAG,EAAE;oBACtB,iBAAiB,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnC,CAAC,CAAC,CAAC;aACJ;iBAAM;gBACL,MAAM,CAAC,WAAW,CAAC,CAAC;aACrB;QACH,CAAC,CAAC;QACF,iBAAiB,CAAC,UAAU,CAAC,CAAC;IAChC,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.d.ts
new file mode 100644
index 0000000..31bf939
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.d.ts
@@ -0,0 +1,12 @@
+export declare const Gate: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    open: string;
+    close: string;
+    toggle: string;
+    startClosed: string;
+}, {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    isInitialized: boolean;
+    isClosed: boolean;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js
new file mode 100644
index 0000000..5a6efac
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js
@@ -0,0 +1,52 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+// based on Unreal Engine Blueprint Gate node
+export const Gate = makeFlowNodeDefinition({
+    typeName: 'flow/gate',
+    label: 'Gate',
+    category: NodeCategory.Flow,
+    in: {
+        flow: 'flow',
+        open: 'flow',
+        close: 'flow',
+        toggle: 'flow',
+        startClosed: 'boolean'
+    },
+    out: {
+        flow: 'flow'
+    },
+    initialState: {
+        isInitialized: false,
+        isClosed: true
+    },
+    triggered: ({ commit, read, triggeringSocketName, state }) => {
+        let isClosed = state.isClosed;
+        let isInitialized = state.isInitialized;
+        if (!state.isInitialized) {
+            isClosed = !!read('startClosed');
+            isInitialized = true;
+        }
+        switch (triggeringSocketName) {
+            case 'flow':
+                if (!isClosed) {
+                    commit('flow');
+                }
+                break;
+            case 'open':
+                isClosed = false;
+                break;
+            case 'close':
+                isClosed = true;
+                break;
+            case 'toggle':
+                isClosed = !isClosed;
+                break;
+            default:
+                throw new Error(`Unexpected triggering socket: ${triggeringSocketName}`);
+        }
+        return {
+            isClosed,
+            isInitialized
+        };
+    }
+});
+//# sourceMappingURL=Gate.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js.map
new file mode 100644
index 0000000..5b41d3a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Gate.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Gate.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Gate.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,6CAA6C;AAE7C,MAAM,CAAC,MAAM,IAAI,GAAG,sBAAsB,CAAC;IACzC,QAAQ,EAAE,WAAW;IACrB,KAAK,EAAE,MAAM;IACb,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,MAAM;QACb,MAAM,EAAE,MAAM;QACd,WAAW,EAAE,SAAS;KACvB;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;KACb;IACD,YAAY,EAAE;QACZ,aAAa,EAAE,KAAK;QACpB,QAAQ,EAAE,IAAI;KACf;IACD,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,oBAAoB,EAAE,KAAK,EAAE,EAAE,EAAE;QAC3D,IAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;QAC9B,IAAI,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;QAExC,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE;YACxB,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;YACjC,aAAa,GAAG,IAAI,CAAC;SACtB;QAED,QAAQ,oBAAoB,EAAE;YAC5B,KAAK,MAAM;gBACT,IAAI,CAAC,QAAQ,EAAE;oBACb,MAAM,CAAC,MAAM,CAAC,CAAC;iBAChB;gBACD,MAAM;YACR,KAAK,MAAM;gBACT,QAAQ,GAAG,KAAK,CAAC;gBACjB,MAAM;YACR,KAAK,OAAO;gBACV,QAAQ,GAAG,IAAI,CAAC;gBAChB,MAAM;YACR,KAAK,QAAQ;gBACX,QAAQ,GAAG,CAAC,QAAQ,CAAC;gBACrB,MAAM;YACR;gBACE,MAAM,IAAI,KAAK,CACb,iCAAiC,oBAAoB,EAAE,CACxD,CAAC;SACL;QAED,OAAO;YACL,QAAQ;YACR,aAAa;SACd,CAAC;IACJ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.d.ts
new file mode 100644
index 0000000..fff5cf1
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.d.ts
@@ -0,0 +1,13 @@
+export declare const MultiGate: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+    reset: string;
+    loop: string;
+    startIndex: string;
+}, {
+    1: string;
+    2: string;
+    3: string;
+}, import("../../../index.js").NodeConfigurationDescription, {
+    isInitialized: boolean;
+    nextIndex: number;
+}>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js
new file mode 100644
index 0000000..c457c69
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js
@@ -0,0 +1,69 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+export const MultiGate = makeFlowNodeDefinition({
+    typeName: 'flow/multiGate',
+    category: NodeCategory.Flow,
+    label: 'MultiGate',
+    in: {
+        flow: 'flow',
+        reset: 'flow',
+        loop: 'boolean',
+        startIndex: 'integer'
+    },
+    out: {
+        1: 'flow',
+        2: 'flow',
+        3: 'flow'
+    },
+    initialState: {
+        isInitialized: false,
+        nextIndex: 0
+    },
+    triggered: ({ state, commit, read, outputSocketKeys, triggeringSocketName }) => {
+        let nextIndex = state.nextIndex;
+        let isInitialized = state.isInitialized;
+        if (!isInitialized) {
+            nextIndex = Number(read('startIndex'));
+            isInitialized = true;
+        }
+        if (read('loop')) {
+            nextIndex = nextIndex % outputSocketKeys.length;
+        }
+        switch (triggeringSocketName) {
+            case 'reset': {
+                nextIndex = 0;
+                return {
+                    isInitialized,
+                    nextIndex
+                };
+            }
+            case 'flow': {
+                if (0 <= nextIndex && nextIndex < outputSocketKeys.length) {
+                    const output = outputSocketKeys[nextIndex];
+                    commit(output);
+                }
+                nextIndex++;
+                return {
+                    isInitialized,
+                    nextIndex
+                };
+            }
+        }
+        // these outputs are fired sequentially in an sync fashion but without delays.
+        // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+        const sequenceIteration = (i) => {
+            if (i < outputSocketKeys.length) {
+                const outputSocket = outputSocketKeys[i];
+                commit(outputSocket, () => {
+                    sequenceIteration(i + 1);
+                });
+            }
+        };
+        sequenceIteration(0);
+        return {
+            isInitialized,
+            nextIndex
+        };
+    }
+});
+//# sourceMappingURL=MultiGate.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js.map
new file mode 100644
index 0000000..c158539
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/MultiGate.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"MultiGate.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/MultiGate.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,8FAA8F;AAE9F,MAAM,CAAC,MAAM,SAAS,GAAG,sBAAsB,CAAC;IAC9C,QAAQ,EAAE,gBAAgB;IAC1B,QAAQ,EAAE,YAAY,CAAC,IAAI;IAC3B,KAAK,EAAE,WAAW;IAClB,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;QACZ,KAAK,EAAE,MAAM;QACb,IAAI,EAAE,SAAS;QACf,UAAU,EAAE,SAAS;KACtB;IACD,GAAG,EAAE;QACH,CAAC,EAAE,MAAM;QACT,CAAC,EAAE,MAAM;QACT,CAAC,EAAE,MAAM;KACV;IACD,YAAY,EAAE;QACZ,aAAa,EAAE,KAAK;QACpB,SAAS,EAAE,CAAC;KACb;IACD,SAAS,EAAE,CAAC,EACV,KAAK,EACL,MAAM,EACN,IAAI,EACJ,gBAAgB,EAChB,oBAAoB,EACrB,EAAE,EAAE;QACH,IAAI,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;QAChC,IAAI,aAAa,GAAG,KAAK,CAAC,aAAa,CAAC;QACxC,IAAI,CAAC,aAAa,EAAE;YAClB,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YACvC,aAAa,GAAG,IAAI,CAAC;SACtB;QAED,IAAI,IAAI,CAAU,MAAM,CAAC,EAAE;YACzB,SAAS,GAAG,SAAS,GAAG,gBAAgB,CAAC,MAAM,CAAC;SACjD;QAED,QAAQ,oBAAoB,EAAE;YAC5B,KAAK,OAAO,CAAC,CAAC;gBACZ,SAAS,GAAG,CAAC,CAAC;gBACd,OAAO;oBACL,aAAa;oBACb,SAAS;iBACV,CAAC;aACH;YACD,KAAK,MAAM,CAAC,CAAC;gBACX,IAAI,CAAC,IAAI,SAAS,IAAI,SAAS,GAAG,gBAAgB,CAAC,MAAM,EAAE;oBACzD,MAAM,MAAM,GAAG,gBAAgB,CAAC,SAAS,CAAC,CAAC;oBAC3C,MAAM,CAAC,MAAM,CAAC,CAAC;iBAChB;gBACD,SAAS,EAAE,CAAC;gBACZ,OAAO;oBACL,aAAa;oBACb,SAAS;iBACV,CAAC;aACH;SACF;QACD,8EAA8E;QAC9E,iHAAiH;QACjH,MAAM,iBAAiB,GAAG,CAAC,CAAS,EAAE,EAAE;YACtC,IAAI,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE;gBAC/B,MAAM,YAAY,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;gBACzC,MAAM,CAAC,YAAY,EAAE,GAAG,EAAE;oBACxB,iBAAiB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;aACJ;QACH,CAAC,CAAC;QACF,iBAAiB,CAAC,CAAC,CAAC,CAAC;QAErB,OAAO;YACL,aAAa;YACb,SAAS;SACV,CAAC;IACJ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.d.ts
new file mode 100644
index 0000000..d5c2727
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.d.ts
@@ -0,0 +1,9 @@
+import { SocketsList } from '../../../Nodes/NodeDefinitions.js';
+export declare const Sequence: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<{
+    flow: string;
+}, (configuration: import("../../../index.js").NodeConfiguration) => SocketsList, {
+    numOutputs: {
+        valueType: string;
+        defaultValue: number;
+    };
+}, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js
new file mode 100644
index 0000000..7b65296
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js
@@ -0,0 +1,43 @@
+import { makeFlowNodeDefinition } from '../../../Nodes/NodeDefinitions.js';
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+export const Sequence = makeFlowNodeDefinition({
+    typeName: 'flow/sequence',
+    label: 'Sequence',
+    configuration: {
+        numOutputs: {
+            valueType: 'number',
+            defaultValue: 4
+        }
+    },
+    in: {
+        flow: 'flow'
+    },
+    out: (configuration) => {
+        const numOutputs = configuration.numOutputs ?? 4;
+        const sockets = [];
+        for (let outputIndex = 1; outputIndex <= numOutputs; outputIndex++) {
+            const key = `${outputIndex}`;
+            sockets.push({
+                key,
+                valueType: 'flow'
+            });
+        }
+        return sockets;
+    },
+    initialState: undefined,
+    triggered: ({ commit, outputSocketKeys }) => {
+        // these outputs are fired sequentially in an sync fashion but without delays.
+        // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+        const sequenceIteration = (i) => {
+            if (i < outputSocketKeys.length) {
+                const outputKey = outputSocketKeys[i];
+                // const outputSocket = this.outputs[i];
+                commit(outputKey, () => {
+                    sequenceIteration(i + 1);
+                });
+            }
+        };
+        sequenceIteration(0);
+    }
+});
+//# sourceMappingURL=Sequence.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js.map
new file mode 100644
index 0000000..6aa23da
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Sequence.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Sequence.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Sequence.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EAEvB,MAAM,mCAAmC,CAAC;AAE3C,8FAA8F;AAE9F,MAAM,CAAC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;IAC7C,QAAQ,EAAE,eAAe;IACzB,KAAK,EAAE,UAAU;IACjB,aAAa,EAAE;QACb,UAAU,EAAE;YACV,SAAS,EAAE,QAAQ;YACnB,YAAY,EAAE,CAAC;SAChB;KACF;IACD,EAAE,EAAE;QACF,IAAI,EAAE,MAAM;KACb;IACD,GAAG,EAAE,CAAC,aAAa,EAAE,EAAE;QACrB,MAAM,UAAU,GAAG,aAAa,CAAC,UAAU,IAAI,CAAC,CAAC;QACjD,MAAM,OAAO,GAAgB,EAAE,CAAC;QAEhC,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,IAAI,UAAU,EAAE,WAAW,EAAE,EAAE;YAClE,MAAM,GAAG,GAAG,GAAG,WAAW,EAAE,CAAC;YAE7B,OAAO,CAAC,IAAI,CAAC;gBACX,GAAG;gBACH,SAAS,EAAE,MAAM;aAClB,CAAC,CAAC;SACJ;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,YAAY,EAAE,SAAS;IACvB,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,gBAAgB,EAAE,EAAE,EAAE;QAC1C,8EAA8E;QAC9E,iHAAiH;QACjH,MAAM,iBAAiB,GAAG,CAAC,CAAS,EAAE,EAAE;YACtC,IAAI,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE;gBAC/B,MAAM,SAAS,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;gBACtC,wCAAwC;gBACxC,MAAM,CAAC,SAAS,EAAE,GAAG,EAAE;oBACrB,iBAAiB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC3B,CAAC,CAAC,CAAC;aACJ;QACH,CAAC,CAAC;QACF,iBAAiB,CAAC,CAAC,CAAC,CAAC;IACvB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.d.ts
new file mode 100644
index 0000000..c396bcc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.d.ts
@@ -0,0 +1,6 @@
+import { SocketsList } from '../../../Nodes/NodeDefinitions.js';
+export declare const SwitchOnInteger: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<(configuration: import("../../../index.js").NodeConfiguration) => SocketsList, (configuration: import("../../../index.js").NodeConfiguration) => SocketsList, {
+    numCases: {
+        valueType: string;
+    };
+}, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js
new file mode 100644
index 0000000..4984c72
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js
@@ -0,0 +1,40 @@
+import { makeFlowNodeDefinition } from '../../../Nodes/NodeDefinitions.js';
+import { sequence } from '../../../sequence.js';
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+export const SwitchOnInteger = makeFlowNodeDefinition({
+    typeName: 'flow/switch/integer',
+    label: 'Switch on Int',
+    configuration: {
+        numCases: {
+            valueType: 'number'
+        }
+    },
+    in: (configuration) => {
+        const sockets = [];
+        sockets.push({ key: 'flow', valueType: 'flow' }, { key: 'selection', valueType: 'integer' });
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            sockets.push({ key: `${index}`, valueType: 'integer' });
+        }
+        return sockets;
+    },
+    out: (configuration) => {
+        const sockets = [];
+        sockets.push({ key: 'default', valueType: 'flow' });
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            sockets.push({ key: `${index}`, valueType: 'flow' });
+        }
+        return sockets;
+    },
+    initialState: undefined,
+    triggered: ({ read, commit, configuration }) => {
+        const selection = read('selection');
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            if (selection === read(`${index}`)) {
+                commit(`${index}`);
+                return;
+            }
+        }
+        commit('default');
+    }
+});
+//# sourceMappingURL=SwitchOnInteger.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js.map
new file mode 100644
index 0000000..8d6a249
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnInteger.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SwitchOnInteger.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/SwitchOnInteger.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EAEvB,MAAM,mCAAmC,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAC;AAEhD,8FAA8F;AAE9F,MAAM,CAAC,MAAM,eAAe,GAAG,sBAAsB,CAAC;IACpD,QAAQ,EAAE,qBAAqB;IAC/B,KAAK,EAAE,eAAe;IACtB,aAAa,EAAE;QACb,QAAQ,EAAE;YACR,SAAS,EAAE,QAAQ;SACpB;KACF;IACD,EAAE,EAAE,CAAC,aAAa,EAAE,EAAE;QACpB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAEhC,OAAO,CAAC,IAAI,CACV,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,EAClC,EAAE,GAAG,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS,EAAE,CAC3C,CAAC;QAEF,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,KAAK,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC;SACzD;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,GAAG,EAAE,CAAC,aAAa,EAAE,EAAE;QACrB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAEhC,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QACpD,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,KAAK,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;SACtD;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,YAAY,EAAE,SAAS;IACvB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,EAAE,EAAE;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAS,WAAW,CAAC,CAAC;QAC5C,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,IAAI,SAAS,KAAK,IAAI,CAAS,GAAG,KAAK,EAAE,CAAC,EAAE;gBAC1C,MAAM,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC;gBACnB,OAAO;aACR;SACF;QACD,MAAM,CAAC,SAAS,CAAC,CAAC;IACpB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.d.ts
new file mode 100644
index 0000000..ca27f0a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.d.ts
@@ -0,0 +1,6 @@
+import { SocketsList } from '../../../Nodes/NodeDefinitions.js';
+export declare const SwitchOnString: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<(configuration: import("../../../index.js").NodeConfiguration) => SocketsList, (configuration: import("../../../index.js").NodeConfiguration) => SocketsList, {
+    numCases: {
+        valueType: string;
+    };
+}, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js
new file mode 100644
index 0000000..eebd3b6
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js
@@ -0,0 +1,40 @@
+import { makeFlowNodeDefinition } from '../../../Nodes/NodeDefinitions.js';
+import { sequence } from '../../../sequence.js';
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+export const SwitchOnString = makeFlowNodeDefinition({
+    typeName: 'flow/switch/string',
+    label: 'Switch on String',
+    configuration: {
+        numCases: {
+            valueType: 'number'
+        }
+    },
+    in: (configuration) => {
+        const sockets = [];
+        sockets.push({ key: 'flow', valueType: 'flow' }, { key: 'selection', valueType: 'string' });
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            sockets.push({ key: `${index}`, valueType: 'string' });
+        }
+        return sockets;
+    },
+    out: (configuration) => {
+        const sockets = [];
+        sockets.push({ key: 'default', valueType: 'flow' });
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            sockets.push({ key: `${index}`, valueType: 'flow' });
+        }
+        return sockets;
+    },
+    initialState: undefined,
+    triggered: ({ read, commit, configuration }) => {
+        const selection = read('selection');
+        for (const index of sequence(1, configuration.numCases + 1)) {
+            if (selection === read(`${index}`)) {
+                commit(`${index}`);
+                return;
+            }
+        }
+        commit('default');
+    }
+});
+//# sourceMappingURL=SwitchOnString.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js.map
new file mode 100644
index 0000000..d67584e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/SwitchOnString.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"SwitchOnString.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/SwitchOnString.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EAEvB,MAAM,mCAAmC,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAC;AAEhD,8FAA8F;AAE9F,MAAM,CAAC,MAAM,cAAc,GAAG,sBAAsB,CAAC;IACnD,QAAQ,EAAE,oBAAoB;IAC9B,KAAK,EAAE,kBAAkB;IACzB,aAAa,EAAE;QACb,QAAQ,EAAE;YACR,SAAS,EAAE,QAAQ;SACpB;KACF;IACD,EAAE,EAAE,CAAC,aAAa,EAAE,EAAE;QACpB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAEhC,OAAO,CAAC,IAAI,CACV,EAAE,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,EAClC,EAAE,GAAG,EAAE,WAAW,EAAE,SAAS,EAAE,QAAQ,EAAE,CAC1C,CAAC;QAEF,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,KAAK,EAAE,EAAE,SAAS,EAAE,QAAQ,EAAE,CAAC,CAAC;SACxD;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,GAAG,EAAE,CAAC,aAAa,EAAE,EAAE;QACrB,MAAM,OAAO,GAAgB,EAAE,CAAC;QAEhC,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;QACpD,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,KAAK,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,CAAC,CAAC;SACtD;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,YAAY,EAAE,SAAS;IACvB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,aAAa,EAAE,EAAE,EAAE;QAC7C,MAAM,SAAS,GAAG,IAAI,CAAS,WAAW,CAAC,CAAC;QAC5C,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,CAAC,EAAE,aAAa,CAAC,QAAQ,GAAG,CAAC,CAAC,EAAE;YAC3D,IAAI,SAAS,KAAK,IAAI,CAAS,GAAG,KAAK,EAAE,CAAC,EAAE;gBAC1C,MAAM,CAAC,GAAG,KAAK,EAAE,CAAC,CAAC;gBACnB,OAAO;aACR;SACF;QACD,MAAM,CAAC,SAAS,CAAC,CAAC;IACpB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.d.ts
new file mode 100644
index 0000000..9212482
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.d.ts
@@ -0,0 +1,12 @@
+import { Engine } from '../../../Execution/Engine.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class Throttle extends AsyncNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: IGraph);
+    private triggerVersion;
+    private timeoutPending;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js
new file mode 100644
index 0000000..dc1fbb3
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js
@@ -0,0 +1,50 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+// based on the description here: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/
+class Throttle extends AsyncNode {
+    constructor(description, graph) {
+        super(description, graph, [
+            new Socket('flow', 'flow'),
+            new Socket('float', 'duration', 1),
+            new Socket('flow', 'cancel')
+        ], [new Socket('flow', 'flow')]);
+        this.triggerVersion = 0;
+        this.timeoutPending = false;
+    }
+    triggered(engine, triggeringSocketName, finished) {
+        // if cancelling, just increment triggerVersion and do not set a timer. :)
+        if (triggeringSocketName === 'cancel') {
+            if (this.timeoutPending) {
+                this.triggerVersion++;
+                this.timeoutPending = false;
+            }
+            return;
+        }
+        // if there is a valid timeout running, leave it.
+        if (this.timeoutPending) {
+            return;
+        }
+        // otherwise start it.
+        this.triggerVersion++;
+        const localTriggerCount = this.triggerVersion;
+        this.timeoutPending = true;
+        setTimeout(() => {
+            if (this.triggerVersion !== localTriggerCount) {
+                return;
+            }
+            Assert.mustBeTrue(this.timeoutPending);
+            this.timeoutPending = false;
+            engine.commitToNewFiber(this, 'flow');
+            finished();
+        }, this.readInput('duration') * 1000);
+    }
+    dispose() {
+        this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+        this.timeoutPending = false;
+    }
+}
+Throttle.Description = new NodeDescription('flow/throttle', 'Flow', 'Throttle', (description, graph) => new Throttle(description, graph));
+export { Throttle };
+//# sourceMappingURL=Throttle.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js.map
new file mode 100644
index 0000000..c7c67d4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/Throttle.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Throttle.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/Throttle.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AAGxD,OAAO,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,MAAM,4CAA4C,CAAC;AAC7E,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,iGAAiG;AAEjG,MAAa,QAAS,SAAQ,SAAS;IAQrC,YAAY,WAA4B,EAAE,KAAa;QACrD,KAAK,CACH,WAAW,EACX,KAAK,EACL;YACE,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;YAC1B,IAAI,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC;YAClC,IAAI,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC;SAC7B,EACD,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAC7B,CAAC;QAGI,mBAAc,GAAG,CAAC,CAAC;QACnB,mBAAc,GAAG,KAAK,CAAC;IAH/B,CAAC;IAKD,SAAS,CACP,MAAc,EACd,oBAA4B,EAC5B,QAAoB;QAEpB,0EAA0E;QAC1E,IAAI,oBAAoB,KAAK,QAAQ,EAAE;YACrC,IAAI,IAAI,CAAC,cAAc,EAAE;gBACvB,IAAI,CAAC,cAAc,EAAE,CAAC;gBACtB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;aAC7B;YACD,OAAO;SACR;QAED,iDAAiD;QACjD,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,OAAO;SACR;QAED,sBAAsB;QACtB,IAAI,CAAC,cAAc,EAAE,CAAC;QACtB,MAAM,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC;QAC9C,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC3B,UAAU,CAAC,GAAG,EAAE;YACd,IAAI,IAAI,CAAC,cAAc,KAAK,iBAAiB,EAAE;gBAC7C,OAAO;aACR;YACD,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACvC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;YAC5B,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACtC,QAAQ,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC,SAAS,CAAS,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,CAAC;IAED,OAAO;QACL,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC,2CAA2C;QAClE,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;IAC9B,CAAC;;AA5Da,oBAAW,GAAG,IAAI,eAAe,CAC7C,eAAe,EACf,MAAM,EACN,UAAU,EACV,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CACzD,AALwB,CAKvB;SANS,QAAQ"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.d.ts
new file mode 100644
index 0000000..aa4ac05
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.d.ts
@@ -0,0 +1,15 @@
+import { Fiber } from '../../../Execution/Fiber.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { FlowNode } from '../../../Nodes/FlowNode.js';
+import { NodeDescription, NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class WaitAll extends FlowNode {
+    private numInputs;
+    static Description: NodeDescription2;
+    private isOn;
+    constructor(description: NodeDescription, graph: IGraph, numInputs: number);
+    private triggeredMap;
+    private triggeredCount;
+    private outputTriggered;
+    private reset;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js
new file mode 100644
index 0000000..f45ae5e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js
@@ -0,0 +1,64 @@
+import { FlowNode } from '../../../Nodes/FlowNode.js';
+import { NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+// this is equivalent to Promise.all()
+class WaitAll extends FlowNode {
+    constructor(description, graph, numInputs) {
+        const inputs = [];
+        for (let i = 1; i <= numInputs; i++) {
+            inputs.push(new Socket('flow', `${i}`));
+        }
+        super(description, graph, [
+            ...inputs,
+            new Socket('flow', 'reset'),
+            new Socket('boolean', 'autoReset')
+        ], [new Socket('flow', 'flow')]);
+        this.numInputs = numInputs;
+        this.isOn = true;
+        this.triggeredMap = {};
+        this.triggeredCount = 0;
+        this.outputTriggered = false;
+        this.reset();
+    }
+    reset() {
+        for (let inputIndex = 1; inputIndex <= this.numInputs; inputIndex++) {
+            this.triggeredMap[`${inputIndex}`] = false;
+        }
+        this.triggeredCount = 0;
+        this.outputTriggered = false;
+    }
+    triggered(fiber, triggeringSocketName) {
+        if (triggeringSocketName === 'reset') {
+            this.reset();
+            return;
+        }
+        if (this.triggeredMap[triggeringSocketName]) {
+            return;
+        }
+        this.triggeredMap[triggeringSocketName] = true;
+        this.triggeredCount++;
+        // if a & b are triggered, first output!
+        if (this.triggeredCount === this.numInputs && !this.outputTriggered) {
+            fiber.commit(this, 'flow');
+            this.outputTriggered = true;
+            // auto-reset if required.
+            if (this.readInput('autoReset') === true) {
+                this.reset();
+            }
+        }
+    }
+}
+WaitAll.Description = new NodeDescription2({
+    typeName: 'flow/waitAll',
+    category: 'Flow',
+    label: 'WaitAll',
+    configuration: {
+        numInputs: {
+            valueType: 'number',
+            defaultValue: 3
+        }
+    },
+    factory: (description, graph, configuration) => new WaitAll(description, graph, configuration.numInputs)
+});
+export { WaitAll };
+//# sourceMappingURL=WaitAll.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js.map
new file mode 100644
index 0000000..926a4d5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Flow/WaitAll.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"WaitAll.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Flow/WaitAll.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAEL,gBAAgB,EACjB,MAAM,4CAA4C,CAAC;AACpD,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,sCAAsC;AACtC,MAAa,OAAQ,SAAQ,QAAQ;IAiBnC,YACE,WAA4B,EAC5B,KAAa,EACL,SAAiB;QAEzB,MAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,SAAS,EAAE,CAAC,EAAE,EAAE;YACnC,MAAM,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;SACzC;QAED,KAAK,CACH,WAAW,EACX,KAAK,EACL;YACE,GAAG,MAAM;YACT,IAAI,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC;YAC3B,IAAI,MAAM,CAAC,SAAS,EAAE,WAAW,CAAC;SACnC,EACD,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAC7B,CAAC;QAhBM,cAAS,GAAT,SAAS,CAAQ;QALnB,SAAI,GAAG,IAAI,CAAC;QA0BZ,iBAAY,GAA+B,EAAE,CAAC;QAC9C,mBAAc,GAAG,CAAC,CAAC;QACnB,oBAAe,GAAG,KAAK,CAAC;QAL9B,IAAI,CAAC,KAAK,EAAE,CAAC;IACf,CAAC;IAMO,KAAK;QACX,KAAK,IAAI,UAAU,GAAG,CAAC,EAAE,UAAU,IAAI,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE;YACnE,IAAI,CAAC,YAAY,CAAC,GAAG,UAAU,EAAE,CAAC,GAAG,KAAK,CAAC;SAC5C;QACD,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;QACxB,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;IAC/B,CAAC;IAED,SAAS,CAAC,KAAY,EAAE,oBAA4B;QAClD,IAAI,oBAAoB,KAAK,OAAO,EAAE;YACpC,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,OAAO;SACR;QAED,IAAI,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,EAAE;YAC3C,OAAO;SACR;QAED,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,GAAG,IAAI,CAAC;QAC/C,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,wCAAwC;QACxC,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACnE,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YAC3B,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAE5B,0BAA0B;YAC1B,IAAI,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,KAAK,IAAI,EAAE;gBACxC,IAAI,CAAC,KAAK,EAAE,CAAC;aACd;SACF;IACH,CAAC;;AA3Ea,mBAAW,GAAG,IAAI,gBAAgB,CAAC;IAC/C,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,MAAM;IAChB,KAAK,EAAE,SAAS;IAChB,aAAa,EAAE;QACb,SAAS,EAAE;YACT,SAAS,EAAE,QAAQ;YACnB,YAAY,EAAE,CAAC;SAChB;KACF;IACD,OAAO,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE,CAC7C,IAAI,OAAO,CAAC,WAAW,EAAE,KAAK,EAAE,aAAa,CAAC,SAAS,CAAC;CAC3D,CAAC,AAZuB,CAYtB;SAbQ,OAAO"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts
new file mode 100644
index 0000000..30e14a9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts
@@ -0,0 +1,7 @@
+type State = {
+    onEndEvent?: (() => void) | undefined;
+};
+export declare const LifecycleOnEnd: import("../../../Nodes/NodeDefinitions.js").IEventNodeDefinition<{}, {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, State>;
+export {};
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js
new file mode 100644
index 0000000..f34a7fa
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js
@@ -0,0 +1,34 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { makeEventNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+const makeInitialState = () => ({
+    onEndEvent: undefined
+});
+export const LifecycleOnEnd = makeEventNodeDefinition({
+    typeName: 'lifecycle/onEnd',
+    label: 'On End',
+    category: NodeCategory.Event,
+    in: {},
+    out: {
+        flow: 'flow'
+    },
+    initialState: makeInitialState(),
+    init: ({ state, commit, graph: { getDependency } }) => {
+        Assert.mustBeTrue(state.onEndEvent === undefined);
+        const onEndEvent = () => {
+            commit('flow');
+        };
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        lifecycleEventEmitter?.endEvent.addListener(onEndEvent);
+        return {
+            onEndEvent
+        };
+    },
+    dispose: ({ state: { onEndEvent }, graph: { getDependency } }) => {
+        Assert.mustBeTrue(onEndEvent !== undefined);
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        if (onEndEvent)
+            lifecycleEventEmitter?.endEvent.removeListener(onEndEvent);
+        return {};
+    }
+});
+//# sourceMappingURL=LifecycleOnEnd.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js.map
new file mode 100644
index 0000000..c8ab5e6
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnEnd.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LifecycleOnEnd.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Lifecycle/LifecycleOnEnd.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AACxD,OAAO,EACL,uBAAuB,EACvB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAS3C,MAAM,gBAAgB,GAAG,GAAU,EAAE,CAAC,CAAC;IACrC,UAAU,EAAE,SAAS;CACtB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,cAAc,GAAG,uBAAuB,CAAC;IACpD,QAAQ,EAAE,iBAAiB;IAC3B,KAAK,EAAE,QAAQ;IACf,QAAQ,EAAE,YAAY,CAAC,KAAK;IAC5B,EAAE,EAAE,EAAE;IACN,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;KACb;IACD,YAAY,EAAE,gBAAgB,EAAE;IAChC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QACpD,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC;QAClD,MAAM,UAAU,GAAG,GAAG,EAAE;YACtB,MAAM,CAAC,MAAM,CAAC,CAAC;QACjB,CAAC,CAAC;QAEF,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,qBAAqB,EAAE,QAAQ,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAExD,OAAO;YACL,UAAU;SACX,CAAC;IACJ,CAAC;IACD,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,UAAU,EAAE,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QAC/D,MAAM,CAAC,UAAU,CAAC,UAAU,KAAK,SAAS,CAAC,CAAC;QAE5C,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,IAAI,UAAU;YAAE,qBAAqB,EAAE,QAAQ,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAE3E,OAAO,EAAE,CAAC;IACZ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts
new file mode 100644
index 0000000..7fb13a3
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts
@@ -0,0 +1,7 @@
+type State = {
+    onStartEvent?: (() => void) | undefined;
+};
+export declare const LifecycleOnStart: import("../../../Nodes/NodeDefinitions.js").IEventNodeDefinition<{}, {
+    flow: string;
+}, import("../../../index.js").NodeConfigurationDescription, State>;
+export {};
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js
new file mode 100644
index 0000000..9e4024a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js
@@ -0,0 +1,34 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { makeEventNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+const makeInitialState = () => ({
+    onStartEvent: undefined
+});
+export const LifecycleOnStart = makeEventNodeDefinition({
+    typeName: 'lifecycle/onStart',
+    label: 'On Start',
+    category: NodeCategory.Event,
+    in: {},
+    out: {
+        flow: 'flow'
+    },
+    initialState: makeInitialState(),
+    init: ({ state, commit, graph: { getDependency } }) => {
+        Assert.mustBeTrue(state.onStartEvent === undefined);
+        const onStartEvent = () => {
+            commit('flow');
+        };
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        lifecycleEventEmitter?.startEvent.addListener(onStartEvent);
+        return {
+            onStartEvent
+        };
+    },
+    dispose: ({ state: { onStartEvent }, graph: { getDependency } }) => {
+        Assert.mustBeTrue(onStartEvent !== undefined);
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        if (onStartEvent)
+            lifecycleEventEmitter?.startEvent.removeListener(onStartEvent);
+        return {};
+    }
+});
+//# sourceMappingURL=LifecycleOnStart.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js.map
new file mode 100644
index 0000000..bd864b2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnStart.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LifecycleOnStart.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Lifecycle/LifecycleOnStart.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AACxD,OAAO,EACL,uBAAuB,EACvB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAO3C,MAAM,gBAAgB,GAAG,GAAU,EAAE,CAAC,CAAC;IACrC,YAAY,EAAE,SAAS;CACxB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,gBAAgB,GAAG,uBAAuB,CAAC;IACtD,QAAQ,EAAE,mBAAmB;IAC7B,KAAK,EAAE,UAAU;IACjB,QAAQ,EAAE,YAAY,CAAC,KAAK;IAC5B,EAAE,EAAE,EAAE;IACN,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;KACb;IACD,YAAY,EAAE,gBAAgB,EAAE;IAChC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QACpD,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,YAAY,KAAK,SAAS,CAAC,CAAC;QACpD,MAAM,YAAY,GAAG,GAAG,EAAE;YACxB,MAAM,CAAC,MAAM,CAAC,CAAC;QACjB,CAAC,CAAC;QAEF,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,qBAAqB,EAAE,UAAU,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC;QAE5D,OAAO;YACL,YAAY;SACb,CAAC;IACJ,CAAC;IACD,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QACjE,MAAM,CAAC,UAAU,CAAC,YAAY,KAAK,SAAS,CAAC,CAAC;QAE9C,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,IAAI,YAAY;YACd,qBAAqB,EAAE,UAAU,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;QAEjE,OAAO,EAAE,CAAC;IACZ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts
new file mode 100644
index 0000000..05e367b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts
@@ -0,0 +1,8 @@
+type State = {
+    onTickEvent?: (() => void) | undefined;
+};
+export declare const LifecycleOnTick: import("../../../Nodes/NodeDefinitions.js").IEventNodeDefinition<{}, {
+    flow: string;
+    deltaSeconds: string;
+}, import("../../../index.js").NodeConfigurationDescription, State>;
+export {};
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js
new file mode 100644
index 0000000..8343f47
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js
@@ -0,0 +1,40 @@
+import { Assert } from '../../../Diagnostics/Assert.js';
+import { makeEventNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+const makeInitialState = () => ({
+    onTickEvent: undefined
+});
+export const LifecycleOnTick = makeEventNodeDefinition({
+    typeName: 'lifecycle/onTick',
+    label: 'On Tick',
+    category: NodeCategory.Event,
+    in: {},
+    out: {
+        flow: 'flow',
+        deltaSeconds: 'float'
+    },
+    initialState: makeInitialState(),
+    init: ({ state, commit, write, graph: { getDependency } }) => {
+        Assert.mustBeTrue(state.onTickEvent === undefined);
+        let lastTickTime = Date.now();
+        const onTickEvent = () => {
+            const currentTime = Date.now();
+            const deltaSeconds = (currentTime - lastTickTime) * 0.001;
+            write('deltaSeconds', deltaSeconds);
+            commit('flow');
+            lastTickTime = currentTime;
+        };
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        lifecycleEventEmitter?.tickEvent.addListener(onTickEvent);
+        return {
+            onTickEvent
+        };
+    },
+    dispose: ({ state: { onTickEvent }, graph: { getDependency } }) => {
+        Assert.mustBeTrue(onTickEvent !== undefined);
+        const lifecycleEventEmitter = getDependency('ILifecycleEventEmitter');
+        if (onTickEvent)
+            lifecycleEventEmitter?.tickEvent.removeListener(onTickEvent);
+        return {};
+    }
+});
+//# sourceMappingURL=LifecycleOnTick.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js.map
new file mode 100644
index 0000000..4f7fbc9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Lifecycle/LifecycleOnTick.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"LifecycleOnTick.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Lifecycle/LifecycleOnTick.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,gCAAgC,CAAC;AACxD,OAAO,EACL,uBAAuB,EACvB,YAAY,EACb,MAAM,mCAAmC,CAAC;AAO3C,MAAM,gBAAgB,GAAG,GAAU,EAAE,CAAC,CAAC;IACrC,WAAW,EAAE,SAAS;CACvB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,eAAe,GAAG,uBAAuB,CAAC;IACrD,QAAQ,EAAE,kBAAkB;IAC5B,KAAK,EAAE,SAAS;IAChB,QAAQ,EAAE,YAAY,CAAC,KAAK;IAC5B,EAAE,EAAE,EAAE;IACN,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;QACZ,YAAY,EAAE,OAAO;KACtB;IACD,YAAY,EAAE,gBAAgB,EAAE;IAChC,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QAC3D,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC;QACnD,IAAI,YAAY,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC9B,MAAM,WAAW,GAAG,GAAG,EAAE;YACvB,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAC/B,MAAM,YAAY,GAAG,CAAC,WAAW,GAAG,YAAY,CAAC,GAAG,KAAK,CAAC;YAC1D,KAAK,CAAC,cAAc,EAAE,YAAY,CAAC,CAAC;YACpC,MAAM,CAAC,MAAM,CAAC,CAAC;YACf,YAAY,GAAG,WAAW,CAAC;QAC7B,CAAC,CAAC;QAEF,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,qBAAqB,EAAE,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAE1D,OAAO;YACL,WAAW;SACZ,CAAC;IACJ,CAAC;IACD,OAAO,EAAE,CAAC,EAAE,KAAK,EAAE,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE,EAAE;QAChE,MAAM,CAAC,UAAU,CAAC,WAAW,KAAK,SAAS,CAAC,CAAC;QAE7C,MAAM,qBAAqB,GAAG,aAAa,CACzC,wBAAwB,CACzB,CAAC;QAEF,IAAI,WAAW;YACb,qBAAqB,EAAE,SAAS,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAE/D,OAAO,EAAE,CAAC;IACZ,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.d.ts
new file mode 100644
index 0000000..e6dadba
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.d.ts
@@ -0,0 +1,17 @@
+export declare const Easing: import("../../../Nodes/NodeDefinitions.js").IFunctionNodeDefinition<{
+    easingFunction: {
+        valueType: string;
+        name: string;
+        defaultValue: string;
+        options: string[];
+    };
+    easingMode: {
+        valueType: string;
+        name: string;
+        defaultValue: string;
+        options: string[];
+    };
+    t: string;
+}, {
+    t: string;
+}, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js
new file mode 100644
index 0000000..2bd35ed
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js
@@ -0,0 +1,33 @@
+import { EasingFunctions, EasingModes } from '../../../Easing.js';
+import { makeFunctionNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+export const Easing = makeFunctionNodeDefinition({
+    typeName: 'math/easing',
+    category: NodeCategory.Logic,
+    label: 'Easing',
+    in: {
+        easingFunction: {
+            valueType: 'string',
+            name: 'easingFunction',
+            defaultValue: 'linear',
+            options: Object.keys(EasingFunctions)
+        },
+        easingMode: {
+            valueType: 'string',
+            name: 'easingMode',
+            defaultValue: 'inOut',
+            options: Object.keys(EasingModes)
+        },
+        t: 'float'
+    },
+    out: {
+        t: 'float'
+    },
+    exec: ({ read, write }) => {
+        const easingFunction = EasingFunctions[read('easingFunction')];
+        const easingMode = EasingModes[read('easingMode')];
+        const easing = easingMode(easingFunction);
+        const inputT = read('t');
+        write('t', easing(inputT));
+    }
+});
+//# sourceMappingURL=Easing.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js.map
new file mode 100644
index 0000000..500b091
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Logic/Easing.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Easing.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Logic/Easing.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,eAAe,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAC;AAClE,OAAO,EACL,0BAA0B,EAC1B,YAAY,EACb,MAAM,mCAAmC,CAAC;AAE3C,MAAM,CAAC,MAAM,MAAM,GAAG,0BAA0B,CAAC;IAC/C,QAAQ,EAAE,aAAa;IACvB,QAAQ,EAAE,YAAY,CAAC,KAAK;IAC5B,KAAK,EAAE,QAAQ;IACf,EAAE,EAAE;QACF,cAAc,EAAE;YACd,SAAS,EAAE,QAAQ;YACnB,IAAI,EAAE,gBAAgB;YACtB,YAAY,EAAE,QAAQ;YACtB,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;SACtC;QACD,UAAU,EAAE;YACV,SAAS,EAAE,QAAQ;YACnB,IAAI,EAAE,YAAY;YAClB,YAAY,EAAE,OAAO;YACrB,OAAO,EAAE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;SAClC;QACD,CAAC,EAAE,OAAO;KACX;IACD,GAAG,EAAE;QACH,CAAC,EAAE,OAAO;KACX;IACD,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE;QACxB,MAAM,cAAc,GAAG,eAAe,CAAC,IAAI,CAAC,gBAAgB,CAAW,CAAC,CAAC;QACzE,MAAM,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC,YAAY,CAAW,CAAC,CAAC;QAC7D,MAAM,MAAM,GAAG,UAAU,CAAC,cAAc,CAAC,CAAC;QAC1C,MAAM,MAAM,GAAG,IAAI,CAAC,GAAG,CAAW,CAAC;QAEnC,KAAK,CAAC,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;IAC7B,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.d.ts
new file mode 100644
index 0000000..e945fbc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.d.ts
@@ -0,0 +1,11 @@
+import { Engine } from '../../../Execution/Engine.js';
+import { IGraph } from '../../../Graphs/Graph.js';
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription, NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+export declare class Delay extends AsyncNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: IGraph);
+    private timeoutPending;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js
new file mode 100644
index 0000000..92d12f7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js
@@ -0,0 +1,39 @@
+import { AsyncNode } from '../../../Nodes/AsyncNode.js';
+import { NodeDescription2 } from '../../../Nodes/Registry/NodeDescription.js';
+import { Socket } from '../../../Sockets/Socket.js';
+// ASYNC - asynchronous evaluation
+// also called "delay"
+class Delay extends AsyncNode {
+    constructor(description, graph) {
+        super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1)], [new Socket('flow', 'flow')]);
+        this.timeoutPending = false;
+    }
+    triggered(engine, triggeringSocketName, finished) {
+        // if there is a valid timeout running, leave it.
+        if (this.timeoutPending) {
+            return;
+        }
+        // otherwise start it.
+        this.timeoutPending = true;
+        setTimeout(() => {
+            // check if cancelled
+            if (!this.timeoutPending)
+                return;
+            this.timeoutPending = false;
+            engine.commitToNewFiber(this, 'flow');
+            finished();
+        }, this.readInput('duration') * 1000);
+    }
+    dispose() {
+        this.timeoutPending = false;
+    }
+}
+Delay.Description = new NodeDescription2({
+    typeName: 'time/delay',
+    otherTypeNames: ['flow/delay'],
+    category: 'Time',
+    label: 'Delay',
+    factory: (description, graph) => new Delay(description, graph)
+});
+export { Delay };
+//# sourceMappingURL=Delay.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js.map
new file mode 100644
index 0000000..51fed4f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/Delay.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Delay.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Time/Delay.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,6BAA6B,CAAC;AACxD,OAAO,EAEL,gBAAgB,EACjB,MAAM,4CAA4C,CAAC;AACpD,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;AAEpD,kCAAkC;AAClC,sBAAsB;AAEtB,MAAa,KAAM,SAAQ,SAAS;IASlC,YAAY,WAA4B,EAAE,KAAa;QACrD,KAAK,CACH,WAAW,EACX,KAAK,EACL,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,IAAI,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,EAChE,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAC7B,CAAC;QAGI,mBAAc,GAAG,KAAK,CAAC;IAF/B,CAAC;IAID,SAAS,CACP,MAAc,EACd,oBAA4B,EAC5B,QAAoB;QAEpB,iDAAiD;QACjD,IAAI,IAAI,CAAC,cAAc,EAAE;YACvB,OAAO;SACR;QAED,sBAAsB;QACtB,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC3B,UAAU,CAAC,GAAG,EAAE;YACd,qBAAqB;YACrB,IAAI,CAAC,IAAI,CAAC,cAAc;gBAAE,OAAO;YACjC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;YAC5B,MAAM,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACtC,QAAQ,EAAE,CAAC;QACb,CAAC,EAAE,IAAI,CAAC,SAAS,CAAS,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,CAAC;IAED,OAAO;QACL,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;IAC9B,CAAC;;AA1Ca,iBAAW,GAAG,IAAI,gBAAgB,CAAC;IAC/C,QAAQ,EAAE,YAAY;IACtB,cAAc,EAAE,CAAC,YAAY,CAAC;IAC9B,QAAQ,EAAE,MAAM;IAChB,KAAK,EAAE,OAAO;IACd,OAAO,EAAE,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC;CAC/D,CAAC,AANuB,CAMtB;SAPQ,KAAK"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.d.ts
new file mode 100644
index 0000000..434ac4d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.d.ts
@@ -0,0 +1 @@
+export declare const Now: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js
new file mode 100644
index 0000000..97d2978
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js
@@ -0,0 +1,9 @@
+import { makeInNOutFunctionDesc } from '../../../Nodes/FunctionNode.js';
+// Unreal Engine Blueprint Time nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Utilities/Time/
+export const Now = makeInNOutFunctionDesc({
+    name: 'time/now',
+    label: 'Now',
+    out: 'float',
+    exec: () => Date.now() / 1000
+});
+//# sourceMappingURL=TimeNodes.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js.map
new file mode 100644
index 0000000..a7a2220
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Time/TimeNodes.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"TimeNodes.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Time/TimeNodes.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,gCAAgC,CAAC;AAExE,4GAA4G;AAE5G,MAAM,CAAC,MAAM,GAAG,GAAG,sBAAsB,CAAC;IACxC,IAAI,EAAE,UAAU;IAChB,KAAK,EAAE,KAAK;IACZ,GAAG,EAAE,OAAO;IACZ,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI;CAC9B,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.d.ts
new file mode 100644
index 0000000..1e02150
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.d.ts
@@ -0,0 +1,7 @@
+export declare const Constant: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const And: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Or: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Not: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const ToFloat: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Equal: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const toInteger: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js
new file mode 100644
index 0000000..2a01249
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js
@@ -0,0 +1,51 @@
+import { makeInNOutFunctionDesc } from '../../../Nodes/FunctionNode.js';
+export const Constant = makeInNOutFunctionDesc({
+    name: 'math/boolean',
+    label: 'Boolean',
+    in: ['boolean'],
+    out: 'boolean',
+    exec: (a) => a
+});
+export const And = makeInNOutFunctionDesc({
+    name: 'math/and/boolean',
+    label: '',
+    in: ['boolean', 'boolean'],
+    out: 'boolean',
+    exec: (a, b) => a && b
+});
+export const Or = makeInNOutFunctionDesc({
+    name: 'math/or/boolean',
+    label: '',
+    in: ['boolean', 'boolean'],
+    out: 'boolean',
+    exec: (a, b) => a || b
+});
+export const Not = makeInNOutFunctionDesc({
+    name: 'math/negate/boolean',
+    label: '',
+    in: ['boolean'],
+    out: 'boolean',
+    exec: (a) => !a
+});
+export const ToFloat = makeInNOutFunctionDesc({
+    name: 'math/toFloat/boolean',
+    label: 'To Float',
+    in: ['boolean'],
+    out: 'float',
+    exec: (a) => (a ? 1 : 0)
+});
+export const Equal = makeInNOutFunctionDesc({
+    name: 'math/equal/boolean',
+    label: '=',
+    in: ['boolean', 'boolean'],
+    out: 'boolean',
+    exec: (a, b) => a === b
+});
+export const toInteger = makeInNOutFunctionDesc({
+    name: 'math/toInteger/boolean',
+    label: 'To Integer',
+    in: ['boolean'],
+    out: 'integer',
+    exec: (a) => (a ? 1n : 0n)
+});
+//# sourceMappingURL=BooleanNodes.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js.map
new file mode 100644
index 0000000..9957588
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanNodes.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"BooleanNodes.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/BooleanNodes.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,gCAAgC,CAAC;AAExE,MAAM,CAAC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;IAC7C,IAAI,EAAE,cAAc;IACpB,KAAK,EAAE,SAAS;IAChB,EAAE,EAAE,CAAC,SAAS,CAAC;IACf,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,EAAE,CAAC,CAAC;CACxB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,GAAG,GAAG,sBAAsB,CAAC;IACxC,IAAI,EAAE,kBAAkB;IACxB,KAAK,EAAE,GAAG;IACV,EAAE,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC;IAC1B,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC;CACzC,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,EAAE,GAAG,sBAAsB,CAAC;IACvC,IAAI,EAAE,iBAAiB;IACvB,KAAK,EAAE,GAAG;IACV,EAAE,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC;IAC1B,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC;CACzC,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,GAAG,GAAG,sBAAsB,CAAC;IACxC,IAAI,EAAE,qBAAqB;IAC3B,KAAK,EAAE,GAAG;IACV,EAAE,EAAE,CAAC,SAAS,CAAC;IACf,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC;CACzB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,OAAO,GAAG,sBAAsB,CAAC;IAC5C,IAAI,EAAE,sBAAsB;IAC5B,KAAK,EAAE,UAAU;IACjB,EAAE,EAAE,CAAC,SAAS,CAAC;IACf,GAAG,EAAE,OAAO;IACZ,IAAI,EAAE,CAAC,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;CAClC,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,KAAK,GAAG,sBAAsB,CAAC;IAC1C,IAAI,EAAE,oBAAoB;IAC1B,KAAK,EAAE,GAAG;IACV,EAAE,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC;IAC1B,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;CAC1C,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,SAAS,GAAG,sBAAsB,CAAC;IAC9C,IAAI,EAAE,wBAAwB;IAC9B,KAAK,EAAE,YAAY;IACnB,EAAE,EAAE,CAAC,SAAS,CAAC;IACf,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;CACpC,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.d.ts
new file mode 100644
index 0000000..a7aa7c9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from '../../../Values/ValueType.js';
+export declare const BooleanValue: ValueType;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js
new file mode 100644
index 0000000..3c6eb54
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js
@@ -0,0 +1,10 @@
+export const BooleanValue = {
+    name: 'boolean',
+    creator: () => false,
+    deserialize: (value) => typeof value === 'string' ? value.toLowerCase() === 'true' : value,
+    serialize: (value) => value,
+    lerp: (start, end, t) => (t < 0.5 ? start : end),
+    equals: (a, b) => a === b,
+    clone: (value) => value
+};
+//# sourceMappingURL=BooleanValue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js.map
new file mode 100644
index 0000000..1e7c2ce
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/BooleanValue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"BooleanValue.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/BooleanValue.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,YAAY,GAAc;IACrC,IAAI,EAAE,SAAS;IACf,OAAO,EAAE,GAAG,EAAE,CAAC,KAAK;IACpB,WAAW,EAAE,CAAC,KAAuB,EAAE,EAAE,CACvC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,KAAK;IACpE,SAAS,EAAE,CAAC,KAAc,EAAE,EAAE,CAAC,KAAK;IACpC,IAAI,EAAE,CAAC,KAAc,EAAE,GAAY,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;IAC1E,MAAM,EAAE,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;IAC3C,KAAK,EAAE,CAAC,KAAc,EAAE,EAAE,CAAC,KAAK;CACjC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.d.ts
new file mode 100644
index 0000000..3499d86
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.d.ts
@@ -0,0 +1,43 @@
+export declare const Constant: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Add: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Subtract: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Negate: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Multiply: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Divide: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Modulus: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Power: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const SquareRoot: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const E: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Exp: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Ln: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Log2: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Log10: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const PI: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Sin: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Asin: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Cos: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Acos: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Tan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const RadiansToDegrees: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const DegreesToRadians: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Atan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Mix: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const ToFloat: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Min: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Max: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Clamp: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Abs: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Sign: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Floor: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Ceil: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Round: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Trunc: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Random: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Equal: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const EqualTolerance: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const GreaterThan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const GreaterThanOrEqual: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const LessThan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const LessThanOrEqual: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const IsNaN: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const IsInf: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js
new file mode 100644
index 0000000..f76c508
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js
@@ -0,0 +1,305 @@
+import { degreesToRadians, equalsTolerance, radiansToDegrees } from '../../../mathUtilities.js';
+import { makeInNOutFunctionDesc } from '../../../Nodes/FunctionNode.js';
+// Unreal Engine Blueprint Float nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Float/
+export const Constant = makeInNOutFunctionDesc({
+    name: 'math/float',
+    label: 'Float',
+    in: ['float'],
+    out: 'float',
+    exec: (a) => a
+});
+export const Add = makeInNOutFunctionDesc({
+    name: 'math/add/float',
+    label: '+',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => a + b
+});
+export const Subtract = makeInNOutFunctionDesc({
+    name: 'math/subtract/float',
+    label: '-',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => a - b
+});
+export const Negate = makeInNOutFunctionDesc({
+    name: 'math/negate/float',
+    label: '-',
+    in: ['float'],
+    out: 'float',
+    exec: (a) => -a
+});
+export const Multiply = makeInNOutFunctionDesc({
+    name: 'math/multiply/float',
+    label: '',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => a * b
+});
+export const Divide = makeInNOutFunctionDesc({
+    name: 'math/divide/float',
+    label: '',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => a / b
+});
+export const Modulus = makeInNOutFunctionDesc({
+    name: 'math/modulus/float',
+    label: 'MOD',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => a % b
+});
+export const Power = makeInNOutFunctionDesc({
+    name: 'math/pow/float',
+    label: 'POW',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: Math.pow
+});
+export const SquareRoot = makeInNOutFunctionDesc({
+    name: 'math/sqrt/float',
+    label: '',
+    in: ['float'],
+    out: 'float',
+    exec: Math.sqrt
+});
+export const E = makeInNOutFunctionDesc({
+    name: 'math/e/float',
+    label: '',
+    out: 'float',
+    exec: () => Math.E
+});
+export const Exp = makeInNOutFunctionDesc({
+    name: 'math/exp/float',
+    label: 'EXP',
+    in: ['float'],
+    out: 'float',
+    exec: Math.exp
+});
+export const Ln = makeInNOutFunctionDesc({
+    name: 'math/ln/float',
+    label: 'LN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.log
+});
+export const Log2 = makeInNOutFunctionDesc({
+    name: 'math/log2/float',
+    label: 'LOG2',
+    in: ['float'],
+    out: 'float',
+    exec: Math.log2
+});
+export const Log10 = makeInNOutFunctionDesc({
+    name: 'math/log10/float',
+    label: 'LOG10',
+    in: ['float'],
+    out: 'float',
+    exec: Math.log10
+});
+export const PI = makeInNOutFunctionDesc({
+    name: 'math/pi/float',
+    label: '',
+    out: 'float',
+    exec: () => Math.PI
+});
+export const Sin = makeInNOutFunctionDesc({
+    name: 'math/sin/float',
+    label: 'SIN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.sin
+});
+export const Asin = makeInNOutFunctionDesc({
+    name: 'math/asin/float',
+    label: 'ASIN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.asin
+});
+export const Cos = makeInNOutFunctionDesc({
+    name: 'math/cos/float',
+    label: 'COS',
+    in: ['float'],
+    out: 'float',
+    exec: Math.cos
+});
+export const Acos = makeInNOutFunctionDesc({
+    name: 'math/acos/float',
+    label: 'ACOS',
+    in: ['float'],
+    out: 'float',
+    exec: Math.acos
+});
+export const Tan = makeInNOutFunctionDesc({
+    name: 'math/tan/float',
+    label: 'TAN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.tan
+});
+export const RadiansToDegrees = makeInNOutFunctionDesc({
+    name: 'math/radiansToDegrees/float',
+    label: 'To Degrees',
+    in: ['float'],
+    out: 'float',
+    exec: radiansToDegrees
+});
+export const DegreesToRadians = makeInNOutFunctionDesc({
+    name: 'math/degreesToRadians/float',
+    label: 'To Radians',
+    in: ['float'],
+    out: 'float',
+    exec: degreesToRadians
+});
+export const Atan = makeInNOutFunctionDesc({
+    name: 'math/atan/float',
+    label: 'ATAN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.atan
+});
+export const Mix = makeInNOutFunctionDesc({
+    name: 'math/mix/float',
+    label: 'MIX',
+    in: ['float', 'float', 'float'],
+    out: 'float',
+    exec: (a, b, t) => {
+        const s = 1 - t;
+        return a * s + b * t;
+    }
+});
+export const ToFloat = makeInNOutFunctionDesc({
+    name: 'math/toFloat/float',
+    label: 'To Float',
+    in: ['float'],
+    out: 'float',
+    exec: (a) => Number(a)
+});
+export const Min = makeInNOutFunctionDesc({
+    name: 'math/min/float',
+    label: 'MIN',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => Math.min(a, b) // TODO: can I jsut pass in Math.min?
+});
+export const Max = makeInNOutFunctionDesc({
+    name: 'math/max/float',
+    label: 'MAX',
+    in: ['float', 'float'],
+    out: 'float',
+    exec: (a, b) => Math.max(a, b) // TODO: can I jsut pass in Math.max?
+});
+export const Clamp = makeInNOutFunctionDesc({
+    name: 'math/clamp/float',
+    label: 'CLAMP',
+    in: ['float', 'float', 'float'],
+    out: 'float',
+    exec: (value, min, max) => value < min ? min : value > max ? max : value
+});
+export const Abs = makeInNOutFunctionDesc({
+    name: 'math/abs/float',
+    label: 'ABS',
+    in: ['float'],
+    out: 'float',
+    exec: Math.abs
+});
+export const Sign = makeInNOutFunctionDesc({
+    name: 'math/sign/float',
+    label: 'SIGN',
+    in: ['float'],
+    out: 'float',
+    exec: Math.sign
+});
+export const Floor = makeInNOutFunctionDesc({
+    name: 'math/floor/float',
+    label: 'FLOOR',
+    in: ['float'],
+    out: 'float',
+    exec: Math.floor
+});
+export const Ceil = makeInNOutFunctionDesc({
+    name: 'math/ceil/float',
+    label: 'CEIL',
+    in: ['float'],
+    out: 'float',
+    exec: Math.ceil
+});
+export const Round = makeInNOutFunctionDesc({
+    name: 'math/round/float',
+    label: 'ROUND',
+    in: ['float'],
+    out: 'float',
+    exec: Math.round
+});
+export const Trunc = makeInNOutFunctionDesc({
+    name: 'math/trunc/float',
+    label: 'TRUNC',
+    in: ['float'],
+    out: 'float',
+    exec: Math.trunc
+});
+export const Random = makeInNOutFunctionDesc({
+    name: 'math/random/float',
+    label: 'RANDOM',
+    out: 'float',
+    exec: Math.random
+});
+export const Equal = makeInNOutFunctionDesc({
+    name: 'math/equal/float',
+    label: '=',
+    in: ['float', 'float'],
+    out: 'boolean',
+    exec: (a, b) => a === b
+});
+export const EqualTolerance = makeInNOutFunctionDesc({
+    name: 'math/equalTolerance/float',
+    label: '=',
+    in: ['float', 'float', 'float'],
+    out: 'boolean',
+    exec: (a, b, tolerance) => equalsTolerance(a, b, tolerance)
+});
+export const GreaterThan = makeInNOutFunctionDesc({
+    name: 'math/greaterThan/float',
+    label: '>',
+    in: ['float', 'float'],
+    out: 'boolean',
+    exec: (a, b) => a > b
+});
+export const GreaterThanOrEqual = makeInNOutFunctionDesc({
+    name: 'math/greaterThanOrEqual/float',
+    label: '',
+    in: ['float', 'float'],
+    out: 'boolean',
+    exec: (a, b) => a >= b
+});
+export const LessThan = makeInNOutFunctionDesc({
+    name: 'math/lessThan/float',
+    label: '<',
+    in: ['float', 'float'],
+    out: 'boolean',
+    exec: (a, b) => a < b
+});
+export const LessThanOrEqual = makeInNOutFunctionDesc({
+    name: 'math/lessThanOrEqual/float',
+    label: '',
+    in: ['float', 'float'],
+    out: 'boolean',
+    exec: (a, b) => a <= b
+});
+export const IsNaN = makeInNOutFunctionDesc({
+    name: 'math/isNaN/float',
+    label: 'isNaN',
+    in: ['float'],
+    out: 'boolean',
+    exec: Number.isNaN
+});
+export const IsInf = makeInNOutFunctionDesc({
+    name: 'math/isInf/float',
+    label: 'isInf',
+    in: ['float'],
+    out: 'boolean',
+    exec: (a) => !Number.isFinite(a) && !Number.isNaN(a)
+});
+//# sourceMappingURL=FloatNodes.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js.map
new file mode 100644
index 0000000..50bd0e5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatNodes.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FloatNodes.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/FloatNodes.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.d.ts
new file mode 100644
index 0000000..de103cf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from '../../../Values/ValueType.js';
+export declare const FloatValue: ValueType;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js
new file mode 100644
index 0000000..5a98ef4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js
@@ -0,0 +1,11 @@
+import { parseSafeFloat } from '../../../parseFloats.js';
+export const FloatValue = {
+    name: 'float',
+    creator: () => 0,
+    deserialize: (value) => typeof value === 'string' ? parseSafeFloat(value, 0) : value,
+    serialize: (value) => value,
+    lerp: (start, end, t) => start * (1 - t) + end * t,
+    equals: (a, b) => a === b,
+    clone: (value) => value
+};
+//# sourceMappingURL=FloatValue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js.map
new file mode 100644
index 0000000..5614bed
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/FloatValue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"FloatValue.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/FloatValue.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,cAAc,EAAE,MAAM,yBAAyB,CAAC;AAGzD,MAAM,CAAC,MAAM,UAAU,GAAc;IACnC,IAAI,EAAE,OAAO;IACb,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC;IAChB,WAAW,EAAE,CAAC,KAAsB,EAAE,EAAE,CACtC,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK;IAC9D,SAAS,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;IACnC,IAAI,EAAE,CAAC,KAAa,EAAE,GAAW,EAAE,CAAS,EAAE,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC;IAC1E,MAAM,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;IACzC,KAAK,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;CAChC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.d.ts
new file mode 100644
index 0000000..1e5f67c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.d.ts
@@ -0,0 +1,19 @@
+export declare const Constant: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Add: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Subtract: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Negate: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Multiply: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Divide: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Modulus: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const ToFloat: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Min: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Max: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Clamp: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Abs: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Sign: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Equal: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const GreaterThan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const GreaterThanOrEqual: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const LessThan: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const LessThanOrEqual: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const toBoolean: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js
new file mode 100644
index 0000000..6476289
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js
@@ -0,0 +1,136 @@
+import { makeInNOutFunctionDesc } from '../../../Nodes/FunctionNode.js';
+// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/
+export const Constant = makeInNOutFunctionDesc({
+    name: 'math/integer',
+    label: 'Integer',
+    in: ['integer'],
+    out: 'integer',
+    exec: (a) => a
+});
+export const Add = makeInNOutFunctionDesc({
+    name: 'math/add/integer',
+    label: '+',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => a + b
+});
+export const Subtract = makeInNOutFunctionDesc({
+    name: 'math/subtract/integer',
+    label: '-',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => a - b
+});
+export const Negate = makeInNOutFunctionDesc({
+    name: 'math/negate/integer',
+    label: '-',
+    in: ['integer'],
+    out: 'integer',
+    exec: (a) => -a
+});
+export const Multiply = makeInNOutFunctionDesc({
+    name: 'math/multiply/integer',
+    label: '',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => a * b
+});
+export const Divide = makeInNOutFunctionDesc({
+    name: 'math/divide/integer',
+    label: '',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => a / b
+});
+export const Modulus = makeInNOutFunctionDesc({
+    name: 'math/modulus/integer',
+    label: 'MOD',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => a % b
+});
+export const ToFloat = makeInNOutFunctionDesc({
+    name: 'math/toFloat/integer',
+    label: 'To Float',
+    in: ['integer'],
+    out: 'float',
+    exec: (a) => Number(a)
+});
+export const Min = makeInNOutFunctionDesc({
+    name: 'math/min/integer',
+    label: 'MIN',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => (a > b ? b : a)
+});
+export const Max = makeInNOutFunctionDesc({
+    name: 'math/max/integer',
+    label: 'MAX',
+    in: ['integer', 'integer'],
+    out: 'integer',
+    exec: (a, b) => (a > b ? a : b)
+});
+export const Clamp = makeInNOutFunctionDesc({
+    name: 'math/clamp/integer',
+    label: 'CLAMP',
+    in: [{ value: 'integer' }, { min: 'integer' }, { max: 'integer' }],
+    out: 'integer',
+    exec: (value, min, max) => value < min ? min : value > max ? max : value
+});
+export const Abs = makeInNOutFunctionDesc({
+    name: 'math/abs/integer',
+    label: 'ABS',
+    in: ['integer'],
+    out: 'integer',
+    exec: (a) => (a < BigInt(0) ? -a : a)
+});
+export const Sign = makeInNOutFunctionDesc({
+    name: 'math/sign/integer',
+    label: 'SIGN',
+    in: ['integer'],
+    out: 'integer',
+    exec: (a) => BigInt(a < 0 ? -1 : a > 0 ? 1 : 0)
+});
+export const Equal = makeInNOutFunctionDesc({
+    name: 'math/equal/integer',
+    label: '=',
+    in: ['integer', 'integer'],
+    out: 'boolean',
+    exec: (a, b) => a === b
+});
+export const GreaterThan = makeInNOutFunctionDesc({
+    name: 'math/greaterThan/integer',
+    label: '>',
+    in: ['integer', 'integer'],
+    out: 'boolean',
+    exec: (a, b) => a > b
+});
+export const GreaterThanOrEqual = makeInNOutFunctionDesc({
+    name: 'math/greaterThanOrEqual/integer',
+    label: '',
+    in: ['integer', 'integer'],
+    out: 'boolean',
+    exec: (a, b) => a >= b
+});
+export const LessThan = makeInNOutFunctionDesc({
+    name: 'math/lessThan/integer',
+    label: '<',
+    in: ['integer', 'integer'],
+    out: 'boolean',
+    exec: (a, b) => a < b
+});
+export const LessThanOrEqual = makeInNOutFunctionDesc({
+    name: 'math/lessThanOrEqual/integer',
+    label: '',
+    in: ['integer', 'integer'],
+    out: 'boolean',
+    exec: (a, b) => a <= b
+});
+export const toBoolean = makeInNOutFunctionDesc({
+    name: 'math/toBoolean/integer',
+    label: 'To Boolean',
+    in: ['integer'],
+    out: 'boolean',
+    exec: (a) => a !== 0n
+});
+//# sourceMappingURL=IntegerNodes.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js.map
new file mode 100644
index 0000000..431611d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerNodes.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"IntegerNodes.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/IntegerNodes.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.d.ts
new file mode 100644
index 0000000..2f20f1f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from '../../../Values/ValueType.js';
+export declare const IntegerValue: ValueType;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js
new file mode 100644
index 0000000..ecc0c5b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js
@@ -0,0 +1,12 @@
+export const IntegerValue = {
+    name: 'integer',
+    creator: () => BigInt(0),
+    deserialize: (value) => BigInt(value),
+    serialize: (value) => Number.MIN_SAFE_INTEGER <= value && value <= Number.MAX_SAFE_INTEGER
+        ? Number(value)
+        : value.toString(),
+    lerp: (start, end, t) => BigInt(Number(start) * (1 - t) + Number(end) * t),
+    equals: (a, b) => a === b,
+    clone: (value) => value
+};
+//# sourceMappingURL=IntegerValue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js.map
new file mode 100644
index 0000000..c258336
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/IntegerValue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"IntegerValue.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/IntegerValue.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,YAAY,GAAc;IACrC,IAAI,EAAE,SAAS;IACf,OAAO,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;IACxB,WAAW,EAAE,CAAC,KAAsB,EAAU,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC;IAC9D,SAAS,EAAE,CAAC,KAAa,EAAE,EAAE,CAC3B,MAAM,CAAC,gBAAgB,IAAI,KAAK,IAAI,KAAK,IAAI,MAAM,CAAC,gBAAgB;QAClE,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;QACf,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE;IAEtB,IAAI,EAAE,CAAC,KAAa,EAAE,GAAW,EAAE,CAAS,EAAE,EAAE,CAC9C,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACnD,MAAM,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;IACzC,KAAK,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;CAChC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.d.ts
new file mode 100644
index 0000000..a7a83ec
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.d.ts
@@ -0,0 +1,5 @@
+export declare const Constant: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Concat: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Includes: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Length: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
+export declare const Equal: import("../../../index.js").IFunctionNodeDefinition<() => import("../../../index.js").SocketsList, () => import("../../../index.js").SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js
new file mode 100644
index 0000000..630c6ee
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js
@@ -0,0 +1,37 @@
+import { makeInNOutFunctionDesc } from '../../../Nodes/FunctionNode.js';
+export const Constant = makeInNOutFunctionDesc({
+    name: 'logic/string',
+    label: 'String',
+    in: ['string'],
+    out: 'string',
+    exec: (a) => a
+});
+export const Concat = makeInNOutFunctionDesc({
+    name: 'logic/concat/string',
+    label: 'Concat',
+    in: ['string', 'string'],
+    out: 'string',
+    exec: (a, b) => a.concat(b)
+});
+export const Includes = makeInNOutFunctionDesc({
+    name: 'logic/includes/string',
+    label: 'Includes',
+    in: ['string', 'string'],
+    out: 'boolean',
+    exec: (a, b) => a.includes(b)
+});
+export const Length = makeInNOutFunctionDesc({
+    name: 'logic/length/string',
+    label: 'Length',
+    in: ['string'],
+    out: 'integer',
+    exec: (a) => BigInt(a.length)
+});
+export const Equal = makeInNOutFunctionDesc({
+    name: 'math/equal/string',
+    label: '=',
+    in: ['string', 'string'],
+    out: 'boolean',
+    exec: (a, b) => a === b
+});
+//# sourceMappingURL=StringNodes.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js.map
new file mode 100644
index 0000000..b30a00a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringNodes.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"StringNodes.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/StringNodes.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,gCAAgC,CAAC;AACxE,MAAM,CAAC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;IAC7C,IAAI,EAAE,cAAc;IACpB,KAAK,EAAE,QAAQ;IACf,EAAE,EAAE,CAAC,QAAQ,CAAC;IACd,GAAG,EAAE,QAAQ;IACb,IAAI,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,CAAC;CACvB,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,MAAM,GAAG,sBAAsB,CAAC;IAC3C,IAAI,EAAE,qBAAqB;IAC3B,KAAK,EAAE,QAAQ;IACf,EAAE,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC;IACxB,GAAG,EAAE,QAAQ;IACb,IAAI,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;CAC5C,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,QAAQ,GAAG,sBAAsB,CAAC;IAC7C,IAAI,EAAE,uBAAuB;IAC7B,KAAK,EAAE,UAAU;IACjB,EAAE,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC;IACxB,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC9C,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,MAAM,GAAG,sBAAsB,CAAC;IAC3C,IAAI,EAAE,qBAAqB;IAC3B,KAAK,EAAE,QAAQ;IACf,EAAE,EAAE,CAAC,QAAQ,CAAC;IACd,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;CACtC,CAAC,CAAC;AAEH,MAAM,CAAC,MAAM,KAAK,GAAG,sBAAsB,CAAC;IAC1C,IAAI,EAAE,mBAAmB;IACzB,KAAK,EAAE,GAAG;IACV,EAAE,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC;IACxB,GAAG,EAAE,SAAS;IACd,IAAI,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;CACxC,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.d.ts
new file mode 100644
index 0000000..ed6cb6e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from '../../../Values/ValueType.js';
+export declare const StringValue: ValueType;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js
new file mode 100644
index 0000000..f5e8fee
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js
@@ -0,0 +1,10 @@
+export const StringValue = {
+    name: 'string',
+    creator: () => '',
+    deserialize: (value) => value,
+    serialize: (value) => value,
+    lerp: (start, end, t) => (t < 0.5 ? start : end),
+    equals: (a, b) => a === b,
+    clone: (value) => value
+};
+//# sourceMappingURL=StringValue.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js.map
new file mode 100644
index 0000000..0d066bd
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Values/StringValue.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"StringValue.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Values/StringValue.ts"],"names":[],"mappings":"AAEA,MAAM,CAAC,MAAM,WAAW,GAAc;IACpC,IAAI,EAAE,QAAQ;IACd,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE;IACjB,WAAW,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;IACrC,SAAS,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;IACnC,IAAI,EAAE,CAAC,KAAa,EAAE,GAAW,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;IACxE,MAAM,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC;IACzC,KAAK,EAAE,CAAC,KAAa,EAAE,EAAE,CAAC,KAAK;CAChC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.d.ts
new file mode 100644
index 0000000..dc246af
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.d.ts
@@ -0,0 +1,2 @@
+import { SocketsList } from '../../../Nodes/NodeDefinitions.js';
+export declare const VariableGet: import("../../../Nodes/NodeDefinitions.js").IFunctionNodeDefinition<{}, (configuration: import("../../../index.js").NodeConfiguration, graph: import("../../../index.js").IGraph) => SocketsList, import("../../../index.js").NodeConfigurationDescription>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js
new file mode 100644
index 0000000..8148bde
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js
@@ -0,0 +1,32 @@
+import { makeFunctionNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+import { Variable } from '../../../Values/Variables/Variable.js';
+export const VariableGet = makeFunctionNodeDefinition({
+    typeName: 'variable/get',
+    category: NodeCategory.Query,
+    label: 'Get',
+    configuration: {
+        variableId: {
+            valueType: 'number'
+        }
+    },
+    in: {},
+    out: (configuration, graph) => {
+        const variable = graph.variables[configuration.variableId] ||
+            new Variable('-1', 'undefined', 'string', '');
+        const result = [
+            {
+                key: 'value',
+                valueType: variable.valueTypeName,
+                label: variable.name
+            }
+        ];
+        return result;
+    },
+    exec: ({ write, graph: { variables }, configuration }) => {
+        const variable = variables[configuration.variableId];
+        if (!variable)
+            return;
+        write('value', variable.get());
+    }
+});
+//# sourceMappingURL=VariableGet.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js.map
new file mode 100644
index 0000000..7ffae51
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableGet.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"VariableGet.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Variables/VariableGet.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,0BAA0B,EAC1B,YAAY,EAEb,MAAM,mCAAmC,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,uCAAuC,CAAC;AAEjE,MAAM,CAAC,MAAM,WAAW,GAAG,0BAA0B,CAAC;IACpD,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,YAAY,CAAC,KAAK;IAC5B,KAAK,EAAE,KAAK;IACZ,aAAa,EAAE;QACb,UAAU,EAAE;YACV,SAAS,EAAE,QAAQ;SACpB;KACF;IACD,EAAE,EAAE,EAAE;IACN,GAAG,EAAE,CAAC,aAAa,EAAE,KAAK,EAAE,EAAE;QAC5B,MAAM,QAAQ,GACZ,KAAK,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC;YACzC,IAAI,QAAQ,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;QAEhD,MAAM,MAAM,GAAgB;YAC1B;gBACE,GAAG,EAAE,OAAO;gBACZ,SAAS,EAAE,QAAQ,CAAC,aAAa;gBACjC,KAAK,EAAE,QAAQ,CAAC,IAAI;aACrB;SACF,CAAC;QAEF,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,SAAS,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE;QACvD,MAAM,QAAQ,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAErD,IAAI,CAAC,QAAQ;YAAE,OAAO;QAEtB,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;IACjC,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.d.ts
new file mode 100644
index 0000000..6ea857d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.d.ts
@@ -0,0 +1,8 @@
+import { SocketsList } from '../../../Nodes/NodeDefinitions.js';
+export declare const VariableSet: import("../../../Nodes/NodeDefinitions.js").IFlowNodeDefinition<(configuration: import("../../../index.js").NodeConfiguration, graph: import("../../../index.js").IGraph) => SocketsList, {
+    flow: string;
+}, {
+    variableId: {
+        valueType: string;
+    };
+}, undefined>;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js
new file mode 100644
index 0000000..ef30923
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js
@@ -0,0 +1,38 @@
+import { makeFlowNodeDefinition, NodeCategory } from '../../../Nodes/NodeDefinitions.js';
+import { Variable } from '../../../Values/Variables/Variable.js';
+export const VariableSet = makeFlowNodeDefinition({
+    typeName: 'variable/set',
+    category: NodeCategory.Action,
+    label: 'Set',
+    configuration: {
+        variableId: {
+            valueType: 'number'
+        }
+    },
+    in: (configuration, graph) => {
+        const variable = graph.variables[configuration.variableId] ||
+            new Variable('-1', 'undefined', 'string', '');
+        const sockets = [
+            {
+                key: 'flow',
+                valueType: 'flow'
+            },
+            {
+                key: 'value',
+                valueType: variable.valueTypeName,
+                label: variable.name
+            }
+        ];
+        return sockets;
+    },
+    initialState: undefined,
+    out: { flow: 'flow' },
+    triggered: ({ read, commit, graph: { variables }, configuration }) => {
+        const variable = variables[configuration.variableId];
+        if (!variable)
+            return;
+        variable.set(read('value'));
+        commit('flow');
+    }
+});
+//# sourceMappingURL=VariableSet.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js.map
new file mode 100644
index 0000000..74d2700
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/Variables/VariableSet.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"VariableSet.js","sourceRoot":"","sources":["../../../../src/Profiles/Core/Variables/VariableSet.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,sBAAsB,EACtB,YAAY,EAEb,MAAM,mCAAmC,CAAC;AAC3C,OAAO,EAAE,QAAQ,EAAE,MAAM,uCAAuC,CAAC;AAEjE,MAAM,CAAC,MAAM,WAAW,GAAG,sBAAsB,CAAC;IAChD,QAAQ,EAAE,cAAc;IACxB,QAAQ,EAAE,YAAY,CAAC,MAAM;IAC7B,KAAK,EAAE,KAAK;IACZ,aAAa,EAAE;QACb,UAAU,EAAE;YACV,SAAS,EAAE,QAAQ;SACpB;KACF;IACD,EAAE,EAAE,CAAC,aAAa,EAAE,KAAK,EAAE,EAAE;QAC3B,MAAM,QAAQ,GACZ,KAAK,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC;YACzC,IAAI,QAAQ,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,EAAE,CAAC,CAAC;QAEhD,MAAM,OAAO,GAAgB;YAC3B;gBACE,GAAG,EAAE,MAAM;gBACX,SAAS,EAAE,MAAM;aAClB;YACD;gBACE,GAAG,EAAE,OAAO;gBACZ,SAAS,EAAE,QAAQ,CAAC,aAAa;gBACjC,KAAK,EAAE,QAAQ,CAAC,IAAI;aACrB;SACF,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IACD,YAAY,EAAE,SAAS;IACvB,GAAG,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE;IACrB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,EAAE,SAAS,EAAE,EAAE,aAAa,EAAE,EAAE,EAAE;QACnE,MAAM,QAAQ,GAAG,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAErD,IAAI,CAAC,QAAQ;YAAE,OAAO;QAEtB,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,MAAM,CAAC,CAAC;IACjB,CAAC;CACF,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.d.ts b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.d.ts
new file mode 100644
index 0000000..7bf114e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.d.ts
@@ -0,0 +1,6 @@
+import { NodeDefinition } from '../../Nodes/Registry/NodeDefinitionsMap.js';
+import { IRegistry } from '../../Registry.js';
+import { ValueTypeMap } from '../../Values/ValueTypeMap.js';
+export declare const getCoreValuesMap: () => ValueTypeMap;
+export declare const getCoreNodesMap: () => Record<string, NodeDefinition>;
+export declare const registerCoreProfile: (registry: IRegistry) => IRegistry;
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js
new file mode 100644
index 0000000..cc7a535
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js
@@ -0,0 +1,102 @@
+/* eslint-disable max-len */
+import { memo } from '../../memo.js';
+import { getNodeDescriptions } from '../../Nodes/Registry/NodeDescription.js';
+import { getStringConversionsForValueType } from '../registerSerializersForValueType.js';
+import { OnCustomEvent } from './CustomEvents/OnCustomEvent.js';
+import { TriggerCustomEvent } from './CustomEvents/TriggerCustomEvent.js';
+import { ExpectTrue as AssertExpectTrue } from './Debug/AssertExpectTrue.js';
+import { Log as DebugLog } from './Debug/DebugLog.js';
+import { Branch } from './Flow/Branch.js';
+import { Counter } from './Flow/Counter.js';
+import { Debounce } from './Flow/Debounce.js';
+import { DoN } from './Flow/DoN.js';
+import { DoOnce } from './Flow/DoOnce.js';
+import { FlipFlop } from './Flow/FlipFlop.js';
+import { ForLoop } from './Flow/ForLoop.js';
+import { Gate } from './Flow/Gate.js';
+import { MultiGate } from './Flow/MultiGate.js';
+import { Sequence } from './Flow/Sequence.js';
+import { SwitchOnInteger } from './Flow/SwitchOnInteger.js';
+import { SwitchOnString } from './Flow/SwitchOnString.js';
+import { Throttle } from './Flow/Throttle.js';
+import { WaitAll } from './Flow/WaitAll.js';
+import { LifecycleOnEnd } from './Lifecycle/LifecycleOnEnd.js';
+import { LifecycleOnStart } from './Lifecycle/LifecycleOnStart.js';
+import { LifecycleOnTick } from './Lifecycle/LifecycleOnTick.js';
+import { Easing } from './Logic/Easing.js';
+import { Delay } from './Time/Delay.js';
+import * as TimeNodes from './Time/TimeNodes.js';
+import * as BooleanNodes from './Values/BooleanNodes.js';
+import { BooleanValue } from './Values/BooleanValue.js';
+import * as FloatNodes from './Values/FloatNodes.js';
+import { FloatValue } from './Values/FloatValue.js';
+import * as IntegerNodes from './Values/IntegerNodes.js';
+import { IntegerValue } from './Values/IntegerValue.js';
+import * as StringNodes from './Values/StringNodes.js';
+import { StringValue } from './Values/StringValue.js';
+import { VariableGet } from './Variables/VariableGet.js';
+import { VariableSet } from './Variables/VariableSet.js';
+export const getCoreValuesMap = memo(() => {
+    const valueTypes = [BooleanValue, StringValue, IntegerValue, FloatValue];
+    return Object.fromEntries(valueTypes.map((valueType) => [valueType.name, valueType]));
+});
+function getCoreStringConversions(values) {
+    return Object.keys(getCoreValuesMap())
+        .filter((name) => name !== 'string')
+        .flatMap((valueTypeName) => getStringConversionsForValueType({ values, valueTypeName }));
+}
+export const getCoreNodesMap = memo(() => {
+    const nodeDefinitions = [
+        ...getNodeDescriptions(StringNodes),
+        ...getNodeDescriptions(BooleanNodes),
+        ...getNodeDescriptions(IntegerNodes),
+        ...getNodeDescriptions(FloatNodes),
+        // custom events
+        OnCustomEvent.Description,
+        TriggerCustomEvent.Description,
+        // variables
+        VariableGet,
+        VariableSet,
+        // complex logic
+        Easing,
+        // actions
+        DebugLog,
+        AssertExpectTrue,
+        // events
+        LifecycleOnStart,
+        LifecycleOnEnd,
+        LifecycleOnTick,
+        // time
+        Delay.Description,
+        ...getNodeDescriptions(TimeNodes),
+        // flow control
+        Branch,
+        FlipFlop,
+        ForLoop,
+        Sequence,
+        SwitchOnInteger,
+        SwitchOnString,
+        Debounce.Description,
+        Throttle.Description,
+        DoN,
+        DoOnce,
+        Gate,
+        MultiGate,
+        WaitAll.Description,
+        Counter,
+        ...getCoreStringConversions(getCoreValuesMap())
+    ];
+    return Object.fromEntries(nodeDefinitions.map((nodeDefinition) => [
+        nodeDefinition.typeName,
+        nodeDefinition
+    ]));
+});
+export const registerCoreProfile = (registry) => {
+    const values = { ...registry.values, ...getCoreValuesMap() };
+    return {
+        values,
+        nodes: { ...registry.nodes, ...getCoreNodesMap() },
+        dependencies: { ...registry.dependencies }
+    };
+};
+//# sourceMappingURL=registerCoreProfile.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js.map b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js.map
new file mode 100644
index 0000000..8c1dc6e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/Core/registerCoreProfile.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"registerCoreProfile.js","sourceRoot":"","sources":["../../../src/Profiles/Core/registerCoreProfile.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.d.ts b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.d.ts
new file mode 100644
index 0000000..e98d820
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.d.ts
@@ -0,0 +1,5 @@
+import { ValueTypeMap } from '../Values/ValueTypeMap.js';
+export declare function getStringConversionsForValueType({ values, valueTypeName }: {
+    values: ValueTypeMap;
+    valueTypeName: string;
+}): import("../index.js").IFunctionNodeDefinition<() => import("../index.js").SocketsList, () => import("../index.js").SocketsList, import("../index.js").NodeConfigurationDescription>[];
diff --git a/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js
new file mode 100644
index 0000000..03f89e0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js
@@ -0,0 +1,22 @@
+import { makeInNOutFunctionDesc } from '../Nodes/FunctionNode.js';
+import { toCamelCase } from '../toCamelCase.js';
+export function getStringConversionsForValueType({ values, valueTypeName }) {
+    const camelCaseValueTypeName = toCamelCase(valueTypeName);
+    return [
+        makeInNOutFunctionDesc({
+            name: `math/to${camelCaseValueTypeName}/string`,
+            label: `To ${camelCaseValueTypeName}`,
+            in: ['string'],
+            out: valueTypeName,
+            exec: (a) => values[valueTypeName]?.deserialize(a)
+        }),
+        makeInNOutFunctionDesc({
+            name: `math/toString/${valueTypeName}`,
+            label: 'To String',
+            in: [valueTypeName],
+            out: 'string',
+            exec: (a) => `${values[valueTypeName]?.serialize(a)}`
+        })
+    ];
+}
+//# sourceMappingURL=registerSerializersForValueType.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js.map b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js.map
new file mode 100644
index 0000000..f879f1c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Profiles/registerSerializersForValueType.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"registerSerializersForValueType.js","sourceRoot":"","sources":["../../src/Profiles/registerSerializersForValueType.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,sBAAsB,EAAE,MAAM,0BAA0B,CAAC;AAClE,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAGhD,MAAM,UAAU,gCAAgC,CAAC,EAC/C,MAAM,EACN,aAAa,EAId;IACC,MAAM,sBAAsB,GAAG,WAAW,CAAC,aAAa,CAAC,CAAC;IAC1D,OAAO;QACL,sBAAsB,CAAC;YACrB,IAAI,EAAE,UAAU,sBAAsB,SAAS;YAC/C,KAAK,EAAE,MAAM,sBAAsB,EAAE;YACrC,EAAE,EAAE,CAAC,QAAQ,CAAC;YACd,GAAG,EAAE,aAAa;YAClB,IAAI,EAAE,CAAC,CAAS,EAAE,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC;SAC3D,CAAC;QACF,sBAAsB,CAAC;YACrB,IAAI,EAAE,iBAAiB,aAAa,EAAE;YACtC,KAAK,EAAE,WAAW;YAClB,EAAE,EAAE,CAAC,aAAa,CAAC;YACnB,GAAG,EAAE,QAAQ;YACb,IAAI,EAAE,CAAC,CAAM,EAAE,EAAE,CAAC,GAAG,MAAM,CAAC,aAAa,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE;SAC3D,CAAC;KACH,CAAC;AACJ,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Registry.d.ts b/node_modules/@behave-graph/core/dist/Registry.d.ts
new file mode 100644
index 0000000..8f9b1f8
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Registry.d.ts
@@ -0,0 +1,13 @@
+import { NodeDefinitionsMap } from './Nodes/Registry/NodeDefinitionsMap.js';
+import { ValueTypeMap } from './Values/ValueTypeMap.js';
+export interface IRegistry {
+    readonly values: ValueTypeMap;
+    readonly nodes: NodeDefinitionsMap;
+    readonly dependencies: Record<string, unknown>;
+}
+export interface IQueryableRegistry<T> {
+    get: (id: string) => T | undefined;
+    getAll: () => T[];
+    getAllNames: () => string[];
+    contains: (id: string) => boolean;
+}
diff --git a/node_modules/@behave-graph/core/dist/Registry.js b/node_modules/@behave-graph/core/dist/Registry.js
new file mode 100644
index 0000000..6d26946
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Registry.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=Registry.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Registry.js.map b/node_modules/@behave-graph/core/dist/Registry.js.map
new file mode 100644
index 0000000..40bc649
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Registry.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Registry.js","sourceRoot":"","sources":["../src/Registry.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Sockets/Socket.d.ts b/node_modules/@behave-graph/core/dist/Sockets/Socket.d.ts
new file mode 100644
index 0000000..ad9c71e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Sockets/Socket.d.ts
@@ -0,0 +1,14 @@
+import { Link } from '../Nodes/Link.js';
+export type Choices = string[] | {
+    text: string;
+    value: any;
+}[];
+export declare class Socket {
+    readonly valueTypeName: string;
+    readonly name: string;
+    value: any | undefined;
+    readonly label: string | undefined;
+    readonly valueChoices?: Choices | undefined;
+    readonly links: Link[];
+    constructor(valueTypeName: string, name: string, value?: any | undefined, label?: string | undefined, valueChoices?: Choices | undefined);
+}
diff --git a/node_modules/@behave-graph/core/dist/Sockets/Socket.js b/node_modules/@behave-graph/core/dist/Sockets/Socket.js
new file mode 100644
index 0000000..53128f1
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Sockets/Socket.js
@@ -0,0 +1,12 @@
+export class Socket {
+    constructor(valueTypeName, name, value = undefined, label = undefined, valueChoices // if not empty, value must be one of these.
+    ) {
+        this.valueTypeName = valueTypeName;
+        this.name = name;
+        this.value = value;
+        this.label = label;
+        this.valueChoices = valueChoices;
+        this.links = [];
+    }
+}
+//# sourceMappingURL=Socket.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Sockets/Socket.js.map b/node_modules/@behave-graph/core/dist/Sockets/Socket.js.map
new file mode 100644
index 0000000..3c35901
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Sockets/Socket.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Socket.js","sourceRoot":"","sources":["../../src/Sockets/Socket.ts"],"names":[],"mappings":"AAIA,MAAM,OAAO,MAAM;IAGjB,YACkB,aAAqB,EACrB,IAAY,EACrB,QAAyB,SAAS,EACzB,QAA4B,SAAS,EACrC,YAAsB,CAAC,4CAA4C;;QAJnE,kBAAa,GAAb,aAAa,CAAQ;QACrB,SAAI,GAAJ,IAAI,CAAQ;QACrB,UAAK,GAAL,KAAK,CAA6B;QACzB,UAAK,GAAL,KAAK,CAAgC;QACrC,iBAAY,GAAZ,YAAY,CAAU;QAPxB,UAAK,GAAW,EAAE,CAAC;IAQhC,CAAC;CACL"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.d.ts b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.d.ts
new file mode 100644
index 0000000..5d37832
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.d.ts
@@ -0,0 +1,2 @@
+import { ValueTypeMap } from '../ValueTypeMap.js';
+export declare function validateValueRegistry(values: ValueTypeMap): string[];
diff --git a/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js
new file mode 100644
index 0000000..236b646
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js
@@ -0,0 +1,24 @@
+const valueTypeNameRegex = /^\w+$/;
+export function validateValueRegistry(values) {
+    const errorList = [];
+    Object.keys(values).forEach((valueTypeName) => {
+        if (!valueTypeNameRegex.test(valueTypeName)) {
+            errorList.push(`invalid value type name ${valueTypeName}`);
+        }
+        const valueType = values[valueTypeName];
+        const value = valueType?.creator();
+        const serializedValue = valueType?.serialize(value);
+        const deserializedValue = valueType?.deserialize(serializedValue);
+        const reserializedValue = valueType?.serialize(deserializedValue);
+        const redeserializedValue = valueType?.deserialize(reserializedValue);
+        if (JSON.stringify(serializedValue) !== JSON.stringify(reserializedValue)) {
+            errorList.push(`value type (${valueTypeName}) reserialization mismatch between ${JSON.stringify(serializedValue)} and ${JSON.stringify(reserializedValue)}`);
+        }
+        if (typeof deserializedValue !== 'bigint' &&
+            JSON.stringify(deserializedValue) !== JSON.stringify(redeserializedValue)) {
+            errorList.push(`value type (${valueTypeName}) redeserialization mismatch between ${JSON.stringify(deserializedValue)} and ${JSON.stringify(redeserializedValue)}`);
+        }
+    });
+    return errorList;
+}
+//# sourceMappingURL=validateValueRegistry.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js.map b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js.map
new file mode 100644
index 0000000..edb49a2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Validation/validateValueRegistry.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateValueRegistry.js","sourceRoot":"","sources":["../../../src/Values/Validation/validateValueRegistry.ts"],"names":[],"mappings":"AAEA,MAAM,kBAAkB,GAAG,OAAO,CAAC;AAEnC,MAAM,UAAU,qBAAqB,CAAC,MAAoB;IACxD,MAAM,SAAS,GAAa,EAAE,CAAC;IAE/B,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,aAAa,EAAE,EAAE;QAC5C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;YAC3C,SAAS,CAAC,IAAI,CAAC,2BAA2B,aAAa,EAAE,CAAC,CAAC;SAC5D;QAED,MAAM,SAAS,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;QAExC,MAAM,KAAK,GAAG,SAAS,EAAE,OAAO,EAAE,CAAC;QACnC,MAAM,eAAe,GAAG,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;QACpD,MAAM,iBAAiB,GAAG,SAAS,EAAE,WAAW,CAAC,eAAe,CAAC,CAAC;QAClE,MAAM,iBAAiB,GAAG,SAAS,EAAE,SAAS,CAAC,iBAAiB,CAAC,CAAC;QAClE,MAAM,mBAAmB,GAAG,SAAS,EAAE,WAAW,CAAC,iBAAiB,CAAC,CAAC;QAEtE,IAAI,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,EAAE;YACzE,SAAS,CAAC,IAAI,CACZ,eAAe,aAAa,sCAAsC,IAAI,CAAC,SAAS,CAC9E,eAAe,CAChB,QAAQ,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,EAAE,CAC7C,CAAC;SACH;QAED,IACE,OAAO,iBAAiB,KAAK,QAAQ;YACrC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,EACzE;YACA,SAAS,CAAC,IAAI,CACZ,eAAe,aAAa,wCAAwC,IAAI,CAAC,SAAS,CAChF,iBAAiB,CAClB,QAAQ,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,EAAE,CAC/C,CAAC;SACH;IACH,CAAC,CAAC,CAAC;IACH,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueType.d.ts b/node_modules/@behave-graph/core/dist/Values/ValueType.d.ts
new file mode 100644
index 0000000..1f8c963
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueType.d.ts
@@ -0,0 +1,9 @@
+export interface ValueType<TValue = any, TJson = any> {
+    name: string;
+    creator: () => TValue;
+    deserialize: (value: TJson) => TValue;
+    serialize: (value: TValue) => TJson;
+    lerp: (start: TValue, end: TValue, t: number) => TValue;
+    equals: (a: TValue, b: TValue) => boolean;
+    clone: (value: TValue) => TValue;
+}
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueType.js b/node_modules/@behave-graph/core/dist/Values/ValueType.js
new file mode 100644
index 0000000..dd85c72
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueType.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=ValueType.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueType.js.map b/node_modules/@behave-graph/core/dist/Values/ValueType.js.map
new file mode 100644
index 0000000..fdd2e18
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueType.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ValueType.js","sourceRoot":"","sources":["../../src/Values/ValueType.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.d.ts b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.d.ts
new file mode 100644
index 0000000..11bf63b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.d.ts
@@ -0,0 +1,4 @@
+import { ValueType } from './ValueType.js';
+export type ValueTypeMap = {
+    readonly [key: string]: ValueType;
+};
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js
new file mode 100644
index 0000000..d96ff6c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js
@@ -0,0 +1,2 @@
+export {};
+//# sourceMappingURL=ValueTypeMap.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js.map b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js.map
new file mode 100644
index 0000000..60bbc23
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/ValueTypeMap.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"ValueTypeMap.js","sourceRoot":"","sources":["../../src/Values/ValueTypeMap.ts"],"names":[],"mappings":""}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/Variables/Variable.d.ts b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.d.ts
new file mode 100644
index 0000000..364f148
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.d.ts
@@ -0,0 +1,16 @@
+import { EventEmitter } from '../../Events/EventEmitter.js';
+import { Metadata } from '../../Metadata.js';
+export declare class Variable {
+    readonly id: string;
+    readonly name: string;
+    readonly valueTypeName: string;
+    initialValue: any;
+    private value;
+    label: string;
+    metadata: Metadata;
+    version: number;
+    readonly onChanged: EventEmitter<Variable>;
+    constructor(id: string, name: string, valueTypeName: string, initialValue: any);
+    get(): any;
+    set(newValue: any): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js
new file mode 100644
index 0000000..2f69b32
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js
@@ -0,0 +1,26 @@
+import { EventEmitter } from '../../Events/EventEmitter.js';
+export class Variable {
+    constructor(id, name, valueTypeName, initialValue // this is assumed to be properly deseriealized from a string.
+    ) {
+        this.id = id;
+        this.name = name;
+        this.valueTypeName = valueTypeName;
+        this.initialValue = initialValue;
+        this.label = '';
+        this.metadata = {};
+        this.version = 0; // this is updated on each change to the variable state.
+        this.onChanged = new EventEmitter();
+        this.value = this.initialValue;
+    }
+    get() {
+        return this.value;
+    }
+    set(newValue) {
+        if (newValue !== this.value) {
+            this.value = newValue;
+            this.version++;
+            this.onChanged.emit(this);
+        }
+    }
+}
+//# sourceMappingURL=Variable.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js.map b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js.map
new file mode 100644
index 0000000..e263c80
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/Values/Variables/Variable.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Variable.js","sourceRoot":"","sources":["../../../src/Values/Variables/Variable.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,8BAA8B,CAAC;AAG5D,MAAM,OAAO,QAAQ;IAOnB,YACkB,EAAU,EACV,IAAY,EACZ,aAAqB,EAC9B,YAAiB,CAAC,8DAA8D;;QAHvE,OAAE,GAAF,EAAE,CAAQ;QACV,SAAI,GAAJ,IAAI,CAAQ;QACZ,kBAAa,GAAb,aAAa,CAAQ;QAC9B,iBAAY,GAAZ,YAAY,CAAK;QATnB,UAAK,GAAG,EAAE,CAAC;QACX,aAAQ,GAAa,EAAE,CAAC;QACxB,YAAO,GAAG,CAAC,CAAC,CAAC,wDAAwD;QAC5D,cAAS,GAAG,IAAI,YAAY,EAAY,CAAC;QAQvD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC;IACjC,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,GAAG,CAAC,QAAa;QACf,IAAI,QAAQ,KAAK,IAAI,CAAC,KAAK,EAAE;YAC3B,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;YACtB,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC3B;IACH,CAAC;CACF"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts
new file mode 100644
index 0000000..020a6a0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts
@@ -0,0 +1,2 @@
+export * from "./declarations/src/index";
+//# sourceMappingURL=behave-graph-core.cjs.d.ts.map
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts.map b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts.map
new file mode 100644
index 0000000..f9317e9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"behave-graph-core.cjs.d.ts","sourceRoot":"","sources":["./declarations/src/index.d.ts"],"names":[],"mappings":"AAAA"}
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.dev.js b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.dev.js
new file mode 100644
index 0000000..72f5582
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.dev.js
@@ -0,0 +1,4171 @@
+'use strict';
+
+Object.defineProperty(exports, '__esModule', { value: true });
+
+function _toPrimitive(input, hint) {
+  if (typeof input !== "object" || input === null) return input;
+  var prim = input[Symbol.toPrimitive];
+  if (prim !== undefined) {
+    var res = prim.call(input, hint || "default");
+    if (typeof res !== "object") return res;
+    throw new TypeError("@@toPrimitive must return a primitive value.");
+  }
+  return (hint === "string" ? String : Number)(input);
+}
+
+function _toPropertyKey(arg) {
+  var key = _toPrimitive(arg, "string");
+  return typeof key === "symbol" ? key : String(key);
+}
+
+function _defineProperty(obj, key, value) {
+  key = _toPropertyKey(key);
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+  return obj;
+}
+
+class EventEmitter {
+  constructor() {
+    _defineProperty(this, "listeners", []);
+  }
+  addListener(listener) {
+    this.listeners.push(listener);
+  }
+  removeListener(listener) {
+    this.listeners.splice(this.listeners.indexOf(listener), 1);
+  }
+  clear() {
+    this.listeners.splice(0, this.listeners.length);
+  }
+  emit(event) {
+    if (this.listeners.length === 0) return;
+    // copy array before emitting event to ensure even if listener array is modified, everyone listening initially gets the event.
+    // inspired by mrdoob's EventDispatcher
+    this.listeners.slice(0).forEach(listener => {
+      listener(event);
+    });
+  }
+  get listenerCount() {
+    return this.listeners.length;
+  }
+}
+
+var _class$o;
+class Logger {
+  static verbose(text) {
+    this.onVerbose.emit(text);
+  }
+  static info(text) {
+    this.onInfo.emit(text);
+  }
+  static warn(text) {
+    this.onWarn.emit(text);
+  }
+  static error(text) {
+    this.onError.emit(text);
+  }
+}
+_class$o = Logger;
+_defineProperty(Logger, "onVerbose", new EventEmitter());
+_defineProperty(Logger, "onInfo", new EventEmitter());
+_defineProperty(Logger, "onWarn", new EventEmitter());
+_defineProperty(Logger, "onError", new EventEmitter());
+(() => {
+  const prefix = () => {
+    return new Date().toLocaleTimeString().padStart(11, '0');
+  };
+  _class$o.onVerbose.addListener(text => {
+    console.log(prefix() + ` VERB:  ${text}`);
+  });
+  _class$o.onInfo.addListener(text => {
+    console.log(prefix() + ` INFO:  ${text}`);
+  });
+  _class$o.onWarn.addListener(text => {
+    console.warn(prefix() + ` WARN:  ${text}`);
+  });
+  _class$o.onError.addListener(text => {
+    console.error(prefix() + ` ERR:  ${text}`);
+  });
+})();
+
+class Assert {
+  static mustBeTrue(condition, msg = '') {
+    if (!condition) {
+      throw new Error(`failed assertion: ${msg}`);
+    }
+  }
+  static mustBeDefined(variable, msg = '') {
+    if (variable === undefined) {
+      throw new Error(`failed assertion: variable must be defined ${msg}`);
+    }
+  }
+}
+
+/* eslint-disable no-mixed-operators */
+/* eslint-disable no-bitwise */
+
+// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
+const lut = [];
+for (let i = 0; i < 256; i++) {
+  lut[i] = (i < 16 ? '0' : '') + i.toString(16);
+}
+function generateUuid() {
+  const d0 = Math.random() * 0xffffffff | 0;
+  const d1 = Math.random() * 0xffffffff | 0;
+  const d2 = Math.random() * 0xffffffff | 0;
+  const d3 = Math.random() * 0xffffffff | 0;
+  const uuid = `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;
+
+  // .toUpperCase() here flattens concatenated strings to save heap memory space.
+  return uuid.toUpperCase();
+}
+
+// Purpose:
+//  - stores the node graph
+class Graph {
+  constructor(registry) {
+    _defineProperty(this, "name", '');
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "nodes", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "variables", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "customEvents", {});
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    this.registry = registry;
+  }
+  createNode(nodeTypeName, nodeId = generateUuid(), nodeConfiguration = {}) {
+    if (nodeId in this.nodes) {
+      throw new Error(`can not create new node of type ${nodeTypeName} with id ${nodeId} as one with that id already exists.`);
+    }
+    let nodeDescription = undefined;
+    if (this.registry.nodes.contains(nodeTypeName)) {
+      nodeDescription = this.registry.nodes.get(nodeTypeName);
+    }
+    if (nodeDescription === undefined) {
+      throw new Error(`no registered node descriptions with the typeName ${nodeTypeName}`);
+    }
+    const node = nodeDescription.factory(nodeDescription, this, nodeConfiguration);
+    node.id = nodeId;
+    this.nodes[nodeId] = node;
+    node.inputs.forEach(socket => {
+      if (socket.valueTypeName !== 'flow' && socket.value === undefined) {
+        socket.value = this.registry.values.get(socket.valueTypeName).creator();
+      }
+    });
+    return node;
+  }
+}
+
+class Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    _defineProperty(this, "id", '');
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    this.description = description;
+    this.graph = graph;
+    this.inputs = inputs;
+    this.outputs = outputs;
+    this.configuration = configuration;
+  }
+
+  // TODO: this may want to cache the values on the creation of the NodeEvalContext
+  // for re-entrant async operations, otherwise the inputs may change during operation.
+  readInput(inputName) {
+    const inputSocket = this.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`can not find input socket with name ${inputName} on node of type ${this.description.typeName}`);
+    }
+    return inputSocket.value;
+  }
+  writeOutput(outputName, value) {
+    const outputSocket = this.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find output socket with name ${outputSocket} on node of type ${this.description.typeName}`);
+    }
+    if (outputSocket.valueTypeName === 'flow') {
+      throw new Error(`can not set the value of Flow output socket ${outputName}, use commit() instead`);
+    }
+    outputSocket.value = value;
+  }
+}
+
+// async flow node with only a single flow input
+class AsyncNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(engine, triggeringSocketName, finished) {
+    throw new Error('not implemented');
+  }
+  dispose() {
+    throw new Error('not implemented');
+  }
+}
+class AsyncNode2 extends AsyncNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs);
+  }
+}
+
+// no flow inputs, always evaluated on startup
+class EventNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // no input flow sockets allowed.
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  init(engine) {
+    throw new Error('not implemented');
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  dispose(engine) {
+    throw new Error('not implemented');
+  }
+}
+class EventNode2 extends EventNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class FlowNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    // determine if this is an eval node
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(fiber, triggeringSocketName) {
+    throw new Error('not implemented');
+  }
+}
+class FlowNode2 extends FlowNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class ImmediateNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], exec, configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have no input flow sockets
+    this.exec = exec;
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have no output flow sockets
+    Assert.mustBeTrue(!this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+}
+class ImmediateNode2 extends ImmediateNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.exec);
+  }
+}
+
+class Link {
+  constructor(nodeId = '', socketName = '') {
+    _defineProperty(this, "_targetNode", undefined);
+    _defineProperty(this, "_targetSocket", undefined);
+    this.nodeId = nodeId;
+    this.socketName = socketName;
+  }
+}
+
+class ValueType {
+  constructor(name, creator, deserialize, serialize, lerp) {
+    this.name = name;
+    this.creator = creator;
+    this.deserialize = deserialize;
+    this.serialize = serialize;
+    this.lerp = lerp;
+  }
+}
+
+class Socket {
+  constructor(valueTypeName, name, value = undefined, label = undefined, valueChoices = [] // if not empty, value must be one of these.
+  ) {
+    _defineProperty(this, "links", []);
+    this.valueTypeName = valueTypeName;
+    this.name = name;
+    this.value = value;
+    this.label = label;
+    this.valueChoices = valueChoices;
+  }
+}
+
+class CustomEvent {
+  constructor(id, name, parameters = []) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "eventEmitter", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.parameters = parameters;
+  }
+}
+
+class Variable {
+  constructor(id, name, valueTypeName, initialValue // this is assumed to be properly deseriealized from a string.
+  ) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    // this is updated on each change to the variable state.
+    _defineProperty(this, "onChanged", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.valueTypeName = valueTypeName;
+    this.initialValue = initialValue;
+    this.value = this.initialValue;
+  }
+  get() {
+    return this.value;
+  }
+  set(newValue) {
+    if (newValue !== this.value) {
+      this.value = newValue;
+      this.version++;
+      this.onChanged.emit(this);
+    }
+  }
+}
+
+const inputSocketName = {
+  a: 'a',
+  b: 'b',
+  c: 'c',
+  d: 'd'
+};
+const resultNodeName = 'result';
+
+class In4Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c, inputSocketName.d]) {
+    if (inputValueTypes.length !== 4) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 4, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 4) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 4, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In3Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c]) {
+    if (inputValueTypes.length !== 3) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 3, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 3) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 3, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In2Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b]) {
+    if (inputValueTypes.length !== 2) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 2, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 2) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 2, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In1Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a]) {
+    if (inputValueTypes.length !== 1) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 1, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 1) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 1, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In0Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, outputValueType, evalFunc) {
+    super(description, graph, [], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc());
+    });
+    this.evalFunc = evalFunc;
+  }
+}
+
+/* eslint-disable no-promise-executor-return */
+function sleep(durationInSeconds) {
+  return new Promise(resolve => setTimeout(resolve, Math.round(durationInSeconds * 1000)));
+}
+
+function resolveSocketValue(engine, inputSocket) {
+  // if it has no links, leave value on input socket alone.
+  if (inputSocket.links.length === 0) {
+    return 0;
+  }
+  const graph = engine.graph;
+  const upstreamLink = inputSocket.links[0];
+  // caching the target node + socket here increases engine performance by 8% on average.  This is a hotspot.
+  if (upstreamLink._targetNode === undefined || upstreamLink._targetSocket === undefined) {
+    Assert.mustBeTrue(inputSocket.links.length === 1);
+
+    // if upstream node is an eval, we just return its last value.
+    upstreamLink._targetNode = graph.nodes[upstreamLink.nodeId];
+    // what is inputSocket connected to?
+    upstreamLink._targetSocket = upstreamLink._targetNode.outputs.find(socket => socket.name === upstreamLink.socketName);
+    if (upstreamLink._targetSocket === undefined) {
+      throw new Error(`can not find socket with the name ${upstreamLink.socketName}`);
+    }
+  }
+  const upstreamNode = upstreamLink._targetNode;
+  const upstreamOutputSocket = upstreamLink._targetSocket;
+
+  // if upstream is a flow/event/async node, do not evaluate it rather just use its existing output socket values
+  if (!(upstreamNode instanceof ImmediateNode)) {
+    inputSocket.value = upstreamOutputSocket.value;
+    return 0;
+  }
+  let executionSteps = 0;
+  if (upstreamNode instanceof ImmediateNode) {
+    // resolve all inputs for the upstream node (this is where the recursion happens)
+    // TODO: This is a bit dangerous as if there are loops in the graph, this will blow up the stack
+    for (const upstreamInputSocket of upstreamNode.inputs) {
+      executionSteps += resolveSocketValue(engine, upstreamInputSocket);
+    }
+    engine.onNodeExecutionStart.emit(upstreamNode);
+    upstreamNode.exec();
+    executionSteps++;
+    engine.onNodeExecutionEnd.emit(upstreamNode);
+
+    // get the output value we wanted.
+    inputSocket.value = upstreamOutputSocket.value;
+    return executionSteps;
+  }
+  return 0;
+}
+
+class Fiber {
+  constructor(engine, nextEval, fiberCompletedListener = undefined) {
+    _defineProperty(this, "fiberCompletedListenerStack", []);
+    _defineProperty(this, "executionSteps", 0);
+    this.engine = engine;
+    this.nextEval = nextEval;
+    this.graph = engine.graph;
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // this is syncCommit.
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars
+  commit(node, outputSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof FlowNode);
+    Assert.mustBeTrue(this.nextEval === null);
+    const outputSocket = node.outputs.find(socket => socket.name === outputSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find socket with the name ${outputSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const link = outputSocket.links[0];
+      if (link === undefined) {
+        throw new Error('link must be defined');
+      }
+      this.nextEval = link;
+    }
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // returns the number of new execution steps created as a result of this one step
+  executeStep() {
+    // pop the next node off the queue
+    const link = this.nextEval;
+    this.nextEval = null;
+
+    // nothing waiting, thus go back and start to evaluate any callbacks, in stack order.
+    if (link === null) {
+      if (this.fiberCompletedListenerStack.length === 0) {
+        return;
+      }
+      const awaitingCallback = this.fiberCompletedListenerStack.pop();
+      if (awaitingCallback === undefined) {
+        throw new Error('awaitingCallback is empty');
+      }
+      awaitingCallback();
+      return;
+    }
+    const node = this.graph.nodes[link.nodeId];
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName !== 'flow') {
+        this.executionSteps += resolveSocketValue(this.engine, inputSocket);
+      }
+    });
+
+    // first resolve all input values
+    // flow socket is set to true for the one flowing in, while all others are set to false.
+    this.engine.onNodeExecutionStart.emit(node);
+    if (node instanceof AsyncNode) {
+      this.engine.asyncNodes.push(node);
+      node.triggered(this.engine, link.socketName, () => {
+        // remove from the list of pending async nodes
+        const index = this.engine.asyncNodes.indexOf(node);
+        this.engine.asyncNodes.splice(index, 1);
+        this.engine.onNodeExecutionEnd.emit(node);
+        this.executionSteps++;
+      });
+      return;
+    }
+    if (node instanceof FlowNode) {
+      node.triggered(this, link.socketName);
+      this.engine.onNodeExecutionEnd.emit(node);
+      this.executionSteps++;
+      return;
+    }
+    throw new TypeError(`should not get here, unhandled node ${node.description.typeName}`);
+  }
+  isCompleted() {
+    return this.fiberCompletedListenerStack.length === 0 && this.nextEval === null;
+  }
+}
+
+class Engine {
+  constructor(graph) {
+    // tracking the next node+input socket to execute.
+    _defineProperty(this, "fiberQueue", []);
+    _defineProperty(this, "asyncNodes", []);
+    _defineProperty(this, "eventNodes", []);
+    _defineProperty(this, "onNodeExecutionStart", new EventEmitter());
+    _defineProperty(this, "onNodeExecutionEnd", new EventEmitter());
+    _defineProperty(this, "executionSteps", 0);
+    this.graph = graph;
+    // collect all event nodes
+    Object.values(graph.nodes).forEach(node => {
+      if (node instanceof EventNode) {
+        this.eventNodes.push(node);
+      }
+    });
+    // init all event nodes at startup
+    this.eventNodes.forEach(eventNode => {
+      // evaluate input parameters
+      eventNode.inputs.forEach(inputSocket => {
+        Assert.mustBeTrue(inputSocket.valueTypeName !== 'flow');
+        this.executionSteps += resolveSocketValue(this, inputSocket);
+      });
+      this.onNodeExecutionStart.emit(eventNode);
+      eventNode.init(this);
+      this.executionSteps++;
+      this.onNodeExecutionEnd.emit(eventNode);
+    });
+  }
+  dispose() {
+    // dispose all, possibly in-progress, async nodes
+    this.asyncNodes.forEach(asyncNode => asyncNode.dispose());
+
+    // dispose all event nodes
+    this.eventNodes.forEach(eventNode => eventNode.dispose(this));
+  }
+
+  // asyncCommit
+  commitToNewFiber(node, outputFlowSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof EventNode || node instanceof AsyncNode);
+    const outputSocket = node.outputs.find(socket => socket.name === outputFlowSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`no socket with the name ${outputFlowSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const fiber = new Fiber(this, outputSocket.links[0], fiberCompletedListener);
+      this.fiberQueue.push(fiber);
+    }
+  }
+
+  // NOTE: This does not execute all if there are promises.
+  executeAllSync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSeconds = 0;
+    let elapsedSteps = 0;
+    while (elapsedSteps < limitInSteps && elapsedSeconds < limitInSeconds && this.fiberQueue.length > 0) {
+      const currentFiber = this.fiberQueue[0];
+      const startingFiberExecutionSteps = currentFiber.executionSteps;
+      currentFiber.executeStep();
+      elapsedSteps += currentFiber.executionSteps - startingFiberExecutionSteps;
+      if (currentFiber.isCompleted()) {
+        // remove first element
+        this.fiberQueue.shift();
+      }
+      elapsedSeconds = (Date.now() - startDateTime) * 0.001;
+    }
+    this.executionSteps += elapsedSteps;
+    return elapsedSteps;
+  }
+  async executeAllAsync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSteps = 0;
+    let elapsedTime = 0;
+    let iterations = 0;
+    do {
+      if (iterations > 0) {
+        // eslint-disable-next-line no-await-in-loop
+        await sleep(0);
+      }
+      elapsedSteps += this.executeAllSync(limitInSeconds - elapsedTime, limitInSteps - elapsedSteps);
+      elapsedTime = (Date.now() - startDateTime) * 0.001;
+      iterations += 1;
+    } while ((this.asyncNodes.length > 0 || this.fiberQueue.length > 0) && elapsedTime < limitInSeconds && elapsedSteps < limitInSteps);
+    return elapsedSteps;
+  }
+}
+
+// Purpose:
+//  - loads a node graph
+function readGraphFromJSON(graphJson, registry) {
+  var _graphJson$name, _graphJson$metadata, _graphJson$nodes;
+  const graph = new Graph(registry);
+  graph.name = (_graphJson$name = graphJson === null || graphJson === void 0 ? void 0 : graphJson.name) !== null && _graphJson$name !== void 0 ? _graphJson$name : graph.name;
+  graph.metadata = (_graphJson$metadata = graphJson === null || graphJson === void 0 ? void 0 : graphJson.metadata) !== null && _graphJson$metadata !== void 0 ? _graphJson$metadata : graph.metadata;
+  if ('variables' in graphJson) {
+    var _graphJson$variables;
+    readVariablesJSON(graph, (_graphJson$variables = graphJson.variables) !== null && _graphJson$variables !== void 0 ? _graphJson$variables : []);
+  }
+  if ('customEvents' in graphJson) {
+    var _graphJson$customEven;
+    readCustomEventsJSON(graph, (_graphJson$customEven = graphJson.customEvents) !== null && _graphJson$customEven !== void 0 ? _graphJson$customEven : []);
+  }
+  const nodesJson = (_graphJson$nodes = graphJson === null || graphJson === void 0 ? void 0 : graphJson.nodes) !== null && _graphJson$nodes !== void 0 ? _graphJson$nodes : [];
+  if (nodesJson.length === 0) {
+    Logger.warn('readGraphFromJSON: no nodes specified');
+  }
+
+  // create new BehaviorNode instances for each node in the json.
+  for (let i = 0; i < nodesJson.length; i += 1) {
+    const nodeJson = nodesJson[i];
+    readNodeJSON(graph, nodeJson);
+  }
+
+  // connect up the graph edges from BehaviorNode inputs to outputs.  This is required to follow execution
+  Object.values(graph.nodes).forEach(node => {
+    // initialize the inputs by resolving to the reference nodes.
+    node.inputs.forEach(inputSocket => {
+      inputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent upstream node id: ${link.nodeId}`);
+        }
+        const upstreamNode = graph.nodes[link.nodeId];
+        const upstreamOutputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (upstreamOutputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent output '${link.socketName}' on upstream node '${upstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const upstreamLink = new Link(node.id, inputSocket.name);
+        if (upstreamOutputSocket.links.findIndex(value => value.nodeId == upstreamLink.nodeId && value.socketName == upstreamLink.socketName) < 0) {
+          upstreamOutputSocket.links.push(upstreamLink);
+        }
+      });
+    });
+    node.outputs.forEach(outputSocket => {
+      outputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent downstream node id ${link.nodeId}`);
+        }
+        const downstreamNode = graph.nodes[link.nodeId];
+        const downstreamInputSocket = downstreamNode.inputs.find(socket => socket.name === link.socketName);
+        if (downstreamInputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent input '${link.socketName}' on downstream node '${downstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const downstreamLink = new Link(node.id, outputSocket.name);
+        if (downstreamInputSocket.links.findIndex(value => value.nodeId == downstreamLink.nodeId && value.socketName == downstreamLink.socketName) < 0) {
+          downstreamInputSocket.links.push(downstreamLink);
+        }
+      });
+    });
+  });
+  return graph;
+}
+function readNodeJSON(graph, nodeJson) {
+  var _nodeJson$label, _nodeJson$metadata;
+  if (nodeJson.type === undefined) {
+    throw new Error('readGraphFromJSON: no type for node');
+  }
+  const nodeName = nodeJson.type;
+  const nodeConfigurationJson = nodeJson.configuration;
+  const nodeConfiguration = {};
+  if (nodeConfigurationJson !== undefined) {
+    Object.keys(nodeConfigurationJson).forEach(key => {
+      nodeConfiguration[key] = nodeConfigurationJson[key];
+    });
+  }
+  const node = graph.createNode(nodeName, nodeJson.id, nodeConfiguration);
+  node.label = (_nodeJson$label = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.label) !== null && _nodeJson$label !== void 0 ? _nodeJson$label : node.label;
+  node.metadata = (_nodeJson$metadata = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.metadata) !== null && _nodeJson$metadata !== void 0 ? _nodeJson$metadata : node.metadata;
+  if (nodeJson.parameters !== undefined) {
+    readNodeParameterJSON(graph, node, nodeJson.parameters);
+  }
+  if (nodeJson.flows !== undefined) {
+    readNodeFlowsJSON(graph, node, nodeJson.flows);
+  }
+}
+function readNodeParameterJSON(graph, node, parametersJson) {
+  node.inputs.forEach(socket => {
+    if (!(socket.name in parametersJson)) {
+      return;
+    }
+    const inputJson = parametersJson[socket.name];
+    if ('value' in inputJson) {
+      // eslint-disable-next-line no-param-reassign
+      socket.value = graph.registry.values.get(socket.valueTypeName).deserialize(inputJson.value);
+    }
+    if ('link' in inputJson) {
+      const linkJson = inputJson.link;
+      socket.links.push(new Link(linkJson.nodeId, linkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const inputName in parametersJson) {
+    const inputSocket = node.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an input '${inputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readNodeFlowsJSON(graph, node, flowsJson) {
+  node.outputs.forEach(socket => {
+    if (socket.name in flowsJson) {
+      const outputLinkJson = flowsJson[socket.name];
+      socket.links.push(new Link(outputLinkJson.nodeId, outputLinkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const outputName in flowsJson) {
+    const outputSocket = node.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an output '${outputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readVariablesJSON(graph, variablesJson) {
+  for (let i = 0; i < variablesJson.length; i += 1) {
+    var _variableJson$label, _variableJson$metadat;
+    const variableJson = variablesJson[i];
+    const variable = new Variable(variableJson.id, variableJson.name, variableJson.valueTypeName, graph.registry.values.get(variableJson.valueTypeName).deserialize(variableJson.initialValue));
+    variable.label = (_variableJson$label = variableJson === null || variableJson === void 0 ? void 0 : variableJson.label) !== null && _variableJson$label !== void 0 ? _variableJson$label : variable.label;
+    variable.metadata = (_variableJson$metadat = variableJson === null || variableJson === void 0 ? void 0 : variableJson.metadata) !== null && _variableJson$metadat !== void 0 ? _variableJson$metadat : variable.metadata;
+    if (variableJson.id in graph.variables) {
+      throw new Error(`duplicate variable id ${variable.id}`);
+    }
+    graph.variables[variableJson.id] = variable;
+  }
+}
+function readCustomEventsJSON(graph, customEventsJson) {
+  for (let i = 0; i < customEventsJson.length; i += 1) {
+    var _customEventJson$para, _customEventJson$labe, _customEventJson$meta;
+    const customEventJson = customEventsJson[i];
+    const parameters = [];
+    ((_customEventJson$para = customEventJson.parameters) !== null && _customEventJson$para !== void 0 ? _customEventJson$para : []).forEach(parameterJson => {
+      parameters.push(new Socket(parameterJson.valueTypeName, parameterJson.name, graph.registry.values.get(parameterJson.valueTypeName).deserialize(parameterJson.defaultValue)));
+    });
+    const customEvent = new CustomEvent(customEventJson.id, customEventJson.name, parameters);
+    customEvent.label = (_customEventJson$labe = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.label) !== null && _customEventJson$labe !== void 0 ? _customEventJson$labe : customEvent.label;
+    customEvent.metadata = (_customEventJson$meta = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.metadata) !== null && _customEventJson$meta !== void 0 ? _customEventJson$meta : customEvent.metadata;
+    if (customEvent.id in graph.customEvents) {
+      throw new Error(`duplicate variable id ${customEvent.id}`);
+    }
+    graph.customEvents[customEvent.id] = customEvent;
+  }
+}
+
+function writeGraphToJSON(graph) {
+  const graphJson = {};
+  if (Object.keys(graph.metadata).length > 0) {
+    graphJson.metadata = graph.metadata;
+  }
+
+  // save custom events
+  Object.values(graph.customEvents).forEach(customEvent => {
+    const customEventJson = {
+      name: customEvent.name,
+      id: customEvent.id
+    };
+    if (customEvent.label.length > 0) {
+      customEventJson.label = customEvent.label;
+    }
+    if (customEvent.parameters.length > 0) {
+      const parametersJson = [];
+      customEvent.parameters.forEach(parameter => {
+        parametersJson.push({
+          name: parameter.name,
+          valueTypeName: parameter.valueTypeName,
+          defaultValue: parameter.value
+        });
+      });
+      customEventJson.parameters = parametersJson;
+    }
+    if (Object.keys(customEvent.metadata).length > 0) {
+      customEventJson.metadata = customEvent.metadata;
+    }
+    if (graphJson.customEvents === undefined) {
+      graphJson.customEvents = [];
+    }
+    graphJson.customEvents.push(customEventJson);
+  });
+
+  // save variables
+  Object.values(graph.variables).forEach(variable => {
+    const variableJson = {
+      valueTypeName: variable.valueTypeName,
+      name: variable.name,
+      id: variable.id,
+      initialValue: graph.registry.values.get(variable.valueTypeName).serialize(variable.initialValue)
+    };
+    if (variable.label.length > 0) {
+      variableJson.label = variable.label;
+    }
+    if (Object.keys(variable.metadata).length > 0) {
+      variableJson.metadata = variable.metadata;
+    }
+    if (graphJson.variables === undefined) {
+      graphJson.variables = [];
+    }
+    graphJson.variables.push(variableJson);
+  });
+
+  // save nodes
+  Object.values(graph.nodes).forEach(node => {
+    const nodeJson = {
+      type: node.description.typeName,
+      id: node.id
+    };
+    if (node.label.length > 0) {
+      nodeJson.label = node.label;
+    }
+    if (Object.keys(node.metadata).length > 0) {
+      nodeJson.metadata = node.metadata;
+    }
+    if (Object.keys(node.description.configuration).length > 0) {
+      const configurationJson = {};
+      Object.keys(node.configuration).forEach(key => {
+        configurationJson[key] = node.configuration[key];
+      });
+      nodeJson.configuration = configurationJson;
+    }
+    const parametersJson = {};
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName === 'flow') return;
+      let parameterJson = undefined;
+      if (inputSocket.links.length === 0) {
+        parameterJson = {
+          value: graph.registry.values.get(inputSocket.valueTypeName).serialize(inputSocket.value)
+        };
+      } else if (inputSocket.links.length === 1) {
+        const link = inputSocket.links[0];
+        parameterJson = {
+          link: {
+            nodeId: link.nodeId,
+            socket: link.socketName
+          }
+        };
+      } else {
+        throw new Error(`should not get here, inputSocket.links.length = ${inputSocket.links.length} > 1`);
+      }
+      parametersJson[inputSocket.name] = parameterJson;
+    });
+    if (Object.keys(parametersJson).length > 0) {
+      nodeJson.parameters = parametersJson;
+    }
+    const flowsJson = {};
+    node.outputs.forEach(outputSocket => {
+      if (outputSocket.valueTypeName !== 'flow') return;
+      if (outputSocket.links.length === 0) return;
+      const linkJson = {
+        nodeId: outputSocket.links[0].nodeId,
+        socket: outputSocket.links[0].socketName
+      };
+      flowsJson[outputSocket.name] = linkJson;
+    });
+    if (Object.keys(flowsJson).length > 0) {
+      nodeJson.flows = flowsJson;
+    }
+    if (graphJson.nodes === undefined) {
+      graphJson.nodes = [];
+    }
+    graphJson.nodes.push(nodeJson);
+  });
+  return graphJson;
+}
+
+function writeNodeSpecsToJSON(registry) {
+  const nodeSpecsJSON = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+    const nodeSpecJSON = {
+      type: nodeTypeName,
+      category: node.description.category,
+      label: node.description.label,
+      inputs: [],
+      outputs: [],
+      configuration: []
+    };
+    node.inputs.forEach(inputSocket => {
+      const valueType = inputSocket.valueTypeName === 'flow' ? undefined : registry.values.get(inputSocket.valueTypeName);
+      let defaultValue = inputSocket.value;
+      if (valueType !== undefined) {
+        defaultValue = valueType.serialize(defaultValue);
+      }
+      if (defaultValue === undefined && valueType !== undefined) {
+        defaultValue = valueType.serialize(valueType.creator());
+      }
+      const socketSpecJSON = {
+        name: inputSocket.name,
+        valueType: inputSocket.valueTypeName,
+        defaultValue
+      };
+      nodeSpecJSON.inputs.push(socketSpecJSON);
+    });
+    node.outputs.forEach(outputSocket => {
+      const socketSpecJSON = {
+        name: outputSocket.name,
+        valueType: outputSocket.valueTypeName
+      };
+      nodeSpecJSON.outputs.push(socketSpecJSON);
+    });
+    nodeSpecsJSON.push(nodeSpecJSON);
+  });
+  return nodeSpecsJSON;
+}
+
+function getNodeDescriptions(importWildcard) {
+  return Object.keys(importWildcard).map(key => importWildcard[key]).filter(value => value instanceof NodeDescription);
+}
+class NodeDescription {
+  constructor(typeName, category, label = '', factory, otherTypeNames = [], helpDescription = '', configuration = {}) {
+    this.typeName = typeName;
+    this.category = category;
+    this.label = label;
+    this.factory = factory;
+    this.otherTypeNames = otherTypeNames;
+    this.helpDescription = helpDescription;
+    this.configuration = configuration;
+  }
+}
+class NodeDescription2 extends NodeDescription {
+  constructor(properties) {
+    super(properties.typeName, properties.category, properties.label, properties.factory, properties.otherTypeNames, properties.helpDescription, properties.configuration);
+    this.properties = properties;
+  }
+}
+
+class NodeTypeRegistry {
+  constructor() {
+    _defineProperty(this, "typeNameToNodeDescriptions", {});
+  }
+  clear() {
+    for (const nodeTypeName in this.typeNameToNodeDescriptions) {
+      delete this.typeNameToNodeDescriptions[nodeTypeName];
+    }
+  }
+  register(...descriptions) {
+    descriptions.forEach(description => {
+      description.otherTypeNames.concat([description.typeName]).forEach(typeName => {
+        if (typeName in this.typeNameToNodeDescriptions) {
+          throw new Error(`already registered node type ${typeName} (string)`);
+        }
+        this.typeNameToNodeDescriptions[typeName] = description;
+      });
+    });
+  }
+  contains(typeName) {
+    return typeName in this.typeNameToNodeDescriptions;
+  }
+  get(typeName) {
+    if (!(typeName in this.typeNameToNodeDescriptions)) {
+      throw new Error(`no registered node with type name ${typeName}`);
+    }
+    return this.typeNameToNodeDescriptions[typeName];
+  }
+  getAllNames() {
+    return Object.keys(this.typeNameToNodeDescriptions);
+  }
+  getAllDescriptions() {
+    return Object.values(this.typeNameToNodeDescriptions);
+  }
+}
+
+class ValueTypeRegistry {
+  constructor() {
+    _defineProperty(this, "valueTypeNameToValueType", {});
+  }
+  register(...valueTypes) {
+    valueTypes.forEach(valueType => {
+      if (valueType.name in this.valueTypeNameToValueType) {
+        throw new Error(`already registered value type ${valueType.name}`);
+      }
+      this.valueTypeNameToValueType[valueType.name] = valueType;
+    });
+  }
+  get(valueTypeName) {
+    if (!(valueTypeName in this.valueTypeNameToValueType)) {
+      throw new Error(`can not find value type with name '${valueTypeName}`);
+    }
+    return this.valueTypeNameToValueType[valueTypeName];
+  }
+  getAllNames() {
+    return Object.keys(this.valueTypeNameToValueType);
+  }
+}
+
+class Registry {
+  constructor() {
+    _defineProperty(this, "values", new ValueTypeRegistry());
+    _defineProperty(this, "nodes", new NodeTypeRegistry());
+  }
+}
+
+const nodeTypeNameRegex = /^\w+(\/\w+)*$/;
+const socketNameRegex = /^\w+$/;
+function validateNodeRegistry(registry) {
+  const errorList = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+
+    // ensure node is registered correctly.
+    if (node.description.typeName !== nodeTypeName) {
+      if (!node.description.otherTypeNames.includes(nodeTypeName)) {
+        errorList.push(`node with typeName '${node.description.typeName}' is registered under a different name '${nodeTypeName}'`);
+      }
+    }
+    if (!nodeTypeNameRegex.test(node.description.typeName)) {
+      errorList.push(`invalid node type name on node ${node.description.typeName}`);
+    }
+    node.inputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for input socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on input socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+    node.outputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for output socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on output socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+  });
+  return errorList;
+}
+
+const valueTypeNameRegex = /^\w+$/;
+function validateValueRegistry(graphRegistry) {
+  const errorList = [];
+  graphRegistry.values.getAllNames().forEach(valueTypeName => {
+    if (!valueTypeNameRegex.test(valueTypeName)) {
+      errorList.push(`invalid value type name ${valueTypeName}`);
+    }
+    const valueType = graphRegistry.values.get(valueTypeName);
+    const value = valueType.creator();
+    const serializedValue = valueType.serialize(value);
+    const deserializedValue = valueType.deserialize(serializedValue);
+    const reserializedValue = valueType.serialize(deserializedValue);
+    const redeserializedValue = valueType.deserialize(reserializedValue);
+    if (JSON.stringify(serializedValue) !== JSON.stringify(reserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) reserialization mismatch between ${JSON.stringify(serializedValue)} and ${JSON.stringify(reserializedValue)}`);
+    }
+    if (typeof deserializedValue !== 'bigint' && JSON.stringify(deserializedValue) !== JSON.stringify(redeserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) redeserialization mismatch between ${JSON.stringify(deserializedValue)} and ${JSON.stringify(redeserializedValue)}`);
+    }
+  });
+  return errorList;
+}
+
+function validateRegistry(registry) {
+  const errorList = [];
+  errorList.push(...validateValueRegistry(registry), ...validateNodeRegistry(registry));
+  return errorList;
+}
+
+function validateGraphAcyclic(graph) {
+  // apparently if you can topological sort, it is a DAG according to: https://stackoverflow.com/questions/4168/graph-serialization/4577#4577
+
+  // instead of modifying the graph, I will use metadata to mark it in place.
+  Object.values(graph.nodes).forEach(node => {
+    // eslint-disable-next-line no-param-reassign
+    node.metadata['dag.marked'] = 'false';
+  });
+
+  // it appears that we can just keep trimming nodes whose input sockets have no connections.
+  // if we can remove all nodes, that means that there are no cycles.
+
+  const nodesToMark = [];
+  do {
+    // clear array: https://stackoverflow.com/a/1232046
+    nodesToMark.length = 0;
+    Object.values(graph.nodes).forEach(node => {
+      // ignore existing marked nodes.
+      if (node.metadata['dag.marked'] === 'true') {
+        return;
+      }
+      let inputsConnected = false;
+      node.inputs.forEach(inputSocket => {
+        inputSocket.links.forEach(link => {
+          // is the other end marked?  If not, then it is still connected.
+          if (graph.nodes[link.nodeId].metadata['dag.marked'] === 'false') {
+            inputsConnected = true;
+          }
+        });
+      });
+      if (!inputsConnected) {
+        nodesToMark.push(node);
+      }
+    });
+    nodesToMark.forEach(node => {
+      // eslint-disable-next-line no-param-reassign
+      node.metadata['dag.marked'] = 'true';
+    });
+  } while (nodesToMark.length > 0);
+  const errorList = [];
+
+  // output errors for each unmarked node
+  // also remove the metadata related to DAG marking
+  Object.values(graph.nodes).forEach(node => {
+    if (node.metadata['dag.marked'] === 'false') {
+      errorList.push(`node ${node.description.typeName} is part of a cycle, not a directed acyclic graph`);
+    }
+    // eslint-disable-next-line no-param-reassign
+    delete node.metadata['dag.marked'];
+  });
+  return errorList;
+}
+
+function validateGraphLinks(graph) {
+  const errorList = [];
+  // for each node
+  Object.values(graph.nodes).forEach(node => {
+    // for each input socket
+    node.inputs.forEach(inputSocket => {
+      // ensure that connected output sockets are the same type
+      inputSocket.links.forEach(link => {
+        // check if the node id is correct
+        if (!(link.nodeId in graph.nodes)) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using invalid nodeId: ${link.nodeId}`);
+          return;
+        }
+
+        // check if the socketName is correct
+        const upstreamNode = graph.nodes[link.nodeId];
+        const outputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (outputSocket === undefined) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using a non-existent socket name: ` + `${link.socketName}, it can not be found on upstream output node: ${upstreamNode.description.typeName}`);
+          return;
+        }
+
+        // check if the socket types align
+        if (inputSocket.valueTypeName !== outputSocket.valueTypeName) {
+          errorList.push(`type mismatch between ${node.description.typeName}.${inputSocket.name} [${inputSocket.valueTypeName}] ` + `and ${upstreamNode.description.typeName}.${outputSocket.name} [${outputSocket.valueTypeName}]`);
+        }
+      });
+    });
+  });
+  return errorList;
+}
+
+function validateGraph(graph) {
+  const errorList = [];
+  errorList.push(...validateGraphAcyclic(graph), ...validateGraphLinks(graph));
+  return errorList;
+}
+
+/* eslint-disable class-methods-use-this */
+class DefaultLogger {
+  verbose(text) {
+    Logger.verbose(text);
+  }
+  info(text) {
+    Logger.info(text);
+  }
+  warn(text) {
+    Logger.warn(text);
+  }
+  error(text) {
+    Logger.error(text);
+  }
+}
+
+class ManualLifecycleEventEmitter {
+  constructor() {
+    _defineProperty(this, "startEvent", new EventEmitter());
+    _defineProperty(this, "endEvent", new EventEmitter());
+    _defineProperty(this, "tickEvent", new EventEmitter());
+  }
+}
+
+var _class$n;
+class OnCustomEvent extends EventNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      outputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      configuration
+    });
+    _defineProperty(this, "onCustomEvent", undefined);
+    this.customEvent = customEvent;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onCustomEvent === undefined);
+    this.onCustomEvent = parameters => {
+      this.customEvent.parameters.forEach(parameterSocket => {
+        if (!(parameterSocket.name in parameters)) {
+          throw new Error(`parameters of custom event do not align with parameters of custom event node, missing ${parameterSocket.name}`);
+        }
+        this.writeOutput(parameterSocket.name, parameters[parameterSocket.name]);
+      });
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.customEvent.eventEmitter.addListener(this.onCustomEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onCustomEvent !== undefined);
+    if (this.onCustomEvent !== undefined) {
+      this.customEvent.eventEmitter.removeListener(this.onCustomEvent);
+    }
+  }
+}
+_class$n = OnCustomEvent;
+_defineProperty(OnCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/onTriggered',
+  category: 'Event',
+  label: 'On Triggered',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$n(description, graph, configuration)
+}));
+
+var _class$m;
+class TriggerCustomEvent extends FlowNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      inputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      outputs: [new Socket('flow', 'flow')],
+      configuration
+    });
+    this.customEvent = customEvent;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const parameters = {};
+    this.customEvent.parameters.forEach(parameterSocket => {
+      parameters[parameterSocket.name] = this.readInput(parameterSocket.name);
+    });
+    this.customEvent.eventEmitter.emit(parameters);
+  }
+}
+_class$m = TriggerCustomEvent;
+_defineProperty(TriggerCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/trigger',
+  category: 'Action',
+  label: 'Trigger',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$m(description, graph, configuration)
+}));
+
+var _class$l;
+class ExpectTrue extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition'), new Socket('string', 'description')], [new Socket('flow', 'flow')]);
+  }
+  triggered(fiber, triggeredSocketName) {
+    Assert.mustBeTrue(this.readInput('condition'), this.readInput('description'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$l = ExpectTrue;
+_defineProperty(ExpectTrue, "Description", new NodeDescription('debug/expectTrue', 'Action', 'Assert Expect True', (description, graph) => new _class$l(description, graph)));
+
+var _class$k;
+class Log extends FlowNode {
+  constructor(description, graph, logger) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'text'), new Socket('string', 'severity', 'info', undefined, ['verbose', 'info', 'warning', 'error'])], [new Socket('flow', 'flow')]);
+    this.logger = logger;
+  }
+  triggered(fiber, triggeredSocketName) {
+    const text = this.readInput('text');
+    switch (this.readInput('severity')) {
+      case 'verbose':
+        this.logger.verbose(text);
+        break;
+      case 'info':
+        this.logger.info(text);
+        break;
+      case 'warning':
+        this.logger.warn(text);
+        break;
+      case 'error':
+        this.logger.error(text);
+        break;
+    }
+    fiber.commit(this, 'flow');
+  }
+}
+_class$k = Log;
+_defineProperty(Log, "Description", logger => new NodeDescription('debug/log', 'Action', 'Debug Log', (description, graph) => new _class$k(description, graph, logger)));
+
+var _class$j;
+class Branch extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition')], [new Socket('flow', 'true'), new Socket('flow', 'false')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    fiber.commit(this, this.readInput('condition') === true ? 'true' : 'false');
+  }
+}
+_class$j = Branch;
+_defineProperty(Branch, "Description", new NodeDescription2({
+  typeName: 'flow/branch',
+  category: 'Flow',
+  label: 'Branch',
+  factory: (description, graph) => new _class$j(description, graph),
+  helpDescription: "Checks the value of the 'condition' input and if true, executes the 'true' branch, otherwise it executes the 'false' branch."
+}));
+
+var _class$i;
+class Counter extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          this.count++;
+          this.writeOutput('count', this.count);
+          fiber.commit(this, 'flow');
+          break;
+        }
+      case 'reset':
+        {
+          this.count = 0;
+          break;
+        }
+      default:
+        throw new Error('should not get here');
+    }
+  }
+}
+_class$i = Counter;
+_defineProperty(Counter, "Description", new NodeDescription('flow/counter', 'Flow', 'Counter', (description, graph) => new _class$i(description, graph)));
+
+var _class$h;
+
+// ASYNC - asynchronous evaluation
+// also called "delay"
+
+class Delay extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.timeoutPending = true;
+    setTimeout(() => {
+      // check if cancelled
+      if (!this.timeoutPending) return;
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.timeoutPending = false;
+  }
+}
+_class$h = Delay;
+_defineProperty(Delay, "Description", new NodeDescription2({
+  typeName: 'time/delay',
+  otherTypeNames: ['flow/delay'],
+  category: 'Time',
+  label: 'Delay',
+  factory: (description, graph) => new _class$h(description, graph)
+}));
+
+var _class$g;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoN extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'n', 1), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.count = 0;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (this.count < Number(this.readInput('n'))) {
+        this.writeOutput('count', this.count);
+        this.count++;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$g = DoN;
+_defineProperty(DoN, "Description", new NodeDescription('flow/doN', 'Flow', 'DoN', (description, graph) => new _class$g(description, graph)));
+
+var _class$f;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoOnce extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "firedOnce", false);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.firedOnce = false;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (!this.firedOnce) {
+        this.firedOnce = true;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$f = DoOnce;
+_defineProperty(DoOnce, "Description", new NodeDescription('flow/doOnce', 'Flow', 'DoOnce', (description, graph) => new _class$f(description, graph)));
+
+var _class$e;
+
+// as long as this continues to be triggered within the duration period, it will not fire.
+// based lousy on https://www.npmjs.com/package/debounce
+
+class Debounce extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'waitDuration'), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    this.triggerVersion++;
+
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      return;
+    }
+    const localTriggerCount = this.triggerVersion;
+    setTimeout(() => {
+      if (this.triggerVersion >= localTriggerCount) {
+        // ignore this timer, as it isn't for the most recent trigger
+        return;
+      }
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('waitDuration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+  }
+}
+_class$e = Debounce;
+_defineProperty(Debounce, "Description", new NodeDescription('flow/debounce', 'Flow', 'Debounce', (description, graph) => new _class$e(description, graph)));
+
+var _class$d;
+class FlipFlop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow')], [new Socket('flow', 'on'), new Socket('flow', 'off'), new Socket('boolean', 'isOn')]);
+    _defineProperty(this, "isOn", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    this.writeOutput('isOn', this.isOn);
+    fiber.commit(this, this.isOn ? 'on' : 'off');
+    this.isOn = !this.isOn;
+  }
+}
+_class$d = FlipFlop;
+_defineProperty(FlipFlop, "Description", new NodeDescription('flow/flipFlop', 'Flow', 'Flip Flop', (description, graph) => new _class$d(description, graph)));
+
+var _class$c;
+class ForLoop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'startIndex'), new Socket('integer', 'endIndex')], [new Socket('flow', 'loopBody'), new Socket('integer', 'index'), new Socket('flow', 'completed')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an async fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const startIndex = this.readInput('startIndex');
+    const endIndex = this.readInput('endIndex');
+    const loopBodyIteration = i => {
+      if (i < endIndex) {
+        this.writeOutput('index', i);
+        fiber.commit(this, 'loopBody', () => {
+          loopBodyIteration(i + BigInt(1));
+        });
+      } else {
+        fiber.commit(this, 'completed');
+      }
+    };
+    loopBodyIteration(startIndex);
+  }
+}
+_class$c = ForLoop;
+_defineProperty(ForLoop, "Description", new NodeDescription2({
+  typeName: 'flow/forLoop',
+  category: 'Flow',
+  label: 'For Loop',
+  factory: (description, graph) => new _class$c(description, graph)
+}));
+
+var _class$b;
+
+// based on Unreal Engine Blueprint Gate node
+
+class Gate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'open'), new Socket('flow', 'close'), new Socket('flow', 'toggle'), new Socket('boolean', 'startClosed', true)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "isClosed", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.isClosed = this.readInput('startClosed');
+      this.isInitialized = true;
+    }
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          if (!this.isClosed) {
+            fiber.commit(this, 'flow');
+          }
+          break;
+        }
+      case 'open':
+        {
+          this.isClosed = false;
+          return;
+        }
+      case 'close':
+        {
+          this.isClosed = true;
+          return;
+        }
+      case 'toggle':
+        {
+          this.isClosed = !this.isClosed;
+          return;
+        }
+    }
+  }
+}
+_class$b = Gate;
+_defineProperty(Gate, "Description", new NodeDescription('flow/gate', 'Flow', 'Gate', (description, graph) => new _class$b(description, graph)));
+
+var _class$a;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class MultiGate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset'), new Socket('boolean', 'loop', true), new Socket('integer', 'startIndex', 0)], [new Socket('flow', '1'), new Socket('flow', '2'), new Socket('flow', '3')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "nextIndex", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.nextIndex = Number(this.readInput('startIndex'));
+    }
+    if (this.readInput('loop')) {
+      this.nextIndex = this.nextIndex % this.outputs.length;
+    }
+    switch (triggeringSocketName) {
+      case 'reset':
+        {
+          this.nextIndex = 0;
+          return;
+        }
+      case 'flow':
+        {
+          if (0 <= this.nextIndex && this.nextIndex < this.outputs.length) {
+            fiber.commit(this, this.outputs[this.nextIndex].name);
+          }
+          this.nextIndex++;
+          return;
+        }
+    }
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$a = MultiGate;
+_defineProperty(MultiGate, "Description", new NodeDescription('flow/multiGate', 'Flow', 'MultiGate', (description, graph) => new _class$a(description, graph)));
+
+var _class$9;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class Sequence extends FlowNode {
+  constructor(description, graph, configuration) {
+    const outputs = [];
+    const numOutputs = configuration.numOutputs;
+    for (let outputIndex = 1; outputIndex <= numOutputs; outputIndex++) {
+      outputs.push(new Socket('flow', `${outputIndex}`));
+    }
+    super(description, graph, [new Socket('flow', 'flow')], outputs);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$9 = Sequence;
+_defineProperty(Sequence, "Description", new NodeDescription2({
+  typeName: 'flow/sequence',
+  category: 'Flow',
+  label: 'Sequence',
+  configuration: {
+    numOutputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$9(description, graph, configuration)
+}));
+
+var _class$8;
+
+// based on the description here: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/
+
+class Throttle extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      if (this.timeoutPending) {
+        this.triggerVersion++;
+        this.timeoutPending = false;
+      }
+      return;
+    }
+
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.triggerVersion++;
+    const localTriggerCount = this.triggerVersion;
+    this.timeoutPending = true;
+    setTimeout(() => {
+      if (this.triggerVersion !== localTriggerCount) {
+        return;
+      }
+      Assert.mustBeTrue(this.timeoutPending);
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+    this.timeoutPending = false;
+  }
+}
+_class$8 = Throttle;
+_defineProperty(Throttle, "Description", new NodeDescription('flow/throttle', 'Flow', 'Throttle', (description, graph) => new _class$8(description, graph)));
+
+var _class$7;
+
+// this is equivalent to Promise.all()
+class WaitAll extends FlowNode {
+  constructor(description, graph, numInputs) {
+    const inputs = [];
+    for (let inputIndex = 1; inputIndex <= numInputs; inputIndex++) {
+      inputs.push(new Socket('flow', `${inputIndex}`));
+    }
+    super(description, graph, [...inputs, new Socket('flow', 'reset'), new Socket('boolean', 'autoReset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isOn", true);
+    _defineProperty(this, "triggeredMap", {});
+    _defineProperty(this, "triggeredCount", 0);
+    _defineProperty(this, "outputTriggered", false);
+    this.numInputs = numInputs;
+    this.reset();
+  }
+  reset() {
+    for (let inputIndex = 1; inputIndex <= this.numInputs; inputIndex++) {
+      this.triggeredMap[`${inputIndex}`] = false;
+    }
+    this.triggeredCount = 0;
+    this.outputTriggered = false;
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.reset();
+      return;
+    }
+    if (this.triggeredMap[triggeringSocketName]) {
+      return;
+    }
+    this.triggeredMap[triggeringSocketName] = true;
+    this.triggeredCount++;
+
+    // if a & b are triggered, first output!
+    if (this.triggeredCount === this.numInputs && !this.outputTriggered) {
+      fiber.commit(this, 'flow');
+      this.outputTriggered = true;
+
+      // auto-reset if required.
+      if (this.readInput('autoReset') === true) {
+        this.reset();
+      }
+    }
+  }
+}
+_class$7 = WaitAll;
+_defineProperty(WaitAll, "Description", new NodeDescription2({
+  typeName: 'flow/waitAll',
+  category: 'Flow',
+  label: 'WaitAll',
+  configuration: {
+    numInputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$7(description, graph, (configuration === null || configuration === void 0 ? void 0 : configuration.numInputs) || 3)
+}));
+
+var _class$6;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnEnd extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onEndEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onEndEvent === undefined);
+    this.onEndEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.endEvent.addListener(this.onEndEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onEndEvent !== undefined);
+    if (this.onEndEvent !== undefined) {
+      this.lifecycleEventEmitter.endEvent.removeListener(this.onEndEvent);
+    }
+  }
+}
+_class$6 = LifecycleOnEnd;
+_defineProperty(LifecycleOnEnd, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onEnd', 'Event', 'On End', (description, graph) => new _class$6(description, graph, lifecycleEventEmitter)));
+
+var _class$5;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnStart extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onStartEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onStartEvent === undefined);
+    this.onStartEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.startEvent.addListener(this.onStartEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onStartEvent !== undefined);
+    if (this.onStartEvent !== undefined) {
+      this.lifecycleEventEmitter.startEvent.removeListener(this.onStartEvent);
+    }
+  }
+}
+_class$5 = LifecycleOnStart;
+_defineProperty(LifecycleOnStart, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onStart', 'Event', 'On Start', (description, graph) => new _class$5(description, graph, lifecycleEventEmitter)));
+
+var _class$4;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnTick extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'deltaSeconds')]);
+    _defineProperty(this, "onTickEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onTickEvent === undefined);
+    let lastTickTime = Date.now();
+    this.onTickEvent = () => {
+      const currentTime = Date.now();
+      const deltaSeconds = (currentTime - lastTickTime) * 0.001;
+      this.writeOutput('deltaSeconds', deltaSeconds);
+      engine.commitToNewFiber(this, 'flow');
+      lastTickTime = currentTime;
+    };
+    this.lifecycleEventEmitter.tickEvent.addListener(this.onTickEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onTickEvent !== undefined);
+    if (this.onTickEvent !== undefined) {
+      this.lifecycleEventEmitter.tickEvent.removeListener(this.onTickEvent);
+    }
+  }
+}
+_class$4 = LifecycleOnTick;
+_defineProperty(LifecycleOnTick, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onTick', 'Event', 'On Tick', (description, graph) => new _class$4(description, graph, lifecycleEventEmitter)));
+
+const Constant$b = new NodeDescription('math/boolean', 'Logic', 'Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => a));
+const And = new NodeDescription('math/and/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a && b));
+const Or = new NodeDescription('math/or/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a || b));
+const Not = new NodeDescription('math/negate/boolean', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => !a));
+const ToFloat$2 = new NodeDescription('math/toFloat/boolean', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'float', a => a ? 1 : 0));
+const Equal$b = new NodeDescription('math/equal/boolean', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a === b));
+const toInteger = new NodeDescription('math/toInteger/boolean', 'Logic', 'To Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'integer', a => a ? 1n : 0n));
+
+var BooleanNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$b,
+  And: And,
+  Or: Or,
+  Not: Not,
+  ToFloat: ToFloat$2,
+  Equal: Equal$b,
+  toInteger: toInteger
+});
+
+const BooleanValue = new ValueType('boolean', () => false, value => typeof value === 'string' ? value.toLowerCase() === 'true' : value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+const EPSILON = 0.000001; // chosen from gl-matrix
+
+function equalsTolerance(a, b, tolerance = EPSILON) {
+  return Math.abs(a - b) < tolerance;
+}
+function degreesToRadians(a) {
+  return a * (Math.PI / 180);
+}
+function radiansToDegrees(a) {
+  return a * (180 / Math.PI);
+}
+function clamp(a, min, max) {
+  return a < min ? min : a > max ? max : a;
+}
+
+// Unreal Engine Blueprint Float nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Float/
+
+const Constant$a = new NodeDescription('math/float', 'Logic', 'Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => a));
+const Add$8 = new NodeDescription('math/add/float', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a + b));
+const Subtract$8 = new NodeDescription('math/subtract/float', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a - b));
+const Negate$9 = new NodeDescription('math/negate/float', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => -a));
+const Multiply$4 = new NodeDescription('math/multiply/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a * b));
+const Divide$1 = new NodeDescription('math/divide/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a / b));
+const Modulus$1 = new NodeDescription('math/modulus/float', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a % b));
+const Power = new NodeDescription('math/pow/float', 'Logic', 'POW', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', Math.pow));
+const SquareRoot = new NodeDescription('math/sqrt/float', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sqrt));
+const E = new NodeDescription('math/e/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.E));
+const Exp$1 = new NodeDescription('math/exp/float', 'Logic', 'EXP', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.exp));
+const Ln$1 = new NodeDescription('math/ln/float', 'Logic', 'LN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log));
+const Log2 = new NodeDescription('math/log2/float', 'Logic', 'LOG2', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log2));
+const Log10 = new NodeDescription('math/log10/float', 'Logic', 'LOG10', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log10));
+const PI = new NodeDescription('math/pi/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.PI));
+const Sin = new NodeDescription('math/sin/float', 'Logic', 'SIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sin));
+const Asin = new NodeDescription('math/asin/float', 'Logic', 'ASIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.asin));
+const Cos = new NodeDescription('math/cos/float', 'Logic', 'COS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.cos));
+const Acos = new NodeDescription('math/acos/float', 'Logic', 'ACOS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.acos));
+const Tan = new NodeDescription('math/tan/float', 'Logic', 'TAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.tan));
+const RadiansToDegrees = new NodeDescription('math/radiansToDegrees/float', 'Logic', 'To Degrees', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => radiansToDegrees(a), ['radian']));
+const DegreesToRadians = new NodeDescription('math/degreesToRadians/float', 'Logic', 'To Radians', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => degreesToRadians(a), ['degrees']));
+const Atan = new NodeDescription('math/atan/float', 'Logic', 'ATAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.atan));
+const Mix$7 = new NodeDescription('math/mix/float', 'Logic', 'MIX', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (a, b, t) => {
+  const s = 1 - t;
+  return a * s + b * t;
+}, ['a', 'b', 't']));
+const ToFloat$1 = new NodeDescription('math/toFloat/float', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => Number(a)));
+const Min$1 = new NodeDescription('math/min/float', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.min(a, b) // TODO: can I jsut pass in Math.min?
+));
+
+const Max$1 = new NodeDescription('math/max/float', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.max(a, b) // TODO: can I jsut pass in Math.max?
+));
+
+const Clamp$1 = new NodeDescription('math/clamp/float', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs$1 = new NodeDescription('math/abs/float', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.abs));
+const Sign$1 = new NodeDescription('math/sign/float', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sign));
+const Floor = new NodeDescription('math/floor/float', 'Logic', 'FLOOR', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.floor));
+const Ceil = new NodeDescription('math/ceil/float', 'Logic', 'CEIL', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.ceil));
+const Round = new NodeDescription('math/round/float', 'Logic', 'ROUND', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.round));
+const Trunc = new NodeDescription('math/trunc/float', 'Logic', 'TRUNC', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.trunc));
+const Random = new NodeDescription('math/random/float', 'Logic', 'RANDOM', (description, graph) => new In0Out1FuncNode(description, graph, 'float', Math.random));
+const Equal$a = new NodeDescription('math/equal/float', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a === b, ['a', 'b']));
+const EqualTolerance = new NodeDescription('math/equalTolerance/float', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'boolean', (a, b, tolerance) => equalsTolerance(a, b, tolerance), ['a', 'b', 'tolerance']));
+const GreaterThan$1 = new NodeDescription('math/greaterThan/float', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual$1 = new NodeDescription('math/greaterThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a >= b));
+const LessThan$1 = new NodeDescription('math/lessThan/float', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual$1 = new NodeDescription('math/lessThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a <= b));
+const IsNaN = new NodeDescription('math/isNaN/float', 'Logic', 'isNaN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', Number.isNaN));
+const IsInf = new NodeDescription('math/isInf/float', 'Logic', 'isInf', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', a => !Number.isFinite(a) && !Number.isNaN(a)));
+
+var FloatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$a,
+  Add: Add$8,
+  Subtract: Subtract$8,
+  Negate: Negate$9,
+  Multiply: Multiply$4,
+  Divide: Divide$1,
+  Modulus: Modulus$1,
+  Power: Power,
+  SquareRoot: SquareRoot,
+  E: E,
+  Exp: Exp$1,
+  Ln: Ln$1,
+  Log2: Log2,
+  Log10: Log10,
+  PI: PI,
+  Sin: Sin,
+  Asin: Asin,
+  Cos: Cos,
+  Acos: Acos,
+  Tan: Tan,
+  RadiansToDegrees: RadiansToDegrees,
+  DegreesToRadians: DegreesToRadians,
+  Atan: Atan,
+  Mix: Mix$7,
+  ToFloat: ToFloat$1,
+  Min: Min$1,
+  Max: Max$1,
+  Clamp: Clamp$1,
+  Abs: Abs$1,
+  Sign: Sign$1,
+  Floor: Floor,
+  Ceil: Ceil,
+  Round: Round,
+  Trunc: Trunc,
+  Random: Random,
+  Equal: Equal$a,
+  EqualTolerance: EqualTolerance,
+  GreaterThan: GreaterThan$1,
+  GreaterThanOrEqual: GreaterThanOrEqual$1,
+  LessThan: LessThan$1,
+  LessThanOrEqual: LessThanOrEqual$1,
+  IsNaN: IsNaN,
+  IsInf: IsInf
+});
+
+const cSeparator = /[^\d+.-]+/;
+function parseSafeFloat(text, fallback = 0) {
+  try {
+    return Number.parseFloat(text);
+  } catch (_unused) {
+    return fallback;
+  }
+}
+function parseSafeFloats(text, fallback = 0) {
+  return text.split(cSeparator).filter(Boolean).map(value => parseSafeFloat(value, fallback));
+}
+function toSafeString(elements) {
+  return `[${elements.join(',')}]`;
+}
+
+const FloatValue = new ValueType('float', () => 0, value => typeof value === 'string' ? parseSafeFloat(value, 0) : value, value => value, (start, end, t) => start * (1 - t) + end * t);
+
+// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/
+
+const Constant$9 = new NodeDescription('math/integer', 'Logic', 'Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a));
+const Add$7 = new NodeDescription('math/add/integer', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a + b));
+const Subtract$7 = new NodeDescription('math/subtract/integer', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a - b));
+const Negate$8 = new NodeDescription('math/negate/integer', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => -a));
+const Multiply$3 = new NodeDescription('math/multiply/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a * b));
+const Divide = new NodeDescription('math/divide/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a / b));
+const Modulus = new NodeDescription('math/modulus/integer', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a % b));
+const ToFloat = new NodeDescription('math/toFloat/integer', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'float', a => Number(a)));
+const Min = new NodeDescription('math/min/integer', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? b : a));
+const Max = new NodeDescription('math/max/integer', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? a : b));
+const Clamp = new NodeDescription('math/clamp/integer', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['integer', 'integer', 'integer'], 'integer', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs = new NodeDescription('math/abs/integer', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a < BigInt(0) ? -a : a));
+const Sign = new NodeDescription('math/sign/integer', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => BigInt(a < 0 ? -1 : a > 0 ? 1 : 0)));
+const Equal$9 = new NodeDescription('math/equal/integer', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a === b));
+const GreaterThan = new NodeDescription('math/greaterThan/integer', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual = new NodeDescription('math/greaterThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a >= b));
+const LessThan = new NodeDescription('math/lessThan/integer', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual = new NodeDescription('math/lessThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a <= b));
+const toBoolean = new NodeDescription('math/toBoolean/integer', 'Logic', 'To Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'boolean', a => a !== 0n));
+
+var IntegerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$9,
+  Add: Add$7,
+  Subtract: Subtract$7,
+  Negate: Negate$8,
+  Multiply: Multiply$3,
+  Divide: Divide,
+  Modulus: Modulus,
+  ToFloat: ToFloat,
+  Min: Min,
+  Max: Max,
+  Clamp: Clamp,
+  Abs: Abs,
+  Sign: Sign,
+  Equal: Equal$9,
+  GreaterThan: GreaterThan,
+  GreaterThanOrEqual: GreaterThanOrEqual,
+  LessThan: LessThan,
+  LessThanOrEqual: LessThanOrEqual,
+  toBoolean: toBoolean
+});
+
+const IntegerValue = new ValueType('integer', () => BigInt(0), value => BigInt(value), value => Number.MIN_SAFE_INTEGER <= value && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value.toString(),
+// prefer string to ensure full range is covered
+
+(start, end, t) => BigInt(Number(start) * (1 - t) + Number(end) * t));
+
+const Constant$8 = new NodeDescription('logic/string', 'Logic', 'String', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'string', a => a));
+const Concat = new NodeDescription('logic/concat/string', 'Logic', 'Concat', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'string', (a, b) => a.concat(b)));
+const Includes = new NodeDescription('logic/includes/string', 'Logic', 'Includes', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a.includes(b)));
+const Length$4 = new NodeDescription('logic/length/string', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'integer', a => BigInt(a.length)));
+const Equal$8 = new NodeDescription('math/equal/string', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a === b));
+
+var StringNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$8,
+  Concat: Concat,
+  Includes: Includes,
+  Length: Length$4,
+  Equal: Equal$8
+});
+
+const StringValue = new ValueType('string', () => '', value => value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+var _class$3;
+class VariableSet extends FlowNode {
+  static GetDescription(graph, variableId) {
+    const variable = graph.variables[variableId];
+    return new NodeDescription(`variable/set/${variable.id}`, 'Action', `Set`, (description, graph) => new VariableSet(description, graph, variable));
+  }
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [new Socket('flow', 'flow'), new Socket(variable.valueTypeName, 'value', undefined, variable.name) // variable name is a label so variable can be renamed without breaking graph.
+    ], [new Socket('flow', 'flow')], configuration);
+    this.variable = variable;
+  }
+  triggered(fiber, triggeredSocketName) {
+    this.variable.set(this.readInput('value'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$3 = VariableSet;
+_defineProperty(VariableSet, "Description", new NodeDescription2({
+  typeName: 'variable/set',
+  category: 'Action',
+  label: 'Set',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$3(description, graph, configuration)
+}));
+
+var _class$2;
+class VariableGet extends ImmediateNode {
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [], [new Socket(variable.valueTypeName, 'value', undefined, variable.name)],
+    // output socket label uses variable name like UE4, but name is value to avoid breaking graph when variable is renamed
+    () => {
+      this.writeOutput('value', variable.get());
+    }, configuration);
+  }
+}
+_class$2 = VariableGet;
+_defineProperty(VariableGet, "Description", new NodeDescription2({
+  typeName: 'variable/get',
+  category: 'Query',
+  label: 'Get',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$2(description, graph, configuration)
+}));
+
+const EasingFunctions = {
+  linear: t => t,
+  quadratic: t => t * t,
+  cubic: t => t * t * t,
+  quartric: t => t * t * t * t,
+  quintic: t => t * t * t * t * t,
+  sine: t => 1 - Math.cos(t * Math.PI / 2),
+  exponential: t => Math.pow(2, 10 * (t - 1)),
+  circle: t => 1 - Math.sqrt(1 - t * t),
+  back: t => {
+    const s = 1.70158;
+    return t * t * ((s + 1) * t - s);
+  },
+  elastic: t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * Math.PI),
+  bounce: t => {
+    if (t < 1 / 2.75) {
+      return 7.5625 * t * t;
+    }
+    if (t < 2 / 2.75) {
+      const _t = t - 1.5 / 2.75;
+      return 7.5625 * _t * _t + 0.75;
+    }
+    if (t < 2.5 / 2.75) {
+      const _t2 = t - 2.25 / 2.75;
+      return 7.5625 * _t2 * _t2 + 0.9375;
+    }
+    const t2 = t - 2.625 / 2.75;
+    return 7.5625 * t2 * t2 + 0.984375;
+  }
+};
+const EasingModes = {
+  in: easing => {
+    return easing;
+  },
+  out: easing => {
+    return t => 1 - easing(1 - t);
+  },
+  inOut: easing => {
+    return t => {
+      if (t < 0.5) {
+        return easing(t * 2) / 2;
+      }
+      return 1 - easing((1 - t) * 2) / 2;
+    };
+  }
+};
+
+var _class$1;
+class Easing extends ImmediateNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('string', 'easingFunction', 'linear', undefined, Object.keys(EasingFunctions)), new Socket('string', 'easingMode', 'inOut', undefined, Object.keys(EasingModes)), new Socket('float', 't')], [new Socket('float', 't')], () => {
+      const easingFunction = EasingFunctions[this.readInput('easingFunction')];
+      const easingMode = EasingModes[this.readInput('easingMode')];
+      const easing = easingMode(easingFunction);
+      const inputT = this.readInput('t');
+      this.writeOutput('t', easing(inputT));
+    });
+  }
+}
+_class$1 = Easing;
+_defineProperty(Easing, "Description", new NodeDescription('math/easing', 'Logic', 'Easing', (description, graph) => new _class$1(description, graph)));
+
+function toCamelCase(text) {
+  if (text.length > 0) {
+    return text.slice(0, 1).toLocaleUpperCase() + text.slice(1);
+  }
+  return text;
+}
+
+/* eslint-disable @typescript-eslint/no-explicit-any */
+function registerSerializersForValueType(registry, valueTypeName) {
+  const camelCaseValueTypeName = toCamelCase(valueTypeName);
+  registry.nodes.register(new NodeDescription(`math/to${camelCaseValueTypeName}/string`, 'Logic', `To ${camelCaseValueTypeName}`, (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, ['string'], valueTypeName, a => registry.values.get(valueTypeName).deserialize(a))), new NodeDescription(`math/toString/${valueTypeName}`, 'Logic', 'To String', (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, [valueTypeName], 'string', a => registry.values.get(valueTypeName).serialize(a))));
+}
+
+// Unreal Engine Blueprint Time nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Utilities/Time/
+
+const Now = new NodeDescription('time/now', 'Logic', 'Now', (description, graph) => {
+  // ensure we do not leak current actual time, just time since initialization?
+  const startTime = Date.now();
+  return new In0Out1FuncNode(description, graph, 'float', () => (Date.now() - startTime) / 1000);
+});
+
+var TimeNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Now: Now
+});
+
+/* eslint-disable max-len */
+function registerCoreProfile(registry, logger = new DefaultLogger(), lifecycleEventEmitter = new ManualLifecycleEventEmitter()) {
+  const {
+    nodes,
+    values
+  } = registry;
+
+  // pull in value type nodes
+  values.register(BooleanValue);
+  values.register(StringValue);
+  values.register(IntegerValue);
+  values.register(FloatValue);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(StringNodes));
+  nodes.register(...getNodeDescriptions(BooleanNodes));
+  nodes.register(...getNodeDescriptions(IntegerNodes));
+  nodes.register(...getNodeDescriptions(FloatNodes));
+
+  // custom events
+
+  nodes.register(OnCustomEvent.Description);
+  nodes.register(TriggerCustomEvent.Description);
+
+  // variables
+
+  nodes.register(VariableGet.Description);
+  nodes.register(VariableSet.Description);
+
+  // complex logic
+
+  nodes.register(Easing.Description);
+
+  // actions
+
+  nodes.register(Log.Description(logger));
+  nodes.register(ExpectTrue.Description);
+
+  // events
+
+  nodes.register(LifecycleOnStart.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnEnd.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnTick.Description(lifecycleEventEmitter));
+
+  // time
+
+  nodes.register(Delay.Description);
+  nodes.register(...getNodeDescriptions(TimeNodes));
+
+  // flow control
+
+  nodes.register(Branch.Description);
+  nodes.register(FlipFlop.Description);
+  nodes.register(ForLoop.Description);
+  nodes.register(Sequence.Description);
+  nodes.register(Debounce.Description);
+  nodes.register(Throttle.Description);
+  nodes.register(DoN.Description);
+  nodes.register(DoOnce.Description);
+  nodes.register(Gate.Description);
+  nodes.register(MultiGate.Description);
+  nodes.register(WaitAll.Description);
+  nodes.register(Counter.Description);
+
+  // string converters
+
+  ['boolean', 'float', 'integer'].forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+class Vec2 {
+  constructor(x = 0, y = 0) {
+    this.x = x;
+    this.y = y;
+  }
+  clone(result = new Vec2()) {
+    return result.set(this.x, this.y);
+  }
+  set(x, y) {
+    this.x = x;
+    this.y = y;
+    return this;
+  }
+}
+function vec2Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance);
+}
+function vec2Add(a, b, result = new Vec2()) {
+  return result.set(a.x + b.x, a.y + b.y);
+}
+function vec2Subtract(a, b, result = new Vec2()) {
+  return result.set(a.x - b.x, a.y - b.y);
+}
+function vec2MultiplyByScalar(a, b, result = new Vec2()) {
+  return result.set(a.x * b, a.y * b);
+}
+function vec2Negate(a, result = new Vec2()) {
+  return result.set(-a.x, -a.y);
+}
+function vec2Length(a) {
+  return Math.sqrt(vec2Dot(a, a));
+}
+function vec2Normalize(a, result = new Vec2()) {
+  const invLength = 1 / vec2Length(a);
+  return vec2MultiplyByScalar(a, invLength, result);
+}
+function vec2Dot(a, b) {
+  return a.x * b.x + a.y * b.y;
+}
+function vec2Mix(a, b, t, result = new Vec2()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t);
+}
+function vec2FromArray(array, offset = 0, result = new Vec2()) {
+  return result.set(array[offset + 0], array[offset + 1]);
+}
+function vec2ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+}
+function vec2ToString(a) {
+  return toSafeString([a.x, a.y]);
+}
+function vec2Parse(text, result = new Vec2()) {
+  return vec2FromArray(parseSafeFloats(text), 0, result);
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, 1 ) x [ 0  3  6 ] = ( x', y', 1 )
+//               [ 1  4  7 ]
+//               [ 2  5  8 ]
+// where elements 2 and 5 would be translation in 2D, as they would multiplied
+// by the last virtual element of the 2D vector.
+const NUM_ROWS$1 = 3;
+const NUM_COLUMNS$1 = 3;
+const NUM_ELEMENTS$1 = NUM_ROWS$1 * NUM_COLUMNS$1;
+class Mat3 {
+  constructor(elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat3()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat3SetColumn3(m, columnIndex, column, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  const base = columnIndex * NUM_ROWS$1;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  return result;
+}
+function mat3SetRow3(m, rowIndex, row, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  re[rowIndex + NUM_COLUMNS$1 * 0] = row.x;
+  re[rowIndex + NUM_COLUMNS$1 * 1] = row.y;
+  re[rowIndex + NUM_COLUMNS$1 * 2] = row.z;
+  return result;
+}
+function column3ToMat3(a, b, c, result = new Mat3()) {
+  const re = result.elements;
+  const columns = [a, b, c];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS$1;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+  }
+  return result;
+}
+function mat3Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat3Add(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat3Subtract(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat3MultiplyByScalar(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat3Negate(a, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat3Multiply(a, b, result = new Mat3()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[3],
+    a13 = ae[6];
+  const a21 = ae[1],
+    a22 = ae[4],
+    a23 = ae[7];
+  const a31 = ae[2],
+    a32 = ae[5],
+    a33 = ae[8];
+  const b11 = be[0],
+    b12 = be[3],
+    b13 = be[6];
+  const b21 = be[1],
+    b22 = be[4],
+    b23 = be[7];
+  const b31 = be[2],
+    b32 = be[5],
+    b33 = be[8];
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31;
+  te[3] = a11 * b12 + a12 * b22 + a13 * b32;
+  te[6] = a11 * b13 + a12 * b23 + a13 * b33;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31;
+  te[4] = a21 * b12 + a22 * b22 + a23 * b32;
+  te[7] = a21 * b13 + a22 * b23 + a23 * b33;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31;
+  te[5] = a31 * b12 + a32 * b22 + a33 * b32;
+  te[8] = a31 * b13 + a32 * b23 + a33 * b33;
+  return result;
+}
+function mat3Determinant(m) {
+  const me = m.elements;
+  const a = me[0],
+    b = me[1],
+    c = me[2],
+    d = me[3],
+    e = me[4],
+    f = me[5],
+    g = me[6],
+    h = me[7],
+    i = me[8];
+  return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
+}
+function mat3Transpose(m, result = new Mat3()) {
+  const me = m.elements;
+  const te = result.elements;
+  te[0] = me[0];
+  te[4] = me[4];
+  te[8] = me[8];
+  te[1] = me[3];
+  te[3] = me[1];
+  te[2] = me[6];
+  te[6] = me[2];
+  te[5] = me[7];
+  te[7] = me[5];
+  return result;
+}
+function mat3Inverse(m, result = new Mat3()) {
+  const e = m.elements;
+  const n11 = e[0],
+    n21 = e[1],
+    n31 = e[2],
+    n12 = e[3],
+    n22 = e[4],
+    n32 = e[5],
+    n13 = e[6],
+    n23 = e[7],
+    n33 = e[8],
+    t11 = n33 * n22 - n32 * n23,
+    t12 = n32 * n13 - n33 * n12,
+    t13 = n23 * n12 - n22 * n13,
+    det = n11 * t11 + n21 * t12 + n31 * t13;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+  const re = result.elements;
+
+  // TODO: replace with a set
+  re[0] = t11 * detInv;
+  re[1] = (n31 * n23 - n33 * n21) * detInv;
+  re[2] = (n32 * n21 - n31 * n22) * detInv;
+  re[3] = t12 * detInv;
+  re[4] = (n33 * n11 - n31 * n13) * detInv;
+  re[5] = (n31 * n12 - n32 * n11) * detInv;
+  re[6] = t13 * detInv;
+  re[7] = (n21 * n13 - n23 * n11) * detInv;
+  re[8] = (n22 * n11 - n21 * n12) * detInv;
+  return result;
+}
+function mat3Mix(a, b, t, result = new Mat3()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat3FromArray(array, offset = 0, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat3Parse(text, result = new Mat3()) {
+  return mat3FromArray(parseSafeFloats(text), 0, result);
+}
+function eulerToMat3(euler, result = new Mat3()) {
+  const te = result.elements;
+  const x = euler.x,
+    y = euler.y,
+    z = euler.z;
+  const a = Math.cos(x),
+    b = Math.sin(x);
+  const c = Math.cos(y),
+    d = Math.sin(y);
+  const e = Math.cos(z),
+    f = Math.sin(z);
+  const ae = a * e,
+    af = a * f,
+    be = b * e,
+    bf = b * f;
+  te[0] = c * e;
+  te[3] = -c * f;
+  te[6] = d;
+  te[1] = af + be * d;
+  te[4] = ae - bf * d;
+  te[7] = -b * c;
+  te[2] = bf - ae * d;
+  te[5] = be + af * d;
+  te[8] = a * c;
+  return result;
+}
+function quatToMat3(q, result = new Mat3()) {
+  const x = q.x,
+    y = q.y,
+    z = q.z,
+    w = q.w;
+  const x2 = x + x,
+    y2 = y + y,
+    z2 = z + z;
+  const xx = x * x2,
+    xy = x * y2,
+    xz = x * z2;
+  const yy = y * y2,
+    yz = y * z2,
+    zz = z * z2;
+  const wx = w * x2,
+    wy = w * y2,
+    wz = w * z2;
+  return result.set([1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)]);
+}
+function scale2ToMat3(s, result = new Mat3()) {
+  return result.set([s.x, 0, 0, 0, s.y, 0, 0, 0, 1]);
+}
+// from gl-matrix
+function mat3ToScale2(m, result = new Vec2()) {
+  const mat = m.elements;
+  const m11 = mat[0];
+  const m12 = mat[1];
+  const m21 = mat[3];
+  const m22 = mat[4];
+  return result.set(Math.sqrt(m11 * m11 + m12 * m12), Math.sqrt(m21 * m21 + m22 * m22));
+}
+function translation2ToMat3(t, result = new Mat3()) {
+  return result.set([1, 0, t.x, 0, 1, t.y, 0, 0, 1]);
+}
+function mat3ToTranslation2(m, result = new Vec2()) {
+  return result.set(m.elements[2], m.elements[5]);
+}
+function mat4ToMat3(a, result = new Mat3()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], ae[4], ae[5], ae[6], ae[8], ae[9], ae[10]]);
+}
+
+class Vec3 {
+  constructor(x = 0, y = 0, z = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+  }
+  clone(result = new Vec3()) {
+    return result.set(this.x, this.y, this.z);
+  }
+  set(x, y, z) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    return this;
+  }
+}
+function vec3Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance);
+}
+function vec3Add(a, b, result = new Vec3()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+function vec3Subtract(a, b, result = new Vec3()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+function vec3MultiplyByScalar(a, b, result = new Vec3()) {
+  return result.set(a.x * b, a.y * b, a.z * b);
+}
+function vec3Negate(a, result = new Vec3()) {
+  return result.set(-a.x, -a.y, -a.z);
+}
+function vec3Length(a) {
+  return Math.sqrt(vec3Dot(a, a));
+}
+function vec3Normalize(a, result = new Vec3()) {
+  const invLength = 1 / vec3Length(a);
+  return vec3MultiplyByScalar(a, invLength, result);
+}
+function vec3Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+function vec3Cross(a, b, result = new Vec3()) {
+  const ax = a.x;
+  const ay = a.y;
+  const az = a.z;
+  const bx = b.x;
+  const by = b.y;
+  const bz = b.z;
+  return result.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
+}
+function vec3Mix(a, b, t, result = new Vec3()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t);
+}
+function vec3FromArray(array, offset = 0, result = new Vec3()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2]);
+}
+function vec3ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+}
+function vec3ToString(a) {
+  return toSafeString([a.x, a.y, a.z]);
+}
+function vec3Parse(text, result = new Vec3()) {
+  return vec3FromArray(parseSafeFloats(text), 0, result);
+}
+function hslToRGB(hsl, result = new Vec3()) {
+  function hue2rgb(p, q, t) {
+    if (t < 0) {
+      t += 1;
+    }
+    if (t > 1) {
+      t -= 1;
+    }
+    if (t < 1 / 6) {
+      return p + (q - p) * 6 * t;
+    }
+    if (t < 1 / 2) {
+      return q;
+    }
+    if (t < 2 / 3) {
+      return p + (q - p) * 6 * (2 / 3 - t);
+    }
+    return p;
+  }
+
+  // h,s,l ranges are in 0.0 - 1.0
+  const h = (hsl.x % 1 + 1) % 1; // euclidean modulo
+  const s = Math.min(Math.max(hsl.y, 0), 1);
+  const l = Math.min(Math.max(hsl.z, 0), 1);
+  if (s === 0) {
+    return result.set(1, 1, 1);
+  }
+  const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
+  const q = 2 * l - p;
+  return result.set(hue2rgb(q, p, h + 1 / 3), hue2rgb(q, p, h), hue2rgb(q, p, h - 1 / 3));
+}
+function rgbToHSL(rgb, result = new Vec3()) {
+  // h,s,l ranges are in 0.0 - 1.0
+  const r = rgb.x,
+    g = rgb.y,
+    b = rgb.z;
+  const max = Math.max(r, g, b);
+  const min = Math.min(r, g, b);
+  let hue = 0;
+  let saturation = 0;
+  const lightness = (min + max) / 2;
+  if (min === max) {
+    hue = 0;
+    saturation = 0;
+  } else {
+    const delta = max - min;
+    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
+    switch (max) {
+      case r:
+        hue = (g - b) / delta + (g < b ? 6 : 0);
+        break;
+      case g:
+        hue = (b - r) / delta + 2;
+        break;
+      case b:
+        hue = (r - g) / delta + 4;
+        break;
+    }
+    hue /= 6;
+  }
+  return result.set(hue, saturation, lightness);
+}
+function hexToRGB(hex, result = new Vec3()) {
+  hex = Math.floor(hex);
+  return result.set((hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255);
+}
+function rgbToHex(rgb) {
+  return rgb.x * 255 << 16 ^ rgb.y * 255 << 8 ^ rgb.z * 255 << 0;
+}
+
+// from three.js
+function mat3ToEuler(m, result = new Vec3()) {
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  const te = m.elements;
+  const m11 = te[0],
+    m12 = te[3],
+    m13 = te[6];
+  te[1];
+    const m22 = te[4],
+    m23 = te[7];
+  te[2];
+    const m32 = te[5],
+    m33 = te[8];
+  result.y = Math.asin(clamp(m13, -1, 1));
+  if (Math.abs(m13) < 0.9999999) {
+    result.x = Math.atan2(-m23, m33);
+    result.z = Math.atan2(-m12, m11);
+  } else {
+    result.x = Math.atan2(m32, m22);
+    result.z = 0;
+  }
+  return result;
+}
+
+// from three.js
+function mat4ToEuler(m, result = new Vec3()) {
+  return mat3ToEuler(mat4ToMat3(m), result);
+}
+function quatToEuler(q, result = new Vec3()) {
+  return mat3ToEuler(quatToMat3(q), result);
+}
+
+const ColorValue = new ValueType('color', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const EulerValue = new ValueType('euler', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+class Vec4 {
+  constructor(x = 0, y = 0, z = 0, w = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+  }
+  clone(result = new Vec4()) {
+    return result.set(this.x, this.y, this.z, this.w);
+  }
+  set(x, y, z, w) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+    return this;
+  }
+}
+function vec4Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance) && equalsTolerance(a.w, b.w, tolerance);
+}
+function vec4Add(a, b, result = new Vec4()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
+}
+function vec4Subtract(a, b, result = new Vec4()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
+}
+function vec4MultiplyByScalar(a, b, result = new Vec4()) {
+  return result.set(a.x * b, a.y * b, a.z * b, a.w * b);
+}
+function vec4Negate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, -a.w);
+}
+function vec4Length(a) {
+  return Math.sqrt(vec4Dot(a, a));
+}
+function vec4Normalize(a, result = new Vec4()) {
+  const invLength = 1 / vec4Length(a);
+  return vec4MultiplyByScalar(a, invLength, result);
+}
+function vec4Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+function vec4Mix(a, b, t, result = new Vec4()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
+}
+function vec4FromArray(array, offset = 0, result = new Vec4()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2], array[offset + 3]);
+}
+function vec4ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+  array[offset + 3] = a.w;
+}
+function vec4ToString(a) {
+  return toSafeString([a.x, a.y, a.z, a.w]);
+}
+function vec4Parse(text, result = new Vec4()) {
+  return vec4FromArray(parseSafeFloats(text), 0, result);
+}
+function quatConjugate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, a.w);
+}
+function quatMultiply(a, b, result = new Vec4()) {
+  // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
+
+  const qax = a.x;
+  const qay = a.y;
+  const qaz = a.z;
+  const qaw = a.w;
+  const qbx = b.x;
+  const qby = b.y;
+  const qbz = b.z;
+  const qbw = b.w;
+  return result.set(qax * qbw + qaw * qbx + qay * qbz - qaz * qby, qay * qbw + qaw * qby + qaz * qbx - qax * qbz, qaz * qbw + qaw * qbz + qax * qby - qay * qbx, qaw * qbw - qax * qbx - qay * qby - qaz * qbz);
+}
+function quatSlerp(a, b, t, result = new Vec4()) {
+  if (t <= 0) return a.clone(result);
+  if (t >= 1) return b.clone(result);
+
+  // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
+
+  let cosHalfTheta = vec4Dot(a, b);
+  if (cosHalfTheta < 0) {
+    vec4Negate(b, result);
+    cosHalfTheta = -cosHalfTheta;
+  } else {
+    b.clone(result);
+  }
+  if (cosHalfTheta >= 1) {
+    return result;
+  }
+  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
+  if (sqrSinHalfTheta <= Number.EPSILON) {
+    vec4Mix(a, result, t);
+    vec4Normalize(result, result);
+    return result;
+  }
+  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
+  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
+  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
+  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
+  result.w = a.w * ratioA + result.w * ratioB;
+  result.x = a.x * ratioA + result.x * ratioB;
+  result.y = a.y * ratioA + result.y * ratioB;
+  result.z = a.z * ratioA + result.z * ratioB;
+  return result;
+}
+
+/**
+ * Calculate the exponential of a unit quaternion.
+ *
+ * @param {quat} out the receiving quaternion
+ * @param {ReadonlyQuat} a quat to calculate the exponential of
+ * @returns {quat} out
+ */
+function quatExp(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const et = Math.exp(w);
+  const s = r > 0 ? et * Math.sin(r) / r : 0;
+  return result.set(x * s, y * s, z * s, et * Math.cos(r));
+}
+
+// from gl-matrix
+function quatLn(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const t = r > 0 ? Math.atan2(r, w) / r : 0;
+  return result.set(x * t, y * t, z * t, 0.5 * Math.log(x * x + y * y + z * z + w * w));
+}
+
+// from gl-matrix
+function quatPow(a, b, result = new Vec4()) {
+  const ln = quatLn(a);
+  const lnScaled = vec4MultiplyByScalar(ln, b);
+  quatExp(lnScaled, result);
+  return result;
+}
+function eulerToQuat(euler, result = new Vec4()) {
+  // eslint-disable-next-line max-len
+  // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
+
+  const c1 = Math.cos(euler.x / 2);
+  const c2 = Math.cos(euler.y / 2);
+  const c3 = Math.cos(euler.z / 2);
+  const s1 = Math.sin(euler.x / 2);
+  const s2 = Math.sin(euler.y / 2);
+  const s3 = Math.sin(euler.z / 2);
+
+  // XYZ order only
+  return result.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
+}
+function angleAxisToQuat(angle, axis, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
+
+  // assumes axis is normalized
+
+  const halfAngle = angle / 2;
+  const s = Math.sin(halfAngle);
+  return result.set(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
+}
+
+// from gl-matrix
+function quatToAngleAxis(q, result = new Vec3()) {
+  const rad = Math.acos(q.w) * 2;
+  const s = Math.sin(rad / 2);
+  if (s > EPSILON) {
+    result.x = q.x / s;
+    result.y = q.y / s;
+    result.z = q.z / s;
+  } else {
+    // If s is zero, return any axis (no rotation - axis does not matter)
+    result.x = 1;
+    result.y = 0;
+    result.z = 0;
+  }
+  return [rad, result];
+}
+function mat4ToQuat(m, result = new Vec4()) {
+  return mat3ToQuat(mat4ToMat3(m), result);
+}
+function mat3ToQuat(m, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
+
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  // TODO, allocate x, y, z, w and only set q.* at the end.
+
+  const te = m.elements,
+    m11 = te[0],
+    m12 = te[3],
+    m13 = te[6],
+    m21 = te[1],
+    m22 = te[4],
+    m23 = te[7],
+    m31 = te[2],
+    m32 = te[5],
+    m33 = te[8],
+    trace = m11 + m22 + m33;
+  if (trace > 0) {
+    const _s = 0.5 / Math.sqrt(trace + 1);
+    return result.set((m32 - m23) * _s, (m13 - m31) * _s, (m21 - m12) * _s, 0.25 / _s);
+  }
+  if (m11 > m22 && m11 > m33) {
+    const _s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
+    return result.set(0.25 * _s2, (m12 + m21) / _s2, (m13 + m31) / _s2, (m32 - m23) / _s2);
+  }
+  if (m22 > m33) {
+    const _s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
+    return result.set((m12 + m21) / _s3, 0.25 * _s3, (m23 + m32) / _s3, (m13 - m31) / _s3);
+  }
+  const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
+  return result.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
+}
+
+const QuatValue = new ValueType('quat', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => quatSlerp(start, end, t));
+
+const Vec2Value = new ValueType('vec2', () => new Vec2(), value => typeof value === 'string' ? vec2Parse(value) : new Vec2(value[0], value[1]), value => [value.x, value.y], (start, end, t) => vec2Mix(start, end, t));
+
+const Vec3Value = new ValueType('vec3', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const Vec4Value = new ValueType('vec4', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => vec4Mix(start, end, t));
+
+class DummyScene {
+  constructor() {
+    _defineProperty(this, "onSceneChanged", new EventEmitter());
+    _defineProperty(this, "valueRegistry", new ValueTypeRegistry());
+    const values = this.valueRegistry;
+    // pull in value type nodes
+    values.register(BooleanValue);
+    values.register(StringValue);
+    values.register(IntegerValue);
+    values.register(FloatValue);
+    values.register(Vec2Value);
+    values.register(Vec3Value);
+    values.register(Vec4Value);
+    values.register(ColorValue);
+    values.register(EulerValue);
+    values.register(QuatValue);
+  }
+  getProperty(jsonPath, valueTypeName) {
+    return this.valueRegistry.get(valueTypeName).creator();
+  }
+  setProperty() {
+    this.onSceneChanged.emit();
+  }
+  addOnClickedListener(jsonPath, callback) {
+    throw new Error('Method not implemented.');
+  }
+}
+
+class SetSceneProperty extends FlowNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/set/${valueTypeName}`, 'Action', `Set Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new SetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'jsonPath'), new Socket(valueTypeName, 'value')], [new Socket('flow', 'flow')]);
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const scene = this.scene;
+    const value = this.readInput('value');
+    scene.setProperty(this.readInput('jsonPath'), this.valueTypeName, value);
+    fiber.commit(this, 'flow');
+  }
+}
+
+var _class;
+
+// very 3D specific.
+class OnSceneNodeClick extends EventNode {
+  constructor(description, graph) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'nodeIndex')]);
+  }
+}
+_class = OnSceneNodeClick;
+_defineProperty(OnSceneNodeClick, "Description", new NodeDescription('scene/nodeClick', 'Event', 'On Node Click', (description, graph) => new _class(description, graph)));
+
+class VecElements extends ImmediateNode {
+  constructor(description, graph, valueTypeName, elementNames = ['x', 'y', 'z', 'w'], toArray) {
+    super(description, graph, [new Socket(valueTypeName, 'value')], elementNames.map(elementName => new Socket('float', elementName)), () => {
+      const value = this.readInput('value');
+      const elementValues = elementNames.map(() => 0);
+      toArray(value, elementValues, 0);
+      elementNames.forEach((elementName, index) => this.writeOutput(elementName, elementValues[index]));
+    });
+  }
+}
+
+class GetSceneProperty extends ImmediateNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/get/${valueTypeName}`, 'Query', `Get Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new GetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('string', 'jsonPath')], [new Socket(valueTypeName, 'value')], () => {
+      this.writeOutput('value', this.scene.getProperty(this.readInput('jsonPath'), valueTypeName));
+    });
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+}
+
+const Constant$7 = new NodeDescription('math/color', 'Logic', 'Color', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', a => a));
+const Create$5 = new NodeDescription('math/toColor/rgb', 'Logic', 'RGB To Color', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'color', (r, g, b) => new Vec3(r, g, b), ['r', 'g', 'b']));
+const Elements$7 = new NodeDescription('math/toRgb/color', 'Logic', 'Color to RGB', (description, graph) => new VecElements(description, graph, 'color', ['r', 'g', 'b'], vec3ToArray));
+const Add$6 = new NodeDescription('math/add/color', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Add));
+const Subtract$6 = new NodeDescription('math/subtract/color', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Subtract));
+const Negate$7 = new NodeDescription('math/negate/color', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', vec3Negate));
+const Scale$7 = new NodeDescription('math/scale/color', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'float'], 'color', vec3MultiplyByScalar));
+const Mix$6 = new NodeDescription('math/mix/color', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'color', vec3Mix, ['a', 'b', 't']));
+const HslToColor = new NodeDescription('math/ToColor/hsl', 'Logic', 'HSL to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'color', hslToRGB));
+const ColorToHsl = new NodeDescription('math/toHsl/color', 'Logic', 'Color to HSL', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'vec3', rgbToHSL));
+const HexToColor = new NodeDescription('math/toColor/hex', 'Logic', 'HEX to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'color', hexToRGB));
+const ColorToHex = new NodeDescription('math/toHex/color', 'Logic', 'Color to HEX', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'float', rgbToHex));
+const Equal$7 = new NodeDescription('math/equal/color', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var ColorNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$7,
+  Create: Create$5,
+  Elements: Elements$7,
+  Add: Add$6,
+  Subtract: Subtract$6,
+  Negate: Negate$7,
+  Scale: Scale$7,
+  Mix: Mix$6,
+  HslToColor: HslToColor,
+  ColorToHsl: ColorToHsl,
+  HexToColor: HexToColor,
+  ColorToHex: ColorToHex,
+  Equal: Equal$7
+});
+
+const Constant$6 = new NodeDescription('math/euler', 'Logic', 'Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', a => a));
+const Create$4 = new NodeDescription('math/toEuler/float', 'Logic', 'Float to Euler', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'euler', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$6 = new NodeDescription('math/toFloat/euler', 'Logic', 'Euler to Float', (description, graph) => new VecElements(description, graph, 'euler', ['x', 'y', 'z'], vec3ToArray));
+const Add$5 = new NodeDescription('math/add/euler', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Add));
+const Subtract$5 = new NodeDescription('math/subtract/euler', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Subtract));
+const Negate$6 = new NodeDescription('math/negate/euler', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', vec3Negate));
+const Scale$6 = new NodeDescription('math/scale/euler', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'float'], 'euler', vec3MultiplyByScalar));
+const Mix$5 = new NodeDescription('math/mix/euler', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'euler', vec3Mix, ['a', 'b', 't']));
+const Mat3ToEuler = new NodeDescription('math/toEuler/mat3', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'euler', mat3ToEuler));
+const Mat4ToEuler = new NodeDescription('math/toEuler/mat4', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'euler', mat4ToEuler));
+const QuatToEuler = new NodeDescription('math/toEuler/quat', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'euler', quatToEuler));
+const Equal$6 = new NodeDescription('math/equal/euler', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var EulerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$6,
+  Create: Create$4,
+  Elements: Elements$6,
+  Add: Add$5,
+  Subtract: Subtract$5,
+  Negate: Negate$6,
+  Scale: Scale$6,
+  Mix: Mix$5,
+  Mat3ToEuler: Mat3ToEuler,
+  Mat4ToEuler: Mat4ToEuler,
+  QuatToEuler: QuatToEuler,
+  Equal: Equal$6
+});
+
+const Constant$5 = new NodeDescription('math/vec2', 'Logic', 'Vec2', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', a => a));
+const Create$3 = new NodeDescription('math/toVec2/float', 'Logic', 'Float to Vec2', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'vec2', (x, y) => new Vec2(x, y), ['x', 'y']));
+const Elements$5 = new NodeDescription('math/toFloat/vec2', 'Logic', 'Vec2 To Float', (description, graph) => new VecElements(description, graph, 'vec2', ['x', 'y', 'z'], vec2ToArray));
+const Add$4 = new NodeDescription('math/add/vec2', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Add));
+const Subtract$4 = new NodeDescription('math/subtract/vec2', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Subtract));
+const Negate$5 = new NodeDescription('math/negate/vec2', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Negate));
+const Scale$5 = new NodeDescription('math/scale/vec2', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'float'], 'vec2', vec2MultiplyByScalar));
+const Length$3 = new NodeDescription('math/length/vec2', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'float', vec2Length));
+const Normalize$3 = new NodeDescription('math/normalize/vec2', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Normalize));
+const Dot$3 = new NodeDescription('math/dot/vec2', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'float', vec2Dot));
+const Mix$4 = new NodeDescription('math/mix/vec2', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'vec2', vec2Mix, ['a', 'b', 't']));
+const Equal$5 = new NodeDescription('math/equal/vec2', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'boolean', vec2Equals, ['a', 'b', 'tolerance']));
+
+var Vec2Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$5,
+  Create: Create$3,
+  Elements: Elements$5,
+  Add: Add$4,
+  Subtract: Subtract$4,
+  Negate: Negate$5,
+  Scale: Scale$5,
+  Length: Length$3,
+  Normalize: Normalize$3,
+  Dot: Dot$3,
+  Mix: Mix$4,
+  Equal: Equal$5
+});
+
+const Constant$4 = new NodeDescription('math/vec3', 'Logic', 'Vec3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', a => a));
+const Create$2 = new NodeDescription('math/toVec3/float', 'Logic', 'Float to Vec3', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'vec3', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$4 = new NodeDescription('math/toFloat/vec3', 'Logic', 'Vec3 To Float', (description, graph) => new VecElements(description, graph, 'vec3', ['x', 'y', 'z'], vec3ToArray));
+const Add$3 = new NodeDescription('math/add/vec3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Add));
+const Subtract$3 = new NodeDescription('math/subtract/vec3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Subtract));
+const Negate$4 = new NodeDescription('math/negate/vec3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Negate));
+const Scale$4 = new NodeDescription('math/scale/vec3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'float'], 'vec3', vec3MultiplyByScalar));
+const Length$2 = new NodeDescription('math/length/vec3', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'float', vec3Length));
+const Normalize$2 = new NodeDescription('math/normalize/vec3', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Normalize));
+const Cross = new NodeDescription('math/cross/vec3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Cross));
+const Dot$2 = new NodeDescription('math/dot/vec3', 'Logic', 'Dot', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'float', vec3Dot));
+const Mix$3 = new NodeDescription('math/mix/vec3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'vec3', vec3Mix, ['a', 'b', 't']));
+const Equal$4 = new NodeDescription('math/equal/vec3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var Vec3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$4,
+  Create: Create$2,
+  Elements: Elements$4,
+  Add: Add$3,
+  Subtract: Subtract$3,
+  Negate: Negate$4,
+  Scale: Scale$4,
+  Length: Length$2,
+  Normalize: Normalize$2,
+  Cross: Cross,
+  Dot: Dot$2,
+  Mix: Mix$3,
+  Equal: Equal$4
+});
+
+const Constant$3 = new NodeDescription('math/vec4', 'Logic', 'Vec4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', a => a));
+const Create$1 = new NodeDescription('math/toVec4/float', 'Logic', 'Float to Vec4', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'vec4', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$3 = new NodeDescription('math/toFloat/vec4', 'Logic', 'Vec4 to Float', (description, graph) => new VecElements(description, graph, 'vec4', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Add$2 = new NodeDescription('math/add/vec4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Add));
+const Subtract$2 = new NodeDescription('math/subtract/vec4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Subtract));
+const Negate$3 = new NodeDescription('math/negate/vec4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Negate));
+const Scale$3 = new NodeDescription('math/scale/vec4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'float'], 'vec4', vec4MultiplyByScalar));
+const Length$1 = new NodeDescription('math/length/vec4', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'float', vec4Length));
+const Normalize$1 = new NodeDescription('math/normalize/vec4', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Normalize));
+const Dot$1 = new NodeDescription('math/dot/vec4', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'float', vec4Dot));
+const Mix$2 = new NodeDescription('math/mix/vec4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'vec4', vec4Mix, ['a', 'b', 't']));
+const Equal$3 = new NodeDescription('math/equal/vec4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var Vec4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$3,
+  Create: Create$1,
+  Elements: Elements$3,
+  Add: Add$2,
+  Subtract: Subtract$2,
+  Negate: Negate$3,
+  Scale: Scale$3,
+  Length: Length$1,
+  Normalize: Normalize$1,
+  Dot: Dot$1,
+  Mix: Mix$2,
+  Equal: Equal$3
+});
+
+/*
+- from Angle Axis
+- from Euler
+- to Angle Axis
+- to Euler
+- Conjugate
+- Multiply
+- Slerp
+- Squad
+- Scale
+- 
+*/
+
+const Constant$2 = new NodeDescription('math/quat', 'Logic', 'Quaternion', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', a => a));
+const Create = new NodeDescription('math/toQuat/float', 'Logic', 'Float to Quat', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'quat', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$2 = new NodeDescription('math/toFloat/quat', 'Logic', 'Quat to Float', (description, graph) => new VecElements(description, graph, 'quat', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Negate$2 = new NodeDescription('math/conjugate/quat', 'Logic', 'Conjugate', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatConjugate));
+const Multiply$2 = new NodeDescription('math/multiply/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'quat', quatMultiply));
+const Scale$2 = new NodeDescription('math/scale/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', vec4MultiplyByScalar));
+const Length = new NodeDescription('math/length/quat', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'float', vec4Length));
+const Normalize = new NodeDescription('math/normalize/quat', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', vec4Normalize));
+const Dot = new NodeDescription('math/dot/quat', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'float', vec4Dot));
+const Ln = new NodeDescription('math/ln/quat', 'Logic', 'Ln', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatLn));
+const Exp = new NodeDescription('math/exp/quat', 'Logic', 'Exp', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatExp));
+const Pow = new NodeDescription('math/pow/quat', 'Logic', 'Pow', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', quatPow));
+const Mat3ToQuat = new NodeDescription('math/toQuat/mat3', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'quat', mat3ToQuat));
+const Mat4ToQuat = new NodeDescription('math/toQuat/mat4', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'quat', mat4ToQuat));
+const EulerToQuat = new NodeDescription('math/toQuat/euler', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'quat', eulerToQuat));
+const AngleAxisToQuat = new NodeDescription('math/toQuat/angleAxis', 'Logic', 'Angle Axis to Quat', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'vec3'], 'quat', angleAxisToQuat));
+const Slerp = new NodeDescription('math/slerp/quat', 'Logic', 'Slerp', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'quat', quatSlerp, ['a', 'b', 't']));
+const Equal$2 = new NodeDescription('math/equal/quat', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var QuatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$2,
+  Create: Create,
+  Elements: Elements$2,
+  Negate: Negate$2,
+  Multiply: Multiply$2,
+  Scale: Scale$2,
+  Length: Length,
+  Normalize: Normalize,
+  Dot: Dot,
+  Ln: Ln,
+  Exp: Exp,
+  Pow: Pow,
+  Mat3ToQuat: Mat3ToQuat,
+  Mat4ToQuat: Mat4ToQuat,
+  EulerToQuat: EulerToQuat,
+  AngleAxisToQuat: AngleAxisToQuat,
+  Slerp: Slerp,
+  Equal: Equal$2
+});
+
+const Constant$1 = new NodeDescription('math/mat3', 'Logic', 'Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', a => a));
+const Column3ToMat3 = new NodeDescription('math/toMat3/column3', 'Logic', 'Columns to Mat3', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat3', column3ToMat3));
+const SetColumn$1 = new NodeDescription('math/setColumn/mat3', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetColumn3));
+const SetRow$1 = new NodeDescription('math/setRow/mat3', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetRow3));
+const Elements$1 = new NodeDescription('math/toVec3/mat3', 'Logic', 'Mat3 To Vec3', (description, graph) => new VecElements(description, graph, 'mat3', ['x', 'y', 'z'], () => {
+  throw new Error('not implemented');
+}));
+const Add$1 = new NodeDescription('math/add/mat3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Add));
+const Subtract$1 = new NodeDescription('math/subtract/mat3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Subtract));
+const Negate$1 = new NodeDescription('math/negate/mat3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Negate));
+const Scale$1 = new NodeDescription('math/scale/mat3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'float'], 'mat3', mat3MultiplyByScalar));
+const Determinant$1 = new NodeDescription('math/determinant/mat3', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'float', mat3Determinant));
+const Inverse$1 = new NodeDescription('math/inverse/mat3', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Inverse));
+const Mat4ToMat3 = new NodeDescription('math/toMat3/mat4', 'Logic', 'Mat4 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat3', mat4ToMat3));
+const Transpose$1 = new NodeDescription('math/transpose/mat3', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Transpose));
+const Multiply$1 = new NodeDescription('math/multiply/mat3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Multiply));
+const Mix$1 = new NodeDescription('math/mix/mat3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'mat3', mat3Mix, ['a', 'b', 't']));
+const Equal$1 = new NodeDescription('math/equal/mat3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'boolean', mat3Equals, ['a', 'b', 'tolerance']));
+const EulerToMat3 = new NodeDescription('math/toMat3/euler', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat3', eulerToMat3));
+const QuatToMat3 = new NodeDescription('math/toMat3/quat', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat3', eulerToMat3));
+const Scale2ToMat3 = new NodeDescription('math/toMat3/scale2', 'Logic', 'Scale2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', scale2ToMat3));
+const Mat3ToScale2 = new NodeDescription('math/toScale2/mat3', 'Logic', 'Mat3 to Scale2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToScale2));
+const Translation2ToMat3 = new NodeDescription('math/toMat3/translation2', 'Logic', 'Translation2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', translation2ToMat3));
+const Mat3ToTranslation3 = new NodeDescription('math/toTranslation2/mat3', 'Logic', 'Mat3 to Translation2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToTranslation2));
+
+var Mat3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$1,
+  Column3ToMat3: Column3ToMat3,
+  SetColumn: SetColumn$1,
+  SetRow: SetRow$1,
+  Elements: Elements$1,
+  Add: Add$1,
+  Subtract: Subtract$1,
+  Negate: Negate$1,
+  Scale: Scale$1,
+  Determinant: Determinant$1,
+  Inverse: Inverse$1,
+  Mat4ToMat3: Mat4ToMat3,
+  Transpose: Transpose$1,
+  Multiply: Multiply$1,
+  Mix: Mix$1,
+  Equal: Equal$1,
+  EulerToMat3: EulerToMat3,
+  QuatToMat3: QuatToMat3,
+  Scale2ToMat3: Scale2ToMat3,
+  Mat3ToScale2: Mat3ToScale2,
+  Translation2ToMat3: Translation2ToMat3,
+  Mat3ToTranslation3: Mat3ToTranslation3
+});
+
+const Mat3Value = new ValueType('mat3', () => new Mat3(), value => typeof value === 'string' ? mat3Parse(value) : new Mat3(value), value => value.elements, (start, end, t) => mat3Mix(start, end, t));
+
+class In5Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e']) {
+    if (inputValueTypes.length !== 5) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 5, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 5) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 5, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In6Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e', 'f']) {
+    if (inputValueTypes.length !== 6) {
+      throw new Error(`inputValueTypes of ${description.typeName} must have a length of 6, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 6) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 6, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4]), new Socket(inputValueTypes[5], inputNames[5])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4]), this.readInput(inputNames[5])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, z, 1 ) x [ 0  4   8  12] = ( x', y', z', 1 )
+//                  [ 1  5   9  13]
+//                  [ 2  6  10  14]
+//                  [ 3  7  11  15]
+// where elements 3, 7, 11 would be translation in 3D, as they would multiplied
+// by the last virtual element of the 3D vector.
+const NUM_ROWS = 4;
+const NUM_COLUMNS = 4;
+const NUM_ELEMENTS = NUM_ROWS * NUM_COLUMNS;
+class Mat4 {
+  constructor(elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat4()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat4SetColumn4(m, columnIndex, column, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(columnIndex) * NUM_ROWS;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  re[base + 3] = column.w;
+  return result;
+}
+function mat4SetRow4(m, rowIndex, row, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(rowIndex);
+  re[base + NUM_COLUMNS * 0] = row.x;
+  re[base + NUM_COLUMNS * 1] = row.y;
+  re[base + NUM_COLUMNS * 2] = row.z;
+  re[base + NUM_COLUMNS * 3] = row.w;
+  return result;
+}
+function column4ToMat4(a, b, c, d, result = new Mat4()) {
+  const re = result.elements;
+  const columns = [a, b, c, d];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+    re[base + 3] = column.w;
+  }
+  return result;
+}
+function mat4Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat4Add(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat4Subtract(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat4MultiplyByScalar(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat4Negate(a, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat4Multiply(a, b, result = new Mat4()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[4],
+    a13 = ae[8],
+    a14 = ae[12];
+  const a21 = ae[1],
+    a22 = ae[5],
+    a23 = ae[9],
+    a24 = ae[13];
+  const a31 = ae[2],
+    a32 = ae[6],
+    a33 = ae[10],
+    a34 = ae[14];
+  const a41 = ae[3],
+    a42 = ae[7],
+    a43 = ae[11],
+    a44 = ae[15];
+  const b11 = be[0],
+    b12 = be[4],
+    b13 = be[8],
+    b14 = be[12];
+  const b21 = be[1],
+    b22 = be[5],
+    b23 = be[9],
+    b24 = be[13];
+  const b31 = be[2],
+    b32 = be[6],
+    b33 = be[10],
+    b34 = be[14];
+  const b41 = be[3],
+    b42 = be[7],
+    b43 = be[11],
+    b44 = be[15];
+
+  // TODO: Replace with set(...)
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
+  te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
+  te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
+  te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
+  te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
+  te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
+  te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
+  te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
+  te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
+  te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
+  te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
+  te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
+  te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
+  te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
+  return result;
+}
+function mat4Determinant(m) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  return n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+}
+function mat4Adjoint(m, result = new Mat4()) {
+  // from gl-matrix
+  const a = m.elements;
+  const out = result.elements;
+  const a00 = a[0],
+    a01 = a[1],
+    a02 = a[2],
+    a03 = a[3];
+  const a10 = a[4],
+    a11 = a[5],
+    a12 = a[6],
+    a13 = a[7];
+  const a20 = a[8],
+    a21 = a[9],
+    a22 = a[10],
+    a23 = a[11];
+  const a30 = a[12],
+    a31 = a[13],
+    a32 = a[14],
+    a33 = a[15];
+  const b00 = a00 * a11 - a01 * a10;
+  const b01 = a00 * a12 - a02 * a10;
+  const b02 = a00 * a13 - a03 * a10;
+  const b03 = a01 * a12 - a02 * a11;
+  const b04 = a01 * a13 - a03 * a11;
+  const b05 = a02 * a13 - a03 * a12;
+  const b06 = a20 * a31 - a21 * a30;
+  const b07 = a20 * a32 - a22 * a30;
+  const b08 = a20 * a33 - a23 * a30;
+  const b09 = a21 * a32 - a22 * a31;
+  const b10 = a21 * a33 - a23 * a31;
+  const b11 = a22 * a33 - a23 * a32;
+  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
+  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
+  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
+  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
+  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
+  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
+  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
+  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
+  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
+  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
+  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
+  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
+  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
+  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
+  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
+  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
+  return result;
+}
+function mat4Transpose(m, result = new Mat4()) {
+  const re = m.clone(result).elements;
+  let tmp;
+
+  // TODO: replace this with just reading from me and setting re, no need for a temporary
+  tmp = re[1];
+  re[1] = re[4];
+  re[4] = tmp;
+  tmp = re[2];
+  re[2] = re[8];
+  re[8] = tmp;
+  tmp = re[6];
+  re[6] = re[9];
+  re[9] = tmp;
+  tmp = re[3];
+  re[3] = re[12];
+  re[12] = tmp;
+  tmp = re[7];
+  re[7] = re[13];
+  re[13] = tmp;
+  tmp = re[11];
+  re[11] = re[14];
+  re[14] = tmp;
+  return result;
+}
+function mat4Inverse(m, result = new Mat4()) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+
+  // TODO: replace with a set
+  const re = result.elements;
+  re[0] = t11 * detInv;
+  re[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
+  re[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
+  re[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
+  re[4] = t12 * detInv;
+  re[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
+  re[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
+  re[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
+  re[8] = t13 * detInv;
+  re[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
+  re[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
+  re[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
+  re[12] = t14 * detInv;
+  re[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
+  re[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
+  re[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
+  return result;
+}
+function mat4Mix(a, b, t, result = new Mat4()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat4FromArray(array, offset = 0, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat4Parse(text, result = new Mat4()) {
+  return mat4FromArray(parseSafeFloats(text), 0, result);
+}
+function mat3ToMat4(a, result = new Mat4()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], 0, ae[3], ae[4], ae[5], 0, ae[6], ae[7], ae[8], 0, 0, 0, 0, 1]);
+}
+function eulerToMat4(e, result = new Mat4()) {
+  return mat3ToMat4(eulerToMat3(e), result);
+}
+function quatToMat4(q, result = new Mat4()) {
+  return mat3ToMat4(quatToMat3(q), result);
+}
+function scale3ToMat4(s, result = new Mat4()) {
+  return result.set([s.x, 0, 0, 0, 0, s.y, 0, 0, 0, 0, s.z, 0, 0, 0, 0, 1]);
+}
+function translation3ToMat4(t, result = new Mat4()) {
+  return result.set([1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1]);
+}
+function mat4Translate(m, t, result = new Mat4()) {
+  return mat4Multiply(m, translation3ToMat4(t), result);
+}
+function mat4Scale(m, s, result = new Mat4()) {
+  return mat4Multiply(m, scale3ToMat4(s), result);
+}
+function mat4RotateByQuat(m, q, result = new Mat4()) {
+  return mat4Multiply(m, quatToMat4(q), result);
+}
+function mat4RotateByEuler(m, e, result = new Mat4()) {
+  return mat4Multiply(m, eulerToMat4(e), result);
+}
+function mat4TransformPoint3(m, v, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
+  result.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
+  result.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
+  result.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
+  return result;
+}
+function mat4TransformNormal3(v, m, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  result.x = e[0] * x + e[4] * y + e[8] * z;
+  result.y = e[1] * x + e[5] * y + e[9] * z;
+  result.z = e[2] * x + e[6] * y + e[10] * z;
+  return vec3Normalize(result, result);
+}
+function mat4Perspective(left, right, top, bottom, near, far, result = new Mat4()) {
+  const x = 2 * near / (right - left);
+  const y = 2 * near / (top - bottom);
+  const a = (right + left) / (right - left);
+  const b = (top + bottom) / (top - bottom);
+  const c = -(far + near) / (far - near);
+  const d = -2 * far * near / (far - near);
+  return result.set([x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0]);
+}
+function mat4PerspectiveFov(verticalFov, near, far, zoom, aspectRatio, result = new Mat4()) {
+  const height = 2 * near * Math.tan(verticalFov * Math.PI / 180) / zoom;
+  const width = height * aspectRatio;
+
+  // NOTE: OpenGL screen coordinates are -bottomt to +top, -left to +right.
+
+  const right = width * 0.5;
+  const left = right - width;
+  const top = height * 0.5;
+  const bottom = top - height;
+  return mat4Perspective(left, right, top, bottom, near, far, result);
+}
+
+// TODO: Replace with a Box3?
+function mat4Orthogonal(left, right, top, bottom, near, far, result = new Mat4()) {
+  const w = 1 / (right - left);
+  const h = 1 / (top - bottom);
+  const p = 1 / (far - near);
+  const x = (right + left) * w;
+  const y = (top + bottom) * h;
+  const z = (far + near) * p;
+  return result.set([2 * w, 0, 0, -x, 0, 2 * h, 0, -y, 0, 0, -2 * p, -z, 0, 0, 0, 1]);
+}
+function mat4OrthogonalSimple(height, center, near, far, zoom, aspectRatio = 1, result = new Mat4()) {
+  height /= zoom;
+  const width = height * aspectRatio;
+  const left = -width * 0.5 + center.x;
+  const right = left + width;
+  const top = -height * 0.5 + center.y;
+  const bottom = top + height;
+  return mat4Orthogonal(left, right, top, bottom, near, far, result);
+}
+function mat4LookAt(eye, target, up, result = new Mat4()) {
+  const te = result.elements;
+  const look = vec3Subtract(eye, target);
+  const lookLength = vec3Length(look);
+  if (lookLength === 0) {
+    look.z = 1;
+  } else {
+    vec3MultiplyByScalar(look, 1 / lookLength, look);
+  }
+  const right = vec3Cross(up, look);
+  const rightLength = vec3Length(right);
+  if (rightLength === 0) {
+    // up and z are parallel
+
+    if (Math.abs(up.z) === 1) {
+      up.x += 0.0001;
+    } else {
+      up.z += 0.0001;
+    }
+    vec3Normalize(up, up);
+    vec3Cross(right, up, right);
+  } else {
+    vec3MultiplyByScalar(right, 1 / rightLength, right);
+  }
+  const up2 = vec3Cross(look, right);
+  te[0] = right.x;
+  te[4] = up2.x;
+  te[8] = look.x;
+  te[1] = right.y;
+  te[5] = up2.y;
+  te[9] = look.y;
+  te[2] = right.z;
+  te[6] = up2.z;
+  te[10] = look.z;
+  return result;
+}
+
+const Constant = new NodeDescription('math/mat4', 'Logic', 'Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', a => a));
+const Column4ToMat4 = new NodeDescription('math/toMat4/column4', 'Logic', 'Columns to Mat4', (description, graph) => new In4Out1FuncNode(description, graph, ['vec4', 'vec4', 'vec4', 'vec4'], 'mat4', column4ToMat4));
+const SetColumn = new NodeDescription('math/setColumn/mat4', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetColumn4));
+const SetRow = new NodeDescription('math/setRow/mat4', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetRow4));
+const Elements = new NodeDescription('math/toVec4/mat4', 'Logic', 'Mat4 To Vec4', (description, graph) => new VecElements(description, graph, 'mat4', ['x', 'y', 'z', 'w'], () => {
+  throw new Error('not implemented');
+}));
+const Add = new NodeDescription('math/add/mat4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Add));
+const Subtract = new NodeDescription('math/subtract/mat4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Subtract));
+const Negate = new NodeDescription('math/negate/mat4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Negate));
+const MultiplyByScalar = new NodeDescription('math/multiplyByScalar/mat4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'float'], 'mat4', mat4MultiplyByScalar));
+const Determinant = new NodeDescription('math/determinant/mat4', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'float', mat4Determinant));
+const Adjoint = new NodeDescription('math/adjoint/mat4', 'Logic', 'Adjoint', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Adjoint));
+const Inverse = new NodeDescription('math/inverse/mat4', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Inverse));
+const Transpose = new NodeDescription('math/transpose/mat4', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Transpose));
+const Mat3ToMat4 = new NodeDescription('math/toMat4/mat3', 'Logic', 'Mat3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat4', mat3ToMat4));
+const Scale3ToMat4 = new NodeDescription('math/toMat4/scale3', 'Logic', 'Scale3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', scale3ToMat4));
+const Translate3ToMat4 = new NodeDescription('math/toMat4/translate3', 'Logic', 'Translate3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', translation3ToMat4));
+const QuatToMat4 = new NodeDescription('math/toMat4/quat', 'Logic', 'Quat To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat4', quatToMat4));
+const EulerToMat4 = new NodeDescription('math/toMat4/euler', 'Logic', 'Euler To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat4', eulerToMat4));
+const Translate = new NodeDescription('math/translate/mat4', 'Logic', 'Translate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Translate));
+const Scale = new NodeDescription('math/scale/mat4', 'Logic', 'Scale', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Scale));
+const RotateByQuat = new NodeDescription('math/rotateByQuat/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'quat'], 'mat4', mat4RotateByQuat));
+const RotateByEuler = new NodeDescription('math/rotateByEuler/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'euler'], 'mat4', mat4RotateByEuler));
+const Multiply = new NodeDescription('math/multiply/mat4', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Multiply));
+const Mix = new NodeDescription('math/mix/mat4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'mat4', mat4Mix, ['a', 'b', 't']));
+const Equal = new NodeDescription('math/equal/mat4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'boolean', mat4Equals, ['a', 'b', 'tolerance']));
+const TransformPoint3 = new NodeDescription('math/transformPoint3/mat4', 'Logic', 'Transform Point3', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformPoint3));
+const TransformNormal3 = new NodeDescription('math/transformNormal3/mat4', 'Logic', 'Transform Normal', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformNormal3));
+const Perspective = new NodeDescription('math/perspective/mat4', 'Logic', 'Perspective', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Perspective, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const PerspectiveFov = new NodeDescription('math/perspectiveFov/mat4', 'Logic', 'Perspective FOV', (description, graph) => new In5Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float'], 'mat4', mat4PerspectiveFov, ['verticalFov', 'near', 'far', 'zoom', 'aspectRatio']));
+const Orthographic = new NodeDescription('math/orthographic/mat4', 'Logic', 'Orthographic', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Orthogonal, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const OrthographicSimple = new NodeDescription('math/orthographicSimple/mat4', 'Logic', 'Orthographic Simple', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'vec2', 'float', 'float', 'float', 'float'], 'mat4', mat4OrthogonalSimple, ['height', 'center', 'near', 'far', 'zoom', 'aspectRatio']));
+const LookAt = new NodeDescription('math/lookAt/mat4', 'Logic', 'Look At', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat4', mat4LookAt, ['eye', 'target', 'up']));
+
+var Mat4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant,
+  Column4ToMat4: Column4ToMat4,
+  SetColumn: SetColumn,
+  SetRow: SetRow,
+  Elements: Elements,
+  Add: Add,
+  Subtract: Subtract,
+  Negate: Negate,
+  MultiplyByScalar: MultiplyByScalar,
+  Determinant: Determinant,
+  Adjoint: Adjoint,
+  Inverse: Inverse,
+  Transpose: Transpose,
+  Mat3ToMat4: Mat3ToMat4,
+  Scale3ToMat4: Scale3ToMat4,
+  Translate3ToMat4: Translate3ToMat4,
+  QuatToMat4: QuatToMat4,
+  EulerToMat4: EulerToMat4,
+  Translate: Translate,
+  Scale: Scale,
+  RotateByQuat: RotateByQuat,
+  RotateByEuler: RotateByEuler,
+  Multiply: Multiply,
+  Mix: Mix,
+  Equal: Equal,
+  TransformPoint3: TransformPoint3,
+  TransformNormal3: TransformNormal3,
+  Perspective: Perspective,
+  PerspectiveFov: PerspectiveFov,
+  Orthographic: Orthographic,
+  OrthographicSimple: OrthographicSimple,
+  LookAt: LookAt
+});
+
+const Mat4Value = new ValueType('mat4', () => new Mat4(), value => typeof value === 'string' ? mat4Parse(value) : new Mat4(value), value => value.elements, (start, end, t) => mat4Mix(start, end, t));
+
+/* eslint-disable max-len */
+function registerSceneProfile(registry, scene = new DummyScene()) {
+  const {
+    values,
+    nodes
+  } = registry;
+
+  // pull in value type nodes
+  values.register(Vec2Value);
+  values.register(Vec3Value);
+  values.register(Vec4Value);
+  values.register(ColorValue);
+  values.register(EulerValue);
+  values.register(QuatValue);
+  values.register(Mat3Value);
+  values.register(Mat4Value);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(Vec2Nodes));
+  nodes.register(...getNodeDescriptions(Vec3Nodes));
+  nodes.register(...getNodeDescriptions(Vec4Nodes));
+  nodes.register(...getNodeDescriptions(ColorNodes));
+  nodes.register(...getNodeDescriptions(EulerNodes));
+  nodes.register(...getNodeDescriptions(QuatNodes));
+  nodes.register(...getNodeDescriptions(Mat3Nodes));
+  nodes.register(...getNodeDescriptions(Mat4Nodes));
+
+  // events
+
+  nodes.register(OnSceneNodeClick.Description);
+
+  // actions
+  const allValueTypeNames = values.getAllNames();
+  nodes.register(...SetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  nodes.register(...GetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  const newValueTypeNames = ['vec2', 'vec3', 'vec4', 'quat', 'euler', 'color', 'mat3', 'mat4'];
+
+  // variables
+
+  newValueTypeNames.forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+exports.Assert = Assert;
+exports.AsyncNode = AsyncNode;
+exports.AsyncNode2 = AsyncNode2;
+exports.BooleanNodes = BooleanNodes;
+exports.BooleanValue = BooleanValue;
+exports.Branch = Branch;
+exports.ColorNodes = ColorNodes;
+exports.ColorValue = ColorValue;
+exports.Counter = Counter;
+exports.CustomEvent = CustomEvent;
+exports.Debounce = Debounce;
+exports.DefaultLogger = DefaultLogger;
+exports.Delay = Delay;
+exports.DoN = DoN;
+exports.DoOnce = DoOnce;
+exports.DummyScene = DummyScene;
+exports.Engine = Engine;
+exports.EulerNodes = EulerNodes;
+exports.EulerValue = EulerValue;
+exports.EventEmitter = EventEmitter;
+exports.EventNode = EventNode;
+exports.EventNode2 = EventNode2;
+exports.ExpectTrue = ExpectTrue;
+exports.Fiber = Fiber;
+exports.FlipFlop = FlipFlop;
+exports.FloatNodes = FloatNodes;
+exports.FloatValue = FloatValue;
+exports.FlowNode = FlowNode;
+exports.FlowNode2 = FlowNode2;
+exports.ForLoop = ForLoop;
+exports.Gate = Gate;
+exports.GetSceneProperty = GetSceneProperty;
+exports.Graph = Graph;
+exports.ImmediateNode = ImmediateNode;
+exports.ImmediateNode2 = ImmediateNode2;
+exports.In0Out1FuncNode = In0Out1FuncNode;
+exports.In1Out1FuncNode = In1Out1FuncNode;
+exports.In2Out1FuncNode = In2Out1FuncNode;
+exports.In3Out1FuncNode = In3Out1FuncNode;
+exports.In4Out1FuncNode = In4Out1FuncNode;
+exports.IntegerNodes = IntegerNodes;
+exports.IntegerValue = IntegerValue;
+exports.LifecycleOnEnd = LifecycleOnEnd;
+exports.LifecycleOnStart = LifecycleOnStart;
+exports.LifecycleOnTick = LifecycleOnTick;
+exports.Link = Link;
+exports.Log = Log;
+exports.Logger = Logger;
+exports.ManualLifecycleEventEmitter = ManualLifecycleEventEmitter;
+exports.MultiGate = MultiGate;
+exports.Node = Node;
+exports.NodeDescription = NodeDescription;
+exports.NodeDescription2 = NodeDescription2;
+exports.NodeTypeRegistry = NodeTypeRegistry;
+exports.OnCustomEvent = OnCustomEvent;
+exports.OnSceneNodeClick = OnSceneNodeClick;
+exports.QuatNodes = QuatNodes;
+exports.QuatValue = QuatValue;
+exports.Registry = Registry;
+exports.Sequence = Sequence;
+exports.SetSceneProperty = SetSceneProperty;
+exports.Socket = Socket;
+exports.StringNodes = StringNodes;
+exports.StringValue = StringValue;
+exports.Throttle = Throttle;
+exports.TriggerCustomEvent = TriggerCustomEvent;
+exports.ValueType = ValueType;
+exports.ValueTypeRegistry = ValueTypeRegistry;
+exports.Variable = Variable;
+exports.VariableGet = VariableGet;
+exports.VariableSet = VariableSet;
+exports.Vec2 = Vec2;
+exports.Vec2Nodes = Vec2Nodes;
+exports.Vec2Value = Vec2Value;
+exports.Vec3 = Vec3;
+exports.Vec3Nodes = Vec3Nodes;
+exports.Vec3Value = Vec3Value;
+exports.Vec4 = Vec4;
+exports.Vec4Nodes = Vec4Nodes;
+exports.Vec4Value = Vec4Value;
+exports.VecElements = VecElements;
+exports.WaitAll = WaitAll;
+exports.angleAxisToQuat = angleAxisToQuat;
+exports.eulerToQuat = eulerToQuat;
+exports.getNodeDescriptions = getNodeDescriptions;
+exports.hexToRGB = hexToRGB;
+exports.hslToRGB = hslToRGB;
+exports.mat3ToEuler = mat3ToEuler;
+exports.mat3ToQuat = mat3ToQuat;
+exports.mat4ToEuler = mat4ToEuler;
+exports.mat4ToQuat = mat4ToQuat;
+exports.parseSafeFloat = parseSafeFloat;
+exports.parseSafeFloats = parseSafeFloats;
+exports.quatConjugate = quatConjugate;
+exports.quatExp = quatExp;
+exports.quatLn = quatLn;
+exports.quatMultiply = quatMultiply;
+exports.quatPow = quatPow;
+exports.quatSlerp = quatSlerp;
+exports.quatToAngleAxis = quatToAngleAxis;
+exports.quatToEuler = quatToEuler;
+exports.readGraphFromJSON = readGraphFromJSON;
+exports.registerCoreProfile = registerCoreProfile;
+exports.registerSceneProfile = registerSceneProfile;
+exports.rgbToHSL = rgbToHSL;
+exports.rgbToHex = rgbToHex;
+exports.toSafeString = toSafeString;
+exports.validateGraph = validateGraph;
+exports.validateGraphAcyclic = validateGraphAcyclic;
+exports.validateGraphLinks = validateGraphLinks;
+exports.validateNodeRegistry = validateNodeRegistry;
+exports.validateRegistry = validateRegistry;
+exports.validateValueRegistry = validateValueRegistry;
+exports.vec2Add = vec2Add;
+exports.vec2Dot = vec2Dot;
+exports.vec2Equals = vec2Equals;
+exports.vec2FromArray = vec2FromArray;
+exports.vec2Length = vec2Length;
+exports.vec2Mix = vec2Mix;
+exports.vec2MultiplyByScalar = vec2MultiplyByScalar;
+exports.vec2Negate = vec2Negate;
+exports.vec2Normalize = vec2Normalize;
+exports.vec2Parse = vec2Parse;
+exports.vec2Subtract = vec2Subtract;
+exports.vec2ToArray = vec2ToArray;
+exports.vec2ToString = vec2ToString;
+exports.vec3Add = vec3Add;
+exports.vec3Cross = vec3Cross;
+exports.vec3Dot = vec3Dot;
+exports.vec3Equals = vec3Equals;
+exports.vec3FromArray = vec3FromArray;
+exports.vec3Length = vec3Length;
+exports.vec3Mix = vec3Mix;
+exports.vec3MultiplyByScalar = vec3MultiplyByScalar;
+exports.vec3Negate = vec3Negate;
+exports.vec3Normalize = vec3Normalize;
+exports.vec3Parse = vec3Parse;
+exports.vec3Subtract = vec3Subtract;
+exports.vec3ToArray = vec3ToArray;
+exports.vec3ToString = vec3ToString;
+exports.vec4Add = vec4Add;
+exports.vec4Dot = vec4Dot;
+exports.vec4Equals = vec4Equals;
+exports.vec4FromArray = vec4FromArray;
+exports.vec4Length = vec4Length;
+exports.vec4Mix = vec4Mix;
+exports.vec4MultiplyByScalar = vec4MultiplyByScalar;
+exports.vec4Negate = vec4Negate;
+exports.vec4Normalize = vec4Normalize;
+exports.vec4Parse = vec4Parse;
+exports.vec4Subtract = vec4Subtract;
+exports.vec4ToArray = vec4ToArray;
+exports.vec4ToString = vec4ToString;
+exports.writeGraphToJSON = writeGraphToJSON;
+exports.writeNodeSpecsToJSON = writeNodeSpecsToJSON;
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.js b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.js
new file mode 100644
index 0000000..0499d24
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.js
@@ -0,0 +1,7 @@
+'use strict';
+
+if (process.env.NODE_ENV === "production") {
+  module.exports = require("./behave-graph-core.cjs.prod.js");
+} else {
+  module.exports = require("./behave-graph-core.cjs.dev.js");
+}
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.prod.js b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.prod.js
new file mode 100644
index 0000000..72f5582
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.cjs.prod.js
@@ -0,0 +1,4171 @@
+'use strict';
+
+Object.defineProperty(exports, '__esModule', { value: true });
+
+function _toPrimitive(input, hint) {
+  if (typeof input !== "object" || input === null) return input;
+  var prim = input[Symbol.toPrimitive];
+  if (prim !== undefined) {
+    var res = prim.call(input, hint || "default");
+    if (typeof res !== "object") return res;
+    throw new TypeError("@@toPrimitive must return a primitive value.");
+  }
+  return (hint === "string" ? String : Number)(input);
+}
+
+function _toPropertyKey(arg) {
+  var key = _toPrimitive(arg, "string");
+  return typeof key === "symbol" ? key : String(key);
+}
+
+function _defineProperty(obj, key, value) {
+  key = _toPropertyKey(key);
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+  return obj;
+}
+
+class EventEmitter {
+  constructor() {
+    _defineProperty(this, "listeners", []);
+  }
+  addListener(listener) {
+    this.listeners.push(listener);
+  }
+  removeListener(listener) {
+    this.listeners.splice(this.listeners.indexOf(listener), 1);
+  }
+  clear() {
+    this.listeners.splice(0, this.listeners.length);
+  }
+  emit(event) {
+    if (this.listeners.length === 0) return;
+    // copy array before emitting event to ensure even if listener array is modified, everyone listening initially gets the event.
+    // inspired by mrdoob's EventDispatcher
+    this.listeners.slice(0).forEach(listener => {
+      listener(event);
+    });
+  }
+  get listenerCount() {
+    return this.listeners.length;
+  }
+}
+
+var _class$o;
+class Logger {
+  static verbose(text) {
+    this.onVerbose.emit(text);
+  }
+  static info(text) {
+    this.onInfo.emit(text);
+  }
+  static warn(text) {
+    this.onWarn.emit(text);
+  }
+  static error(text) {
+    this.onError.emit(text);
+  }
+}
+_class$o = Logger;
+_defineProperty(Logger, "onVerbose", new EventEmitter());
+_defineProperty(Logger, "onInfo", new EventEmitter());
+_defineProperty(Logger, "onWarn", new EventEmitter());
+_defineProperty(Logger, "onError", new EventEmitter());
+(() => {
+  const prefix = () => {
+    return new Date().toLocaleTimeString().padStart(11, '0');
+  };
+  _class$o.onVerbose.addListener(text => {
+    console.log(prefix() + ` VERB:  ${text}`);
+  });
+  _class$o.onInfo.addListener(text => {
+    console.log(prefix() + ` INFO:  ${text}`);
+  });
+  _class$o.onWarn.addListener(text => {
+    console.warn(prefix() + ` WARN:  ${text}`);
+  });
+  _class$o.onError.addListener(text => {
+    console.error(prefix() + ` ERR:  ${text}`);
+  });
+})();
+
+class Assert {
+  static mustBeTrue(condition, msg = '') {
+    if (!condition) {
+      throw new Error(`failed assertion: ${msg}`);
+    }
+  }
+  static mustBeDefined(variable, msg = '') {
+    if (variable === undefined) {
+      throw new Error(`failed assertion: variable must be defined ${msg}`);
+    }
+  }
+}
+
+/* eslint-disable no-mixed-operators */
+/* eslint-disable no-bitwise */
+
+// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
+const lut = [];
+for (let i = 0; i < 256; i++) {
+  lut[i] = (i < 16 ? '0' : '') + i.toString(16);
+}
+function generateUuid() {
+  const d0 = Math.random() * 0xffffffff | 0;
+  const d1 = Math.random() * 0xffffffff | 0;
+  const d2 = Math.random() * 0xffffffff | 0;
+  const d3 = Math.random() * 0xffffffff | 0;
+  const uuid = `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;
+
+  // .toUpperCase() here flattens concatenated strings to save heap memory space.
+  return uuid.toUpperCase();
+}
+
+// Purpose:
+//  - stores the node graph
+class Graph {
+  constructor(registry) {
+    _defineProperty(this, "name", '');
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "nodes", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "variables", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "customEvents", {});
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    this.registry = registry;
+  }
+  createNode(nodeTypeName, nodeId = generateUuid(), nodeConfiguration = {}) {
+    if (nodeId in this.nodes) {
+      throw new Error(`can not create new node of type ${nodeTypeName} with id ${nodeId} as one with that id already exists.`);
+    }
+    let nodeDescription = undefined;
+    if (this.registry.nodes.contains(nodeTypeName)) {
+      nodeDescription = this.registry.nodes.get(nodeTypeName);
+    }
+    if (nodeDescription === undefined) {
+      throw new Error(`no registered node descriptions with the typeName ${nodeTypeName}`);
+    }
+    const node = nodeDescription.factory(nodeDescription, this, nodeConfiguration);
+    node.id = nodeId;
+    this.nodes[nodeId] = node;
+    node.inputs.forEach(socket => {
+      if (socket.valueTypeName !== 'flow' && socket.value === undefined) {
+        socket.value = this.registry.values.get(socket.valueTypeName).creator();
+      }
+    });
+    return node;
+  }
+}
+
+class Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    _defineProperty(this, "id", '');
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    this.description = description;
+    this.graph = graph;
+    this.inputs = inputs;
+    this.outputs = outputs;
+    this.configuration = configuration;
+  }
+
+  // TODO: this may want to cache the values on the creation of the NodeEvalContext
+  // for re-entrant async operations, otherwise the inputs may change during operation.
+  readInput(inputName) {
+    const inputSocket = this.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`can not find input socket with name ${inputName} on node of type ${this.description.typeName}`);
+    }
+    return inputSocket.value;
+  }
+  writeOutput(outputName, value) {
+    const outputSocket = this.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find output socket with name ${outputSocket} on node of type ${this.description.typeName}`);
+    }
+    if (outputSocket.valueTypeName === 'flow') {
+      throw new Error(`can not set the value of Flow output socket ${outputName}, use commit() instead`);
+    }
+    outputSocket.value = value;
+  }
+}
+
+// async flow node with only a single flow input
+class AsyncNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(engine, triggeringSocketName, finished) {
+    throw new Error('not implemented');
+  }
+  dispose() {
+    throw new Error('not implemented');
+  }
+}
+class AsyncNode2 extends AsyncNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs);
+  }
+}
+
+// no flow inputs, always evaluated on startup
+class EventNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // no input flow sockets allowed.
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  init(engine) {
+    throw new Error('not implemented');
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  dispose(engine) {
+    throw new Error('not implemented');
+  }
+}
+class EventNode2 extends EventNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class FlowNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    // determine if this is an eval node
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(fiber, triggeringSocketName) {
+    throw new Error('not implemented');
+  }
+}
+class FlowNode2 extends FlowNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class ImmediateNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], exec, configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have no input flow sockets
+    this.exec = exec;
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have no output flow sockets
+    Assert.mustBeTrue(!this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+}
+class ImmediateNode2 extends ImmediateNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.exec);
+  }
+}
+
+class Link {
+  constructor(nodeId = '', socketName = '') {
+    _defineProperty(this, "_targetNode", undefined);
+    _defineProperty(this, "_targetSocket", undefined);
+    this.nodeId = nodeId;
+    this.socketName = socketName;
+  }
+}
+
+class ValueType {
+  constructor(name, creator, deserialize, serialize, lerp) {
+    this.name = name;
+    this.creator = creator;
+    this.deserialize = deserialize;
+    this.serialize = serialize;
+    this.lerp = lerp;
+  }
+}
+
+class Socket {
+  constructor(valueTypeName, name, value = undefined, label = undefined, valueChoices = [] // if not empty, value must be one of these.
+  ) {
+    _defineProperty(this, "links", []);
+    this.valueTypeName = valueTypeName;
+    this.name = name;
+    this.value = value;
+    this.label = label;
+    this.valueChoices = valueChoices;
+  }
+}
+
+class CustomEvent {
+  constructor(id, name, parameters = []) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "eventEmitter", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.parameters = parameters;
+  }
+}
+
+class Variable {
+  constructor(id, name, valueTypeName, initialValue // this is assumed to be properly deseriealized from a string.
+  ) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    // this is updated on each change to the variable state.
+    _defineProperty(this, "onChanged", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.valueTypeName = valueTypeName;
+    this.initialValue = initialValue;
+    this.value = this.initialValue;
+  }
+  get() {
+    return this.value;
+  }
+  set(newValue) {
+    if (newValue !== this.value) {
+      this.value = newValue;
+      this.version++;
+      this.onChanged.emit(this);
+    }
+  }
+}
+
+const inputSocketName = {
+  a: 'a',
+  b: 'b',
+  c: 'c',
+  d: 'd'
+};
+const resultNodeName = 'result';
+
+class In4Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c, inputSocketName.d]) {
+    if (inputValueTypes.length !== 4) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 4, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 4) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 4, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In3Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c]) {
+    if (inputValueTypes.length !== 3) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 3, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 3) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 3, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In2Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b]) {
+    if (inputValueTypes.length !== 2) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 2, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 2) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 2, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In1Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a]) {
+    if (inputValueTypes.length !== 1) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 1, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 1) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 1, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In0Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, outputValueType, evalFunc) {
+    super(description, graph, [], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc());
+    });
+    this.evalFunc = evalFunc;
+  }
+}
+
+/* eslint-disable no-promise-executor-return */
+function sleep(durationInSeconds) {
+  return new Promise(resolve => setTimeout(resolve, Math.round(durationInSeconds * 1000)));
+}
+
+function resolveSocketValue(engine, inputSocket) {
+  // if it has no links, leave value on input socket alone.
+  if (inputSocket.links.length === 0) {
+    return 0;
+  }
+  const graph = engine.graph;
+  const upstreamLink = inputSocket.links[0];
+  // caching the target node + socket here increases engine performance by 8% on average.  This is a hotspot.
+  if (upstreamLink._targetNode === undefined || upstreamLink._targetSocket === undefined) {
+    Assert.mustBeTrue(inputSocket.links.length === 1);
+
+    // if upstream node is an eval, we just return its last value.
+    upstreamLink._targetNode = graph.nodes[upstreamLink.nodeId];
+    // what is inputSocket connected to?
+    upstreamLink._targetSocket = upstreamLink._targetNode.outputs.find(socket => socket.name === upstreamLink.socketName);
+    if (upstreamLink._targetSocket === undefined) {
+      throw new Error(`can not find socket with the name ${upstreamLink.socketName}`);
+    }
+  }
+  const upstreamNode = upstreamLink._targetNode;
+  const upstreamOutputSocket = upstreamLink._targetSocket;
+
+  // if upstream is a flow/event/async node, do not evaluate it rather just use its existing output socket values
+  if (!(upstreamNode instanceof ImmediateNode)) {
+    inputSocket.value = upstreamOutputSocket.value;
+    return 0;
+  }
+  let executionSteps = 0;
+  if (upstreamNode instanceof ImmediateNode) {
+    // resolve all inputs for the upstream node (this is where the recursion happens)
+    // TODO: This is a bit dangerous as if there are loops in the graph, this will blow up the stack
+    for (const upstreamInputSocket of upstreamNode.inputs) {
+      executionSteps += resolveSocketValue(engine, upstreamInputSocket);
+    }
+    engine.onNodeExecutionStart.emit(upstreamNode);
+    upstreamNode.exec();
+    executionSteps++;
+    engine.onNodeExecutionEnd.emit(upstreamNode);
+
+    // get the output value we wanted.
+    inputSocket.value = upstreamOutputSocket.value;
+    return executionSteps;
+  }
+  return 0;
+}
+
+class Fiber {
+  constructor(engine, nextEval, fiberCompletedListener = undefined) {
+    _defineProperty(this, "fiberCompletedListenerStack", []);
+    _defineProperty(this, "executionSteps", 0);
+    this.engine = engine;
+    this.nextEval = nextEval;
+    this.graph = engine.graph;
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // this is syncCommit.
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars
+  commit(node, outputSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof FlowNode);
+    Assert.mustBeTrue(this.nextEval === null);
+    const outputSocket = node.outputs.find(socket => socket.name === outputSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find socket with the name ${outputSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const link = outputSocket.links[0];
+      if (link === undefined) {
+        throw new Error('link must be defined');
+      }
+      this.nextEval = link;
+    }
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // returns the number of new execution steps created as a result of this one step
+  executeStep() {
+    // pop the next node off the queue
+    const link = this.nextEval;
+    this.nextEval = null;
+
+    // nothing waiting, thus go back and start to evaluate any callbacks, in stack order.
+    if (link === null) {
+      if (this.fiberCompletedListenerStack.length === 0) {
+        return;
+      }
+      const awaitingCallback = this.fiberCompletedListenerStack.pop();
+      if (awaitingCallback === undefined) {
+        throw new Error('awaitingCallback is empty');
+      }
+      awaitingCallback();
+      return;
+    }
+    const node = this.graph.nodes[link.nodeId];
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName !== 'flow') {
+        this.executionSteps += resolveSocketValue(this.engine, inputSocket);
+      }
+    });
+
+    // first resolve all input values
+    // flow socket is set to true for the one flowing in, while all others are set to false.
+    this.engine.onNodeExecutionStart.emit(node);
+    if (node instanceof AsyncNode) {
+      this.engine.asyncNodes.push(node);
+      node.triggered(this.engine, link.socketName, () => {
+        // remove from the list of pending async nodes
+        const index = this.engine.asyncNodes.indexOf(node);
+        this.engine.asyncNodes.splice(index, 1);
+        this.engine.onNodeExecutionEnd.emit(node);
+        this.executionSteps++;
+      });
+      return;
+    }
+    if (node instanceof FlowNode) {
+      node.triggered(this, link.socketName);
+      this.engine.onNodeExecutionEnd.emit(node);
+      this.executionSteps++;
+      return;
+    }
+    throw new TypeError(`should not get here, unhandled node ${node.description.typeName}`);
+  }
+  isCompleted() {
+    return this.fiberCompletedListenerStack.length === 0 && this.nextEval === null;
+  }
+}
+
+class Engine {
+  constructor(graph) {
+    // tracking the next node+input socket to execute.
+    _defineProperty(this, "fiberQueue", []);
+    _defineProperty(this, "asyncNodes", []);
+    _defineProperty(this, "eventNodes", []);
+    _defineProperty(this, "onNodeExecutionStart", new EventEmitter());
+    _defineProperty(this, "onNodeExecutionEnd", new EventEmitter());
+    _defineProperty(this, "executionSteps", 0);
+    this.graph = graph;
+    // collect all event nodes
+    Object.values(graph.nodes).forEach(node => {
+      if (node instanceof EventNode) {
+        this.eventNodes.push(node);
+      }
+    });
+    // init all event nodes at startup
+    this.eventNodes.forEach(eventNode => {
+      // evaluate input parameters
+      eventNode.inputs.forEach(inputSocket => {
+        Assert.mustBeTrue(inputSocket.valueTypeName !== 'flow');
+        this.executionSteps += resolveSocketValue(this, inputSocket);
+      });
+      this.onNodeExecutionStart.emit(eventNode);
+      eventNode.init(this);
+      this.executionSteps++;
+      this.onNodeExecutionEnd.emit(eventNode);
+    });
+  }
+  dispose() {
+    // dispose all, possibly in-progress, async nodes
+    this.asyncNodes.forEach(asyncNode => asyncNode.dispose());
+
+    // dispose all event nodes
+    this.eventNodes.forEach(eventNode => eventNode.dispose(this));
+  }
+
+  // asyncCommit
+  commitToNewFiber(node, outputFlowSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof EventNode || node instanceof AsyncNode);
+    const outputSocket = node.outputs.find(socket => socket.name === outputFlowSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`no socket with the name ${outputFlowSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const fiber = new Fiber(this, outputSocket.links[0], fiberCompletedListener);
+      this.fiberQueue.push(fiber);
+    }
+  }
+
+  // NOTE: This does not execute all if there are promises.
+  executeAllSync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSeconds = 0;
+    let elapsedSteps = 0;
+    while (elapsedSteps < limitInSteps && elapsedSeconds < limitInSeconds && this.fiberQueue.length > 0) {
+      const currentFiber = this.fiberQueue[0];
+      const startingFiberExecutionSteps = currentFiber.executionSteps;
+      currentFiber.executeStep();
+      elapsedSteps += currentFiber.executionSteps - startingFiberExecutionSteps;
+      if (currentFiber.isCompleted()) {
+        // remove first element
+        this.fiberQueue.shift();
+      }
+      elapsedSeconds = (Date.now() - startDateTime) * 0.001;
+    }
+    this.executionSteps += elapsedSteps;
+    return elapsedSteps;
+  }
+  async executeAllAsync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSteps = 0;
+    let elapsedTime = 0;
+    let iterations = 0;
+    do {
+      if (iterations > 0) {
+        // eslint-disable-next-line no-await-in-loop
+        await sleep(0);
+      }
+      elapsedSteps += this.executeAllSync(limitInSeconds - elapsedTime, limitInSteps - elapsedSteps);
+      elapsedTime = (Date.now() - startDateTime) * 0.001;
+      iterations += 1;
+    } while ((this.asyncNodes.length > 0 || this.fiberQueue.length > 0) && elapsedTime < limitInSeconds && elapsedSteps < limitInSteps);
+    return elapsedSteps;
+  }
+}
+
+// Purpose:
+//  - loads a node graph
+function readGraphFromJSON(graphJson, registry) {
+  var _graphJson$name, _graphJson$metadata, _graphJson$nodes;
+  const graph = new Graph(registry);
+  graph.name = (_graphJson$name = graphJson === null || graphJson === void 0 ? void 0 : graphJson.name) !== null && _graphJson$name !== void 0 ? _graphJson$name : graph.name;
+  graph.metadata = (_graphJson$metadata = graphJson === null || graphJson === void 0 ? void 0 : graphJson.metadata) !== null && _graphJson$metadata !== void 0 ? _graphJson$metadata : graph.metadata;
+  if ('variables' in graphJson) {
+    var _graphJson$variables;
+    readVariablesJSON(graph, (_graphJson$variables = graphJson.variables) !== null && _graphJson$variables !== void 0 ? _graphJson$variables : []);
+  }
+  if ('customEvents' in graphJson) {
+    var _graphJson$customEven;
+    readCustomEventsJSON(graph, (_graphJson$customEven = graphJson.customEvents) !== null && _graphJson$customEven !== void 0 ? _graphJson$customEven : []);
+  }
+  const nodesJson = (_graphJson$nodes = graphJson === null || graphJson === void 0 ? void 0 : graphJson.nodes) !== null && _graphJson$nodes !== void 0 ? _graphJson$nodes : [];
+  if (nodesJson.length === 0) {
+    Logger.warn('readGraphFromJSON: no nodes specified');
+  }
+
+  // create new BehaviorNode instances for each node in the json.
+  for (let i = 0; i < nodesJson.length; i += 1) {
+    const nodeJson = nodesJson[i];
+    readNodeJSON(graph, nodeJson);
+  }
+
+  // connect up the graph edges from BehaviorNode inputs to outputs.  This is required to follow execution
+  Object.values(graph.nodes).forEach(node => {
+    // initialize the inputs by resolving to the reference nodes.
+    node.inputs.forEach(inputSocket => {
+      inputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent upstream node id: ${link.nodeId}`);
+        }
+        const upstreamNode = graph.nodes[link.nodeId];
+        const upstreamOutputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (upstreamOutputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent output '${link.socketName}' on upstream node '${upstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const upstreamLink = new Link(node.id, inputSocket.name);
+        if (upstreamOutputSocket.links.findIndex(value => value.nodeId == upstreamLink.nodeId && value.socketName == upstreamLink.socketName) < 0) {
+          upstreamOutputSocket.links.push(upstreamLink);
+        }
+      });
+    });
+    node.outputs.forEach(outputSocket => {
+      outputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent downstream node id ${link.nodeId}`);
+        }
+        const downstreamNode = graph.nodes[link.nodeId];
+        const downstreamInputSocket = downstreamNode.inputs.find(socket => socket.name === link.socketName);
+        if (downstreamInputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent input '${link.socketName}' on downstream node '${downstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const downstreamLink = new Link(node.id, outputSocket.name);
+        if (downstreamInputSocket.links.findIndex(value => value.nodeId == downstreamLink.nodeId && value.socketName == downstreamLink.socketName) < 0) {
+          downstreamInputSocket.links.push(downstreamLink);
+        }
+      });
+    });
+  });
+  return graph;
+}
+function readNodeJSON(graph, nodeJson) {
+  var _nodeJson$label, _nodeJson$metadata;
+  if (nodeJson.type === undefined) {
+    throw new Error('readGraphFromJSON: no type for node');
+  }
+  const nodeName = nodeJson.type;
+  const nodeConfigurationJson = nodeJson.configuration;
+  const nodeConfiguration = {};
+  if (nodeConfigurationJson !== undefined) {
+    Object.keys(nodeConfigurationJson).forEach(key => {
+      nodeConfiguration[key] = nodeConfigurationJson[key];
+    });
+  }
+  const node = graph.createNode(nodeName, nodeJson.id, nodeConfiguration);
+  node.label = (_nodeJson$label = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.label) !== null && _nodeJson$label !== void 0 ? _nodeJson$label : node.label;
+  node.metadata = (_nodeJson$metadata = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.metadata) !== null && _nodeJson$metadata !== void 0 ? _nodeJson$metadata : node.metadata;
+  if (nodeJson.parameters !== undefined) {
+    readNodeParameterJSON(graph, node, nodeJson.parameters);
+  }
+  if (nodeJson.flows !== undefined) {
+    readNodeFlowsJSON(graph, node, nodeJson.flows);
+  }
+}
+function readNodeParameterJSON(graph, node, parametersJson) {
+  node.inputs.forEach(socket => {
+    if (!(socket.name in parametersJson)) {
+      return;
+    }
+    const inputJson = parametersJson[socket.name];
+    if ('value' in inputJson) {
+      // eslint-disable-next-line no-param-reassign
+      socket.value = graph.registry.values.get(socket.valueTypeName).deserialize(inputJson.value);
+    }
+    if ('link' in inputJson) {
+      const linkJson = inputJson.link;
+      socket.links.push(new Link(linkJson.nodeId, linkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const inputName in parametersJson) {
+    const inputSocket = node.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an input '${inputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readNodeFlowsJSON(graph, node, flowsJson) {
+  node.outputs.forEach(socket => {
+    if (socket.name in flowsJson) {
+      const outputLinkJson = flowsJson[socket.name];
+      socket.links.push(new Link(outputLinkJson.nodeId, outputLinkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const outputName in flowsJson) {
+    const outputSocket = node.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an output '${outputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readVariablesJSON(graph, variablesJson) {
+  for (let i = 0; i < variablesJson.length; i += 1) {
+    var _variableJson$label, _variableJson$metadat;
+    const variableJson = variablesJson[i];
+    const variable = new Variable(variableJson.id, variableJson.name, variableJson.valueTypeName, graph.registry.values.get(variableJson.valueTypeName).deserialize(variableJson.initialValue));
+    variable.label = (_variableJson$label = variableJson === null || variableJson === void 0 ? void 0 : variableJson.label) !== null && _variableJson$label !== void 0 ? _variableJson$label : variable.label;
+    variable.metadata = (_variableJson$metadat = variableJson === null || variableJson === void 0 ? void 0 : variableJson.metadata) !== null && _variableJson$metadat !== void 0 ? _variableJson$metadat : variable.metadata;
+    if (variableJson.id in graph.variables) {
+      throw new Error(`duplicate variable id ${variable.id}`);
+    }
+    graph.variables[variableJson.id] = variable;
+  }
+}
+function readCustomEventsJSON(graph, customEventsJson) {
+  for (let i = 0; i < customEventsJson.length; i += 1) {
+    var _customEventJson$para, _customEventJson$labe, _customEventJson$meta;
+    const customEventJson = customEventsJson[i];
+    const parameters = [];
+    ((_customEventJson$para = customEventJson.parameters) !== null && _customEventJson$para !== void 0 ? _customEventJson$para : []).forEach(parameterJson => {
+      parameters.push(new Socket(parameterJson.valueTypeName, parameterJson.name, graph.registry.values.get(parameterJson.valueTypeName).deserialize(parameterJson.defaultValue)));
+    });
+    const customEvent = new CustomEvent(customEventJson.id, customEventJson.name, parameters);
+    customEvent.label = (_customEventJson$labe = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.label) !== null && _customEventJson$labe !== void 0 ? _customEventJson$labe : customEvent.label;
+    customEvent.metadata = (_customEventJson$meta = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.metadata) !== null && _customEventJson$meta !== void 0 ? _customEventJson$meta : customEvent.metadata;
+    if (customEvent.id in graph.customEvents) {
+      throw new Error(`duplicate variable id ${customEvent.id}`);
+    }
+    graph.customEvents[customEvent.id] = customEvent;
+  }
+}
+
+function writeGraphToJSON(graph) {
+  const graphJson = {};
+  if (Object.keys(graph.metadata).length > 0) {
+    graphJson.metadata = graph.metadata;
+  }
+
+  // save custom events
+  Object.values(graph.customEvents).forEach(customEvent => {
+    const customEventJson = {
+      name: customEvent.name,
+      id: customEvent.id
+    };
+    if (customEvent.label.length > 0) {
+      customEventJson.label = customEvent.label;
+    }
+    if (customEvent.parameters.length > 0) {
+      const parametersJson = [];
+      customEvent.parameters.forEach(parameter => {
+        parametersJson.push({
+          name: parameter.name,
+          valueTypeName: parameter.valueTypeName,
+          defaultValue: parameter.value
+        });
+      });
+      customEventJson.parameters = parametersJson;
+    }
+    if (Object.keys(customEvent.metadata).length > 0) {
+      customEventJson.metadata = customEvent.metadata;
+    }
+    if (graphJson.customEvents === undefined) {
+      graphJson.customEvents = [];
+    }
+    graphJson.customEvents.push(customEventJson);
+  });
+
+  // save variables
+  Object.values(graph.variables).forEach(variable => {
+    const variableJson = {
+      valueTypeName: variable.valueTypeName,
+      name: variable.name,
+      id: variable.id,
+      initialValue: graph.registry.values.get(variable.valueTypeName).serialize(variable.initialValue)
+    };
+    if (variable.label.length > 0) {
+      variableJson.label = variable.label;
+    }
+    if (Object.keys(variable.metadata).length > 0) {
+      variableJson.metadata = variable.metadata;
+    }
+    if (graphJson.variables === undefined) {
+      graphJson.variables = [];
+    }
+    graphJson.variables.push(variableJson);
+  });
+
+  // save nodes
+  Object.values(graph.nodes).forEach(node => {
+    const nodeJson = {
+      type: node.description.typeName,
+      id: node.id
+    };
+    if (node.label.length > 0) {
+      nodeJson.label = node.label;
+    }
+    if (Object.keys(node.metadata).length > 0) {
+      nodeJson.metadata = node.metadata;
+    }
+    if (Object.keys(node.description.configuration).length > 0) {
+      const configurationJson = {};
+      Object.keys(node.configuration).forEach(key => {
+        configurationJson[key] = node.configuration[key];
+      });
+      nodeJson.configuration = configurationJson;
+    }
+    const parametersJson = {};
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName === 'flow') return;
+      let parameterJson = undefined;
+      if (inputSocket.links.length === 0) {
+        parameterJson = {
+          value: graph.registry.values.get(inputSocket.valueTypeName).serialize(inputSocket.value)
+        };
+      } else if (inputSocket.links.length === 1) {
+        const link = inputSocket.links[0];
+        parameterJson = {
+          link: {
+            nodeId: link.nodeId,
+            socket: link.socketName
+          }
+        };
+      } else {
+        throw new Error(`should not get here, inputSocket.links.length = ${inputSocket.links.length} > 1`);
+      }
+      parametersJson[inputSocket.name] = parameterJson;
+    });
+    if (Object.keys(parametersJson).length > 0) {
+      nodeJson.parameters = parametersJson;
+    }
+    const flowsJson = {};
+    node.outputs.forEach(outputSocket => {
+      if (outputSocket.valueTypeName !== 'flow') return;
+      if (outputSocket.links.length === 0) return;
+      const linkJson = {
+        nodeId: outputSocket.links[0].nodeId,
+        socket: outputSocket.links[0].socketName
+      };
+      flowsJson[outputSocket.name] = linkJson;
+    });
+    if (Object.keys(flowsJson).length > 0) {
+      nodeJson.flows = flowsJson;
+    }
+    if (graphJson.nodes === undefined) {
+      graphJson.nodes = [];
+    }
+    graphJson.nodes.push(nodeJson);
+  });
+  return graphJson;
+}
+
+function writeNodeSpecsToJSON(registry) {
+  const nodeSpecsJSON = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+    const nodeSpecJSON = {
+      type: nodeTypeName,
+      category: node.description.category,
+      label: node.description.label,
+      inputs: [],
+      outputs: [],
+      configuration: []
+    };
+    node.inputs.forEach(inputSocket => {
+      const valueType = inputSocket.valueTypeName === 'flow' ? undefined : registry.values.get(inputSocket.valueTypeName);
+      let defaultValue = inputSocket.value;
+      if (valueType !== undefined) {
+        defaultValue = valueType.serialize(defaultValue);
+      }
+      if (defaultValue === undefined && valueType !== undefined) {
+        defaultValue = valueType.serialize(valueType.creator());
+      }
+      const socketSpecJSON = {
+        name: inputSocket.name,
+        valueType: inputSocket.valueTypeName,
+        defaultValue
+      };
+      nodeSpecJSON.inputs.push(socketSpecJSON);
+    });
+    node.outputs.forEach(outputSocket => {
+      const socketSpecJSON = {
+        name: outputSocket.name,
+        valueType: outputSocket.valueTypeName
+      };
+      nodeSpecJSON.outputs.push(socketSpecJSON);
+    });
+    nodeSpecsJSON.push(nodeSpecJSON);
+  });
+  return nodeSpecsJSON;
+}
+
+function getNodeDescriptions(importWildcard) {
+  return Object.keys(importWildcard).map(key => importWildcard[key]).filter(value => value instanceof NodeDescription);
+}
+class NodeDescription {
+  constructor(typeName, category, label = '', factory, otherTypeNames = [], helpDescription = '', configuration = {}) {
+    this.typeName = typeName;
+    this.category = category;
+    this.label = label;
+    this.factory = factory;
+    this.otherTypeNames = otherTypeNames;
+    this.helpDescription = helpDescription;
+    this.configuration = configuration;
+  }
+}
+class NodeDescription2 extends NodeDescription {
+  constructor(properties) {
+    super(properties.typeName, properties.category, properties.label, properties.factory, properties.otherTypeNames, properties.helpDescription, properties.configuration);
+    this.properties = properties;
+  }
+}
+
+class NodeTypeRegistry {
+  constructor() {
+    _defineProperty(this, "typeNameToNodeDescriptions", {});
+  }
+  clear() {
+    for (const nodeTypeName in this.typeNameToNodeDescriptions) {
+      delete this.typeNameToNodeDescriptions[nodeTypeName];
+    }
+  }
+  register(...descriptions) {
+    descriptions.forEach(description => {
+      description.otherTypeNames.concat([description.typeName]).forEach(typeName => {
+        if (typeName in this.typeNameToNodeDescriptions) {
+          throw new Error(`already registered node type ${typeName} (string)`);
+        }
+        this.typeNameToNodeDescriptions[typeName] = description;
+      });
+    });
+  }
+  contains(typeName) {
+    return typeName in this.typeNameToNodeDescriptions;
+  }
+  get(typeName) {
+    if (!(typeName in this.typeNameToNodeDescriptions)) {
+      throw new Error(`no registered node with type name ${typeName}`);
+    }
+    return this.typeNameToNodeDescriptions[typeName];
+  }
+  getAllNames() {
+    return Object.keys(this.typeNameToNodeDescriptions);
+  }
+  getAllDescriptions() {
+    return Object.values(this.typeNameToNodeDescriptions);
+  }
+}
+
+class ValueTypeRegistry {
+  constructor() {
+    _defineProperty(this, "valueTypeNameToValueType", {});
+  }
+  register(...valueTypes) {
+    valueTypes.forEach(valueType => {
+      if (valueType.name in this.valueTypeNameToValueType) {
+        throw new Error(`already registered value type ${valueType.name}`);
+      }
+      this.valueTypeNameToValueType[valueType.name] = valueType;
+    });
+  }
+  get(valueTypeName) {
+    if (!(valueTypeName in this.valueTypeNameToValueType)) {
+      throw new Error(`can not find value type with name '${valueTypeName}`);
+    }
+    return this.valueTypeNameToValueType[valueTypeName];
+  }
+  getAllNames() {
+    return Object.keys(this.valueTypeNameToValueType);
+  }
+}
+
+class Registry {
+  constructor() {
+    _defineProperty(this, "values", new ValueTypeRegistry());
+    _defineProperty(this, "nodes", new NodeTypeRegistry());
+  }
+}
+
+const nodeTypeNameRegex = /^\w+(\/\w+)*$/;
+const socketNameRegex = /^\w+$/;
+function validateNodeRegistry(registry) {
+  const errorList = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+
+    // ensure node is registered correctly.
+    if (node.description.typeName !== nodeTypeName) {
+      if (!node.description.otherTypeNames.includes(nodeTypeName)) {
+        errorList.push(`node with typeName '${node.description.typeName}' is registered under a different name '${nodeTypeName}'`);
+      }
+    }
+    if (!nodeTypeNameRegex.test(node.description.typeName)) {
+      errorList.push(`invalid node type name on node ${node.description.typeName}`);
+    }
+    node.inputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for input socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on input socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+    node.outputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for output socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on output socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+  });
+  return errorList;
+}
+
+const valueTypeNameRegex = /^\w+$/;
+function validateValueRegistry(graphRegistry) {
+  const errorList = [];
+  graphRegistry.values.getAllNames().forEach(valueTypeName => {
+    if (!valueTypeNameRegex.test(valueTypeName)) {
+      errorList.push(`invalid value type name ${valueTypeName}`);
+    }
+    const valueType = graphRegistry.values.get(valueTypeName);
+    const value = valueType.creator();
+    const serializedValue = valueType.serialize(value);
+    const deserializedValue = valueType.deserialize(serializedValue);
+    const reserializedValue = valueType.serialize(deserializedValue);
+    const redeserializedValue = valueType.deserialize(reserializedValue);
+    if (JSON.stringify(serializedValue) !== JSON.stringify(reserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) reserialization mismatch between ${JSON.stringify(serializedValue)} and ${JSON.stringify(reserializedValue)}`);
+    }
+    if (typeof deserializedValue !== 'bigint' && JSON.stringify(deserializedValue) !== JSON.stringify(redeserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) redeserialization mismatch between ${JSON.stringify(deserializedValue)} and ${JSON.stringify(redeserializedValue)}`);
+    }
+  });
+  return errorList;
+}
+
+function validateRegistry(registry) {
+  const errorList = [];
+  errorList.push(...validateValueRegistry(registry), ...validateNodeRegistry(registry));
+  return errorList;
+}
+
+function validateGraphAcyclic(graph) {
+  // apparently if you can topological sort, it is a DAG according to: https://stackoverflow.com/questions/4168/graph-serialization/4577#4577
+
+  // instead of modifying the graph, I will use metadata to mark it in place.
+  Object.values(graph.nodes).forEach(node => {
+    // eslint-disable-next-line no-param-reassign
+    node.metadata['dag.marked'] = 'false';
+  });
+
+  // it appears that we can just keep trimming nodes whose input sockets have no connections.
+  // if we can remove all nodes, that means that there are no cycles.
+
+  const nodesToMark = [];
+  do {
+    // clear array: https://stackoverflow.com/a/1232046
+    nodesToMark.length = 0;
+    Object.values(graph.nodes).forEach(node => {
+      // ignore existing marked nodes.
+      if (node.metadata['dag.marked'] === 'true') {
+        return;
+      }
+      let inputsConnected = false;
+      node.inputs.forEach(inputSocket => {
+        inputSocket.links.forEach(link => {
+          // is the other end marked?  If not, then it is still connected.
+          if (graph.nodes[link.nodeId].metadata['dag.marked'] === 'false') {
+            inputsConnected = true;
+          }
+        });
+      });
+      if (!inputsConnected) {
+        nodesToMark.push(node);
+      }
+    });
+    nodesToMark.forEach(node => {
+      // eslint-disable-next-line no-param-reassign
+      node.metadata['dag.marked'] = 'true';
+    });
+  } while (nodesToMark.length > 0);
+  const errorList = [];
+
+  // output errors for each unmarked node
+  // also remove the metadata related to DAG marking
+  Object.values(graph.nodes).forEach(node => {
+    if (node.metadata['dag.marked'] === 'false') {
+      errorList.push(`node ${node.description.typeName} is part of a cycle, not a directed acyclic graph`);
+    }
+    // eslint-disable-next-line no-param-reassign
+    delete node.metadata['dag.marked'];
+  });
+  return errorList;
+}
+
+function validateGraphLinks(graph) {
+  const errorList = [];
+  // for each node
+  Object.values(graph.nodes).forEach(node => {
+    // for each input socket
+    node.inputs.forEach(inputSocket => {
+      // ensure that connected output sockets are the same type
+      inputSocket.links.forEach(link => {
+        // check if the node id is correct
+        if (!(link.nodeId in graph.nodes)) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using invalid nodeId: ${link.nodeId}`);
+          return;
+        }
+
+        // check if the socketName is correct
+        const upstreamNode = graph.nodes[link.nodeId];
+        const outputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (outputSocket === undefined) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using a non-existent socket name: ` + `${link.socketName}, it can not be found on upstream output node: ${upstreamNode.description.typeName}`);
+          return;
+        }
+
+        // check if the socket types align
+        if (inputSocket.valueTypeName !== outputSocket.valueTypeName) {
+          errorList.push(`type mismatch between ${node.description.typeName}.${inputSocket.name} [${inputSocket.valueTypeName}] ` + `and ${upstreamNode.description.typeName}.${outputSocket.name} [${outputSocket.valueTypeName}]`);
+        }
+      });
+    });
+  });
+  return errorList;
+}
+
+function validateGraph(graph) {
+  const errorList = [];
+  errorList.push(...validateGraphAcyclic(graph), ...validateGraphLinks(graph));
+  return errorList;
+}
+
+/* eslint-disable class-methods-use-this */
+class DefaultLogger {
+  verbose(text) {
+    Logger.verbose(text);
+  }
+  info(text) {
+    Logger.info(text);
+  }
+  warn(text) {
+    Logger.warn(text);
+  }
+  error(text) {
+    Logger.error(text);
+  }
+}
+
+class ManualLifecycleEventEmitter {
+  constructor() {
+    _defineProperty(this, "startEvent", new EventEmitter());
+    _defineProperty(this, "endEvent", new EventEmitter());
+    _defineProperty(this, "tickEvent", new EventEmitter());
+  }
+}
+
+var _class$n;
+class OnCustomEvent extends EventNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      outputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      configuration
+    });
+    _defineProperty(this, "onCustomEvent", undefined);
+    this.customEvent = customEvent;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onCustomEvent === undefined);
+    this.onCustomEvent = parameters => {
+      this.customEvent.parameters.forEach(parameterSocket => {
+        if (!(parameterSocket.name in parameters)) {
+          throw new Error(`parameters of custom event do not align with parameters of custom event node, missing ${parameterSocket.name}`);
+        }
+        this.writeOutput(parameterSocket.name, parameters[parameterSocket.name]);
+      });
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.customEvent.eventEmitter.addListener(this.onCustomEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onCustomEvent !== undefined);
+    if (this.onCustomEvent !== undefined) {
+      this.customEvent.eventEmitter.removeListener(this.onCustomEvent);
+    }
+  }
+}
+_class$n = OnCustomEvent;
+_defineProperty(OnCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/onTriggered',
+  category: 'Event',
+  label: 'On Triggered',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$n(description, graph, configuration)
+}));
+
+var _class$m;
+class TriggerCustomEvent extends FlowNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      inputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      outputs: [new Socket('flow', 'flow')],
+      configuration
+    });
+    this.customEvent = customEvent;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const parameters = {};
+    this.customEvent.parameters.forEach(parameterSocket => {
+      parameters[parameterSocket.name] = this.readInput(parameterSocket.name);
+    });
+    this.customEvent.eventEmitter.emit(parameters);
+  }
+}
+_class$m = TriggerCustomEvent;
+_defineProperty(TriggerCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/trigger',
+  category: 'Action',
+  label: 'Trigger',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$m(description, graph, configuration)
+}));
+
+var _class$l;
+class ExpectTrue extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition'), new Socket('string', 'description')], [new Socket('flow', 'flow')]);
+  }
+  triggered(fiber, triggeredSocketName) {
+    Assert.mustBeTrue(this.readInput('condition'), this.readInput('description'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$l = ExpectTrue;
+_defineProperty(ExpectTrue, "Description", new NodeDescription('debug/expectTrue', 'Action', 'Assert Expect True', (description, graph) => new _class$l(description, graph)));
+
+var _class$k;
+class Log extends FlowNode {
+  constructor(description, graph, logger) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'text'), new Socket('string', 'severity', 'info', undefined, ['verbose', 'info', 'warning', 'error'])], [new Socket('flow', 'flow')]);
+    this.logger = logger;
+  }
+  triggered(fiber, triggeredSocketName) {
+    const text = this.readInput('text');
+    switch (this.readInput('severity')) {
+      case 'verbose':
+        this.logger.verbose(text);
+        break;
+      case 'info':
+        this.logger.info(text);
+        break;
+      case 'warning':
+        this.logger.warn(text);
+        break;
+      case 'error':
+        this.logger.error(text);
+        break;
+    }
+    fiber.commit(this, 'flow');
+  }
+}
+_class$k = Log;
+_defineProperty(Log, "Description", logger => new NodeDescription('debug/log', 'Action', 'Debug Log', (description, graph) => new _class$k(description, graph, logger)));
+
+var _class$j;
+class Branch extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition')], [new Socket('flow', 'true'), new Socket('flow', 'false')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    fiber.commit(this, this.readInput('condition') === true ? 'true' : 'false');
+  }
+}
+_class$j = Branch;
+_defineProperty(Branch, "Description", new NodeDescription2({
+  typeName: 'flow/branch',
+  category: 'Flow',
+  label: 'Branch',
+  factory: (description, graph) => new _class$j(description, graph),
+  helpDescription: "Checks the value of the 'condition' input and if true, executes the 'true' branch, otherwise it executes the 'false' branch."
+}));
+
+var _class$i;
+class Counter extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          this.count++;
+          this.writeOutput('count', this.count);
+          fiber.commit(this, 'flow');
+          break;
+        }
+      case 'reset':
+        {
+          this.count = 0;
+          break;
+        }
+      default:
+        throw new Error('should not get here');
+    }
+  }
+}
+_class$i = Counter;
+_defineProperty(Counter, "Description", new NodeDescription('flow/counter', 'Flow', 'Counter', (description, graph) => new _class$i(description, graph)));
+
+var _class$h;
+
+// ASYNC - asynchronous evaluation
+// also called "delay"
+
+class Delay extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.timeoutPending = true;
+    setTimeout(() => {
+      // check if cancelled
+      if (!this.timeoutPending) return;
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.timeoutPending = false;
+  }
+}
+_class$h = Delay;
+_defineProperty(Delay, "Description", new NodeDescription2({
+  typeName: 'time/delay',
+  otherTypeNames: ['flow/delay'],
+  category: 'Time',
+  label: 'Delay',
+  factory: (description, graph) => new _class$h(description, graph)
+}));
+
+var _class$g;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoN extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'n', 1), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.count = 0;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (this.count < Number(this.readInput('n'))) {
+        this.writeOutput('count', this.count);
+        this.count++;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$g = DoN;
+_defineProperty(DoN, "Description", new NodeDescription('flow/doN', 'Flow', 'DoN', (description, graph) => new _class$g(description, graph)));
+
+var _class$f;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoOnce extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "firedOnce", false);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.firedOnce = false;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (!this.firedOnce) {
+        this.firedOnce = true;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$f = DoOnce;
+_defineProperty(DoOnce, "Description", new NodeDescription('flow/doOnce', 'Flow', 'DoOnce', (description, graph) => new _class$f(description, graph)));
+
+var _class$e;
+
+// as long as this continues to be triggered within the duration period, it will not fire.
+// based lousy on https://www.npmjs.com/package/debounce
+
+class Debounce extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'waitDuration'), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    this.triggerVersion++;
+
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      return;
+    }
+    const localTriggerCount = this.triggerVersion;
+    setTimeout(() => {
+      if (this.triggerVersion >= localTriggerCount) {
+        // ignore this timer, as it isn't for the most recent trigger
+        return;
+      }
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('waitDuration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+  }
+}
+_class$e = Debounce;
+_defineProperty(Debounce, "Description", new NodeDescription('flow/debounce', 'Flow', 'Debounce', (description, graph) => new _class$e(description, graph)));
+
+var _class$d;
+class FlipFlop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow')], [new Socket('flow', 'on'), new Socket('flow', 'off'), new Socket('boolean', 'isOn')]);
+    _defineProperty(this, "isOn", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    this.writeOutput('isOn', this.isOn);
+    fiber.commit(this, this.isOn ? 'on' : 'off');
+    this.isOn = !this.isOn;
+  }
+}
+_class$d = FlipFlop;
+_defineProperty(FlipFlop, "Description", new NodeDescription('flow/flipFlop', 'Flow', 'Flip Flop', (description, graph) => new _class$d(description, graph)));
+
+var _class$c;
+class ForLoop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'startIndex'), new Socket('integer', 'endIndex')], [new Socket('flow', 'loopBody'), new Socket('integer', 'index'), new Socket('flow', 'completed')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an async fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const startIndex = this.readInput('startIndex');
+    const endIndex = this.readInput('endIndex');
+    const loopBodyIteration = i => {
+      if (i < endIndex) {
+        this.writeOutput('index', i);
+        fiber.commit(this, 'loopBody', () => {
+          loopBodyIteration(i + BigInt(1));
+        });
+      } else {
+        fiber.commit(this, 'completed');
+      }
+    };
+    loopBodyIteration(startIndex);
+  }
+}
+_class$c = ForLoop;
+_defineProperty(ForLoop, "Description", new NodeDescription2({
+  typeName: 'flow/forLoop',
+  category: 'Flow',
+  label: 'For Loop',
+  factory: (description, graph) => new _class$c(description, graph)
+}));
+
+var _class$b;
+
+// based on Unreal Engine Blueprint Gate node
+
+class Gate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'open'), new Socket('flow', 'close'), new Socket('flow', 'toggle'), new Socket('boolean', 'startClosed', true)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "isClosed", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.isClosed = this.readInput('startClosed');
+      this.isInitialized = true;
+    }
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          if (!this.isClosed) {
+            fiber.commit(this, 'flow');
+          }
+          break;
+        }
+      case 'open':
+        {
+          this.isClosed = false;
+          return;
+        }
+      case 'close':
+        {
+          this.isClosed = true;
+          return;
+        }
+      case 'toggle':
+        {
+          this.isClosed = !this.isClosed;
+          return;
+        }
+    }
+  }
+}
+_class$b = Gate;
+_defineProperty(Gate, "Description", new NodeDescription('flow/gate', 'Flow', 'Gate', (description, graph) => new _class$b(description, graph)));
+
+var _class$a;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class MultiGate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset'), new Socket('boolean', 'loop', true), new Socket('integer', 'startIndex', 0)], [new Socket('flow', '1'), new Socket('flow', '2'), new Socket('flow', '3')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "nextIndex", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.nextIndex = Number(this.readInput('startIndex'));
+    }
+    if (this.readInput('loop')) {
+      this.nextIndex = this.nextIndex % this.outputs.length;
+    }
+    switch (triggeringSocketName) {
+      case 'reset':
+        {
+          this.nextIndex = 0;
+          return;
+        }
+      case 'flow':
+        {
+          if (0 <= this.nextIndex && this.nextIndex < this.outputs.length) {
+            fiber.commit(this, this.outputs[this.nextIndex].name);
+          }
+          this.nextIndex++;
+          return;
+        }
+    }
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$a = MultiGate;
+_defineProperty(MultiGate, "Description", new NodeDescription('flow/multiGate', 'Flow', 'MultiGate', (description, graph) => new _class$a(description, graph)));
+
+var _class$9;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class Sequence extends FlowNode {
+  constructor(description, graph, configuration) {
+    const outputs = [];
+    const numOutputs = configuration.numOutputs;
+    for (let outputIndex = 1; outputIndex <= numOutputs; outputIndex++) {
+      outputs.push(new Socket('flow', `${outputIndex}`));
+    }
+    super(description, graph, [new Socket('flow', 'flow')], outputs);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$9 = Sequence;
+_defineProperty(Sequence, "Description", new NodeDescription2({
+  typeName: 'flow/sequence',
+  category: 'Flow',
+  label: 'Sequence',
+  configuration: {
+    numOutputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$9(description, graph, configuration)
+}));
+
+var _class$8;
+
+// based on the description here: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/
+
+class Throttle extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      if (this.timeoutPending) {
+        this.triggerVersion++;
+        this.timeoutPending = false;
+      }
+      return;
+    }
+
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.triggerVersion++;
+    const localTriggerCount = this.triggerVersion;
+    this.timeoutPending = true;
+    setTimeout(() => {
+      if (this.triggerVersion !== localTriggerCount) {
+        return;
+      }
+      Assert.mustBeTrue(this.timeoutPending);
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+    this.timeoutPending = false;
+  }
+}
+_class$8 = Throttle;
+_defineProperty(Throttle, "Description", new NodeDescription('flow/throttle', 'Flow', 'Throttle', (description, graph) => new _class$8(description, graph)));
+
+var _class$7;
+
+// this is equivalent to Promise.all()
+class WaitAll extends FlowNode {
+  constructor(description, graph, numInputs) {
+    const inputs = [];
+    for (let inputIndex = 1; inputIndex <= numInputs; inputIndex++) {
+      inputs.push(new Socket('flow', `${inputIndex}`));
+    }
+    super(description, graph, [...inputs, new Socket('flow', 'reset'), new Socket('boolean', 'autoReset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isOn", true);
+    _defineProperty(this, "triggeredMap", {});
+    _defineProperty(this, "triggeredCount", 0);
+    _defineProperty(this, "outputTriggered", false);
+    this.numInputs = numInputs;
+    this.reset();
+  }
+  reset() {
+    for (let inputIndex = 1; inputIndex <= this.numInputs; inputIndex++) {
+      this.triggeredMap[`${inputIndex}`] = false;
+    }
+    this.triggeredCount = 0;
+    this.outputTriggered = false;
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.reset();
+      return;
+    }
+    if (this.triggeredMap[triggeringSocketName]) {
+      return;
+    }
+    this.triggeredMap[triggeringSocketName] = true;
+    this.triggeredCount++;
+
+    // if a & b are triggered, first output!
+    if (this.triggeredCount === this.numInputs && !this.outputTriggered) {
+      fiber.commit(this, 'flow');
+      this.outputTriggered = true;
+
+      // auto-reset if required.
+      if (this.readInput('autoReset') === true) {
+        this.reset();
+      }
+    }
+  }
+}
+_class$7 = WaitAll;
+_defineProperty(WaitAll, "Description", new NodeDescription2({
+  typeName: 'flow/waitAll',
+  category: 'Flow',
+  label: 'WaitAll',
+  configuration: {
+    numInputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$7(description, graph, (configuration === null || configuration === void 0 ? void 0 : configuration.numInputs) || 3)
+}));
+
+var _class$6;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnEnd extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onEndEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onEndEvent === undefined);
+    this.onEndEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.endEvent.addListener(this.onEndEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onEndEvent !== undefined);
+    if (this.onEndEvent !== undefined) {
+      this.lifecycleEventEmitter.endEvent.removeListener(this.onEndEvent);
+    }
+  }
+}
+_class$6 = LifecycleOnEnd;
+_defineProperty(LifecycleOnEnd, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onEnd', 'Event', 'On End', (description, graph) => new _class$6(description, graph, lifecycleEventEmitter)));
+
+var _class$5;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnStart extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onStartEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onStartEvent === undefined);
+    this.onStartEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.startEvent.addListener(this.onStartEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onStartEvent !== undefined);
+    if (this.onStartEvent !== undefined) {
+      this.lifecycleEventEmitter.startEvent.removeListener(this.onStartEvent);
+    }
+  }
+}
+_class$5 = LifecycleOnStart;
+_defineProperty(LifecycleOnStart, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onStart', 'Event', 'On Start', (description, graph) => new _class$5(description, graph, lifecycleEventEmitter)));
+
+var _class$4;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnTick extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'deltaSeconds')]);
+    _defineProperty(this, "onTickEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onTickEvent === undefined);
+    let lastTickTime = Date.now();
+    this.onTickEvent = () => {
+      const currentTime = Date.now();
+      const deltaSeconds = (currentTime - lastTickTime) * 0.001;
+      this.writeOutput('deltaSeconds', deltaSeconds);
+      engine.commitToNewFiber(this, 'flow');
+      lastTickTime = currentTime;
+    };
+    this.lifecycleEventEmitter.tickEvent.addListener(this.onTickEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onTickEvent !== undefined);
+    if (this.onTickEvent !== undefined) {
+      this.lifecycleEventEmitter.tickEvent.removeListener(this.onTickEvent);
+    }
+  }
+}
+_class$4 = LifecycleOnTick;
+_defineProperty(LifecycleOnTick, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onTick', 'Event', 'On Tick', (description, graph) => new _class$4(description, graph, lifecycleEventEmitter)));
+
+const Constant$b = new NodeDescription('math/boolean', 'Logic', 'Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => a));
+const And = new NodeDescription('math/and/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a && b));
+const Or = new NodeDescription('math/or/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a || b));
+const Not = new NodeDescription('math/negate/boolean', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => !a));
+const ToFloat$2 = new NodeDescription('math/toFloat/boolean', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'float', a => a ? 1 : 0));
+const Equal$b = new NodeDescription('math/equal/boolean', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a === b));
+const toInteger = new NodeDescription('math/toInteger/boolean', 'Logic', 'To Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'integer', a => a ? 1n : 0n));
+
+var BooleanNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$b,
+  And: And,
+  Or: Or,
+  Not: Not,
+  ToFloat: ToFloat$2,
+  Equal: Equal$b,
+  toInteger: toInteger
+});
+
+const BooleanValue = new ValueType('boolean', () => false, value => typeof value === 'string' ? value.toLowerCase() === 'true' : value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+const EPSILON = 0.000001; // chosen from gl-matrix
+
+function equalsTolerance(a, b, tolerance = EPSILON) {
+  return Math.abs(a - b) < tolerance;
+}
+function degreesToRadians(a) {
+  return a * (Math.PI / 180);
+}
+function radiansToDegrees(a) {
+  return a * (180 / Math.PI);
+}
+function clamp(a, min, max) {
+  return a < min ? min : a > max ? max : a;
+}
+
+// Unreal Engine Blueprint Float nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Float/
+
+const Constant$a = new NodeDescription('math/float', 'Logic', 'Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => a));
+const Add$8 = new NodeDescription('math/add/float', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a + b));
+const Subtract$8 = new NodeDescription('math/subtract/float', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a - b));
+const Negate$9 = new NodeDescription('math/negate/float', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => -a));
+const Multiply$4 = new NodeDescription('math/multiply/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a * b));
+const Divide$1 = new NodeDescription('math/divide/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a / b));
+const Modulus$1 = new NodeDescription('math/modulus/float', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a % b));
+const Power = new NodeDescription('math/pow/float', 'Logic', 'POW', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', Math.pow));
+const SquareRoot = new NodeDescription('math/sqrt/float', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sqrt));
+const E = new NodeDescription('math/e/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.E));
+const Exp$1 = new NodeDescription('math/exp/float', 'Logic', 'EXP', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.exp));
+const Ln$1 = new NodeDescription('math/ln/float', 'Logic', 'LN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log));
+const Log2 = new NodeDescription('math/log2/float', 'Logic', 'LOG2', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log2));
+const Log10 = new NodeDescription('math/log10/float', 'Logic', 'LOG10', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log10));
+const PI = new NodeDescription('math/pi/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.PI));
+const Sin = new NodeDescription('math/sin/float', 'Logic', 'SIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sin));
+const Asin = new NodeDescription('math/asin/float', 'Logic', 'ASIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.asin));
+const Cos = new NodeDescription('math/cos/float', 'Logic', 'COS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.cos));
+const Acos = new NodeDescription('math/acos/float', 'Logic', 'ACOS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.acos));
+const Tan = new NodeDescription('math/tan/float', 'Logic', 'TAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.tan));
+const RadiansToDegrees = new NodeDescription('math/radiansToDegrees/float', 'Logic', 'To Degrees', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => radiansToDegrees(a), ['radian']));
+const DegreesToRadians = new NodeDescription('math/degreesToRadians/float', 'Logic', 'To Radians', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => degreesToRadians(a), ['degrees']));
+const Atan = new NodeDescription('math/atan/float', 'Logic', 'ATAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.atan));
+const Mix$7 = new NodeDescription('math/mix/float', 'Logic', 'MIX', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (a, b, t) => {
+  const s = 1 - t;
+  return a * s + b * t;
+}, ['a', 'b', 't']));
+const ToFloat$1 = new NodeDescription('math/toFloat/float', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => Number(a)));
+const Min$1 = new NodeDescription('math/min/float', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.min(a, b) // TODO: can I jsut pass in Math.min?
+));
+
+const Max$1 = new NodeDescription('math/max/float', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.max(a, b) // TODO: can I jsut pass in Math.max?
+));
+
+const Clamp$1 = new NodeDescription('math/clamp/float', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs$1 = new NodeDescription('math/abs/float', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.abs));
+const Sign$1 = new NodeDescription('math/sign/float', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sign));
+const Floor = new NodeDescription('math/floor/float', 'Logic', 'FLOOR', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.floor));
+const Ceil = new NodeDescription('math/ceil/float', 'Logic', 'CEIL', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.ceil));
+const Round = new NodeDescription('math/round/float', 'Logic', 'ROUND', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.round));
+const Trunc = new NodeDescription('math/trunc/float', 'Logic', 'TRUNC', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.trunc));
+const Random = new NodeDescription('math/random/float', 'Logic', 'RANDOM', (description, graph) => new In0Out1FuncNode(description, graph, 'float', Math.random));
+const Equal$a = new NodeDescription('math/equal/float', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a === b, ['a', 'b']));
+const EqualTolerance = new NodeDescription('math/equalTolerance/float', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'boolean', (a, b, tolerance) => equalsTolerance(a, b, tolerance), ['a', 'b', 'tolerance']));
+const GreaterThan$1 = new NodeDescription('math/greaterThan/float', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual$1 = new NodeDescription('math/greaterThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a >= b));
+const LessThan$1 = new NodeDescription('math/lessThan/float', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual$1 = new NodeDescription('math/lessThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a <= b));
+const IsNaN = new NodeDescription('math/isNaN/float', 'Logic', 'isNaN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', Number.isNaN));
+const IsInf = new NodeDescription('math/isInf/float', 'Logic', 'isInf', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', a => !Number.isFinite(a) && !Number.isNaN(a)));
+
+var FloatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$a,
+  Add: Add$8,
+  Subtract: Subtract$8,
+  Negate: Negate$9,
+  Multiply: Multiply$4,
+  Divide: Divide$1,
+  Modulus: Modulus$1,
+  Power: Power,
+  SquareRoot: SquareRoot,
+  E: E,
+  Exp: Exp$1,
+  Ln: Ln$1,
+  Log2: Log2,
+  Log10: Log10,
+  PI: PI,
+  Sin: Sin,
+  Asin: Asin,
+  Cos: Cos,
+  Acos: Acos,
+  Tan: Tan,
+  RadiansToDegrees: RadiansToDegrees,
+  DegreesToRadians: DegreesToRadians,
+  Atan: Atan,
+  Mix: Mix$7,
+  ToFloat: ToFloat$1,
+  Min: Min$1,
+  Max: Max$1,
+  Clamp: Clamp$1,
+  Abs: Abs$1,
+  Sign: Sign$1,
+  Floor: Floor,
+  Ceil: Ceil,
+  Round: Round,
+  Trunc: Trunc,
+  Random: Random,
+  Equal: Equal$a,
+  EqualTolerance: EqualTolerance,
+  GreaterThan: GreaterThan$1,
+  GreaterThanOrEqual: GreaterThanOrEqual$1,
+  LessThan: LessThan$1,
+  LessThanOrEqual: LessThanOrEqual$1,
+  IsNaN: IsNaN,
+  IsInf: IsInf
+});
+
+const cSeparator = /[^\d+.-]+/;
+function parseSafeFloat(text, fallback = 0) {
+  try {
+    return Number.parseFloat(text);
+  } catch (_unused) {
+    return fallback;
+  }
+}
+function parseSafeFloats(text, fallback = 0) {
+  return text.split(cSeparator).filter(Boolean).map(value => parseSafeFloat(value, fallback));
+}
+function toSafeString(elements) {
+  return `[${elements.join(',')}]`;
+}
+
+const FloatValue = new ValueType('float', () => 0, value => typeof value === 'string' ? parseSafeFloat(value, 0) : value, value => value, (start, end, t) => start * (1 - t) + end * t);
+
+// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/
+
+const Constant$9 = new NodeDescription('math/integer', 'Logic', 'Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a));
+const Add$7 = new NodeDescription('math/add/integer', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a + b));
+const Subtract$7 = new NodeDescription('math/subtract/integer', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a - b));
+const Negate$8 = new NodeDescription('math/negate/integer', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => -a));
+const Multiply$3 = new NodeDescription('math/multiply/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a * b));
+const Divide = new NodeDescription('math/divide/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a / b));
+const Modulus = new NodeDescription('math/modulus/integer', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a % b));
+const ToFloat = new NodeDescription('math/toFloat/integer', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'float', a => Number(a)));
+const Min = new NodeDescription('math/min/integer', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? b : a));
+const Max = new NodeDescription('math/max/integer', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? a : b));
+const Clamp = new NodeDescription('math/clamp/integer', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['integer', 'integer', 'integer'], 'integer', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs = new NodeDescription('math/abs/integer', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a < BigInt(0) ? -a : a));
+const Sign = new NodeDescription('math/sign/integer', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => BigInt(a < 0 ? -1 : a > 0 ? 1 : 0)));
+const Equal$9 = new NodeDescription('math/equal/integer', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a === b));
+const GreaterThan = new NodeDescription('math/greaterThan/integer', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual = new NodeDescription('math/greaterThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a >= b));
+const LessThan = new NodeDescription('math/lessThan/integer', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual = new NodeDescription('math/lessThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a <= b));
+const toBoolean = new NodeDescription('math/toBoolean/integer', 'Logic', 'To Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'boolean', a => a !== 0n));
+
+var IntegerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$9,
+  Add: Add$7,
+  Subtract: Subtract$7,
+  Negate: Negate$8,
+  Multiply: Multiply$3,
+  Divide: Divide,
+  Modulus: Modulus,
+  ToFloat: ToFloat,
+  Min: Min,
+  Max: Max,
+  Clamp: Clamp,
+  Abs: Abs,
+  Sign: Sign,
+  Equal: Equal$9,
+  GreaterThan: GreaterThan,
+  GreaterThanOrEqual: GreaterThanOrEqual,
+  LessThan: LessThan,
+  LessThanOrEqual: LessThanOrEqual,
+  toBoolean: toBoolean
+});
+
+const IntegerValue = new ValueType('integer', () => BigInt(0), value => BigInt(value), value => Number.MIN_SAFE_INTEGER <= value && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value.toString(),
+// prefer string to ensure full range is covered
+
+(start, end, t) => BigInt(Number(start) * (1 - t) + Number(end) * t));
+
+const Constant$8 = new NodeDescription('logic/string', 'Logic', 'String', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'string', a => a));
+const Concat = new NodeDescription('logic/concat/string', 'Logic', 'Concat', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'string', (a, b) => a.concat(b)));
+const Includes = new NodeDescription('logic/includes/string', 'Logic', 'Includes', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a.includes(b)));
+const Length$4 = new NodeDescription('logic/length/string', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'integer', a => BigInt(a.length)));
+const Equal$8 = new NodeDescription('math/equal/string', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a === b));
+
+var StringNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$8,
+  Concat: Concat,
+  Includes: Includes,
+  Length: Length$4,
+  Equal: Equal$8
+});
+
+const StringValue = new ValueType('string', () => '', value => value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+var _class$3;
+class VariableSet extends FlowNode {
+  static GetDescription(graph, variableId) {
+    const variable = graph.variables[variableId];
+    return new NodeDescription(`variable/set/${variable.id}`, 'Action', `Set`, (description, graph) => new VariableSet(description, graph, variable));
+  }
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [new Socket('flow', 'flow'), new Socket(variable.valueTypeName, 'value', undefined, variable.name) // variable name is a label so variable can be renamed without breaking graph.
+    ], [new Socket('flow', 'flow')], configuration);
+    this.variable = variable;
+  }
+  triggered(fiber, triggeredSocketName) {
+    this.variable.set(this.readInput('value'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$3 = VariableSet;
+_defineProperty(VariableSet, "Description", new NodeDescription2({
+  typeName: 'variable/set',
+  category: 'Action',
+  label: 'Set',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$3(description, graph, configuration)
+}));
+
+var _class$2;
+class VariableGet extends ImmediateNode {
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [], [new Socket(variable.valueTypeName, 'value', undefined, variable.name)],
+    // output socket label uses variable name like UE4, but name is value to avoid breaking graph when variable is renamed
+    () => {
+      this.writeOutput('value', variable.get());
+    }, configuration);
+  }
+}
+_class$2 = VariableGet;
+_defineProperty(VariableGet, "Description", new NodeDescription2({
+  typeName: 'variable/get',
+  category: 'Query',
+  label: 'Get',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$2(description, graph, configuration)
+}));
+
+const EasingFunctions = {
+  linear: t => t,
+  quadratic: t => t * t,
+  cubic: t => t * t * t,
+  quartric: t => t * t * t * t,
+  quintic: t => t * t * t * t * t,
+  sine: t => 1 - Math.cos(t * Math.PI / 2),
+  exponential: t => Math.pow(2, 10 * (t - 1)),
+  circle: t => 1 - Math.sqrt(1 - t * t),
+  back: t => {
+    const s = 1.70158;
+    return t * t * ((s + 1) * t - s);
+  },
+  elastic: t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * Math.PI),
+  bounce: t => {
+    if (t < 1 / 2.75) {
+      return 7.5625 * t * t;
+    }
+    if (t < 2 / 2.75) {
+      const _t = t - 1.5 / 2.75;
+      return 7.5625 * _t * _t + 0.75;
+    }
+    if (t < 2.5 / 2.75) {
+      const _t2 = t - 2.25 / 2.75;
+      return 7.5625 * _t2 * _t2 + 0.9375;
+    }
+    const t2 = t - 2.625 / 2.75;
+    return 7.5625 * t2 * t2 + 0.984375;
+  }
+};
+const EasingModes = {
+  in: easing => {
+    return easing;
+  },
+  out: easing => {
+    return t => 1 - easing(1 - t);
+  },
+  inOut: easing => {
+    return t => {
+      if (t < 0.5) {
+        return easing(t * 2) / 2;
+      }
+      return 1 - easing((1 - t) * 2) / 2;
+    };
+  }
+};
+
+var _class$1;
+class Easing extends ImmediateNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('string', 'easingFunction', 'linear', undefined, Object.keys(EasingFunctions)), new Socket('string', 'easingMode', 'inOut', undefined, Object.keys(EasingModes)), new Socket('float', 't')], [new Socket('float', 't')], () => {
+      const easingFunction = EasingFunctions[this.readInput('easingFunction')];
+      const easingMode = EasingModes[this.readInput('easingMode')];
+      const easing = easingMode(easingFunction);
+      const inputT = this.readInput('t');
+      this.writeOutput('t', easing(inputT));
+    });
+  }
+}
+_class$1 = Easing;
+_defineProperty(Easing, "Description", new NodeDescription('math/easing', 'Logic', 'Easing', (description, graph) => new _class$1(description, graph)));
+
+function toCamelCase(text) {
+  if (text.length > 0) {
+    return text.slice(0, 1).toLocaleUpperCase() + text.slice(1);
+  }
+  return text;
+}
+
+/* eslint-disable @typescript-eslint/no-explicit-any */
+function registerSerializersForValueType(registry, valueTypeName) {
+  const camelCaseValueTypeName = toCamelCase(valueTypeName);
+  registry.nodes.register(new NodeDescription(`math/to${camelCaseValueTypeName}/string`, 'Logic', `To ${camelCaseValueTypeName}`, (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, ['string'], valueTypeName, a => registry.values.get(valueTypeName).deserialize(a))), new NodeDescription(`math/toString/${valueTypeName}`, 'Logic', 'To String', (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, [valueTypeName], 'string', a => registry.values.get(valueTypeName).serialize(a))));
+}
+
+// Unreal Engine Blueprint Time nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Utilities/Time/
+
+const Now = new NodeDescription('time/now', 'Logic', 'Now', (description, graph) => {
+  // ensure we do not leak current actual time, just time since initialization?
+  const startTime = Date.now();
+  return new In0Out1FuncNode(description, graph, 'float', () => (Date.now() - startTime) / 1000);
+});
+
+var TimeNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Now: Now
+});
+
+/* eslint-disable max-len */
+function registerCoreProfile(registry, logger = new DefaultLogger(), lifecycleEventEmitter = new ManualLifecycleEventEmitter()) {
+  const {
+    nodes,
+    values
+  } = registry;
+
+  // pull in value type nodes
+  values.register(BooleanValue);
+  values.register(StringValue);
+  values.register(IntegerValue);
+  values.register(FloatValue);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(StringNodes));
+  nodes.register(...getNodeDescriptions(BooleanNodes));
+  nodes.register(...getNodeDescriptions(IntegerNodes));
+  nodes.register(...getNodeDescriptions(FloatNodes));
+
+  // custom events
+
+  nodes.register(OnCustomEvent.Description);
+  nodes.register(TriggerCustomEvent.Description);
+
+  // variables
+
+  nodes.register(VariableGet.Description);
+  nodes.register(VariableSet.Description);
+
+  // complex logic
+
+  nodes.register(Easing.Description);
+
+  // actions
+
+  nodes.register(Log.Description(logger));
+  nodes.register(ExpectTrue.Description);
+
+  // events
+
+  nodes.register(LifecycleOnStart.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnEnd.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnTick.Description(lifecycleEventEmitter));
+
+  // time
+
+  nodes.register(Delay.Description);
+  nodes.register(...getNodeDescriptions(TimeNodes));
+
+  // flow control
+
+  nodes.register(Branch.Description);
+  nodes.register(FlipFlop.Description);
+  nodes.register(ForLoop.Description);
+  nodes.register(Sequence.Description);
+  nodes.register(Debounce.Description);
+  nodes.register(Throttle.Description);
+  nodes.register(DoN.Description);
+  nodes.register(DoOnce.Description);
+  nodes.register(Gate.Description);
+  nodes.register(MultiGate.Description);
+  nodes.register(WaitAll.Description);
+  nodes.register(Counter.Description);
+
+  // string converters
+
+  ['boolean', 'float', 'integer'].forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+class Vec2 {
+  constructor(x = 0, y = 0) {
+    this.x = x;
+    this.y = y;
+  }
+  clone(result = new Vec2()) {
+    return result.set(this.x, this.y);
+  }
+  set(x, y) {
+    this.x = x;
+    this.y = y;
+    return this;
+  }
+}
+function vec2Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance);
+}
+function vec2Add(a, b, result = new Vec2()) {
+  return result.set(a.x + b.x, a.y + b.y);
+}
+function vec2Subtract(a, b, result = new Vec2()) {
+  return result.set(a.x - b.x, a.y - b.y);
+}
+function vec2MultiplyByScalar(a, b, result = new Vec2()) {
+  return result.set(a.x * b, a.y * b);
+}
+function vec2Negate(a, result = new Vec2()) {
+  return result.set(-a.x, -a.y);
+}
+function vec2Length(a) {
+  return Math.sqrt(vec2Dot(a, a));
+}
+function vec2Normalize(a, result = new Vec2()) {
+  const invLength = 1 / vec2Length(a);
+  return vec2MultiplyByScalar(a, invLength, result);
+}
+function vec2Dot(a, b) {
+  return a.x * b.x + a.y * b.y;
+}
+function vec2Mix(a, b, t, result = new Vec2()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t);
+}
+function vec2FromArray(array, offset = 0, result = new Vec2()) {
+  return result.set(array[offset + 0], array[offset + 1]);
+}
+function vec2ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+}
+function vec2ToString(a) {
+  return toSafeString([a.x, a.y]);
+}
+function vec2Parse(text, result = new Vec2()) {
+  return vec2FromArray(parseSafeFloats(text), 0, result);
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, 1 ) x [ 0  3  6 ] = ( x', y', 1 )
+//               [ 1  4  7 ]
+//               [ 2  5  8 ]
+// where elements 2 and 5 would be translation in 2D, as they would multiplied
+// by the last virtual element of the 2D vector.
+const NUM_ROWS$1 = 3;
+const NUM_COLUMNS$1 = 3;
+const NUM_ELEMENTS$1 = NUM_ROWS$1 * NUM_COLUMNS$1;
+class Mat3 {
+  constructor(elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat3()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat3SetColumn3(m, columnIndex, column, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  const base = columnIndex * NUM_ROWS$1;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  return result;
+}
+function mat3SetRow3(m, rowIndex, row, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  re[rowIndex + NUM_COLUMNS$1 * 0] = row.x;
+  re[rowIndex + NUM_COLUMNS$1 * 1] = row.y;
+  re[rowIndex + NUM_COLUMNS$1 * 2] = row.z;
+  return result;
+}
+function column3ToMat3(a, b, c, result = new Mat3()) {
+  const re = result.elements;
+  const columns = [a, b, c];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS$1;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+  }
+  return result;
+}
+function mat3Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat3Add(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat3Subtract(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat3MultiplyByScalar(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat3Negate(a, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat3Multiply(a, b, result = new Mat3()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[3],
+    a13 = ae[6];
+  const a21 = ae[1],
+    a22 = ae[4],
+    a23 = ae[7];
+  const a31 = ae[2],
+    a32 = ae[5],
+    a33 = ae[8];
+  const b11 = be[0],
+    b12 = be[3],
+    b13 = be[6];
+  const b21 = be[1],
+    b22 = be[4],
+    b23 = be[7];
+  const b31 = be[2],
+    b32 = be[5],
+    b33 = be[8];
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31;
+  te[3] = a11 * b12 + a12 * b22 + a13 * b32;
+  te[6] = a11 * b13 + a12 * b23 + a13 * b33;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31;
+  te[4] = a21 * b12 + a22 * b22 + a23 * b32;
+  te[7] = a21 * b13 + a22 * b23 + a23 * b33;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31;
+  te[5] = a31 * b12 + a32 * b22 + a33 * b32;
+  te[8] = a31 * b13 + a32 * b23 + a33 * b33;
+  return result;
+}
+function mat3Determinant(m) {
+  const me = m.elements;
+  const a = me[0],
+    b = me[1],
+    c = me[2],
+    d = me[3],
+    e = me[4],
+    f = me[5],
+    g = me[6],
+    h = me[7],
+    i = me[8];
+  return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
+}
+function mat3Transpose(m, result = new Mat3()) {
+  const me = m.elements;
+  const te = result.elements;
+  te[0] = me[0];
+  te[4] = me[4];
+  te[8] = me[8];
+  te[1] = me[3];
+  te[3] = me[1];
+  te[2] = me[6];
+  te[6] = me[2];
+  te[5] = me[7];
+  te[7] = me[5];
+  return result;
+}
+function mat3Inverse(m, result = new Mat3()) {
+  const e = m.elements;
+  const n11 = e[0],
+    n21 = e[1],
+    n31 = e[2],
+    n12 = e[3],
+    n22 = e[4],
+    n32 = e[5],
+    n13 = e[6],
+    n23 = e[7],
+    n33 = e[8],
+    t11 = n33 * n22 - n32 * n23,
+    t12 = n32 * n13 - n33 * n12,
+    t13 = n23 * n12 - n22 * n13,
+    det = n11 * t11 + n21 * t12 + n31 * t13;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+  const re = result.elements;
+
+  // TODO: replace with a set
+  re[0] = t11 * detInv;
+  re[1] = (n31 * n23 - n33 * n21) * detInv;
+  re[2] = (n32 * n21 - n31 * n22) * detInv;
+  re[3] = t12 * detInv;
+  re[4] = (n33 * n11 - n31 * n13) * detInv;
+  re[5] = (n31 * n12 - n32 * n11) * detInv;
+  re[6] = t13 * detInv;
+  re[7] = (n21 * n13 - n23 * n11) * detInv;
+  re[8] = (n22 * n11 - n21 * n12) * detInv;
+  return result;
+}
+function mat3Mix(a, b, t, result = new Mat3()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat3FromArray(array, offset = 0, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat3Parse(text, result = new Mat3()) {
+  return mat3FromArray(parseSafeFloats(text), 0, result);
+}
+function eulerToMat3(euler, result = new Mat3()) {
+  const te = result.elements;
+  const x = euler.x,
+    y = euler.y,
+    z = euler.z;
+  const a = Math.cos(x),
+    b = Math.sin(x);
+  const c = Math.cos(y),
+    d = Math.sin(y);
+  const e = Math.cos(z),
+    f = Math.sin(z);
+  const ae = a * e,
+    af = a * f,
+    be = b * e,
+    bf = b * f;
+  te[0] = c * e;
+  te[3] = -c * f;
+  te[6] = d;
+  te[1] = af + be * d;
+  te[4] = ae - bf * d;
+  te[7] = -b * c;
+  te[2] = bf - ae * d;
+  te[5] = be + af * d;
+  te[8] = a * c;
+  return result;
+}
+function quatToMat3(q, result = new Mat3()) {
+  const x = q.x,
+    y = q.y,
+    z = q.z,
+    w = q.w;
+  const x2 = x + x,
+    y2 = y + y,
+    z2 = z + z;
+  const xx = x * x2,
+    xy = x * y2,
+    xz = x * z2;
+  const yy = y * y2,
+    yz = y * z2,
+    zz = z * z2;
+  const wx = w * x2,
+    wy = w * y2,
+    wz = w * z2;
+  return result.set([1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)]);
+}
+function scale2ToMat3(s, result = new Mat3()) {
+  return result.set([s.x, 0, 0, 0, s.y, 0, 0, 0, 1]);
+}
+// from gl-matrix
+function mat3ToScale2(m, result = new Vec2()) {
+  const mat = m.elements;
+  const m11 = mat[0];
+  const m12 = mat[1];
+  const m21 = mat[3];
+  const m22 = mat[4];
+  return result.set(Math.sqrt(m11 * m11 + m12 * m12), Math.sqrt(m21 * m21 + m22 * m22));
+}
+function translation2ToMat3(t, result = new Mat3()) {
+  return result.set([1, 0, t.x, 0, 1, t.y, 0, 0, 1]);
+}
+function mat3ToTranslation2(m, result = new Vec2()) {
+  return result.set(m.elements[2], m.elements[5]);
+}
+function mat4ToMat3(a, result = new Mat3()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], ae[4], ae[5], ae[6], ae[8], ae[9], ae[10]]);
+}
+
+class Vec3 {
+  constructor(x = 0, y = 0, z = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+  }
+  clone(result = new Vec3()) {
+    return result.set(this.x, this.y, this.z);
+  }
+  set(x, y, z) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    return this;
+  }
+}
+function vec3Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance);
+}
+function vec3Add(a, b, result = new Vec3()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+function vec3Subtract(a, b, result = new Vec3()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+function vec3MultiplyByScalar(a, b, result = new Vec3()) {
+  return result.set(a.x * b, a.y * b, a.z * b);
+}
+function vec3Negate(a, result = new Vec3()) {
+  return result.set(-a.x, -a.y, -a.z);
+}
+function vec3Length(a) {
+  return Math.sqrt(vec3Dot(a, a));
+}
+function vec3Normalize(a, result = new Vec3()) {
+  const invLength = 1 / vec3Length(a);
+  return vec3MultiplyByScalar(a, invLength, result);
+}
+function vec3Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+function vec3Cross(a, b, result = new Vec3()) {
+  const ax = a.x;
+  const ay = a.y;
+  const az = a.z;
+  const bx = b.x;
+  const by = b.y;
+  const bz = b.z;
+  return result.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
+}
+function vec3Mix(a, b, t, result = new Vec3()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t);
+}
+function vec3FromArray(array, offset = 0, result = new Vec3()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2]);
+}
+function vec3ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+}
+function vec3ToString(a) {
+  return toSafeString([a.x, a.y, a.z]);
+}
+function vec3Parse(text, result = new Vec3()) {
+  return vec3FromArray(parseSafeFloats(text), 0, result);
+}
+function hslToRGB(hsl, result = new Vec3()) {
+  function hue2rgb(p, q, t) {
+    if (t < 0) {
+      t += 1;
+    }
+    if (t > 1) {
+      t -= 1;
+    }
+    if (t < 1 / 6) {
+      return p + (q - p) * 6 * t;
+    }
+    if (t < 1 / 2) {
+      return q;
+    }
+    if (t < 2 / 3) {
+      return p + (q - p) * 6 * (2 / 3 - t);
+    }
+    return p;
+  }
+
+  // h,s,l ranges are in 0.0 - 1.0
+  const h = (hsl.x % 1 + 1) % 1; // euclidean modulo
+  const s = Math.min(Math.max(hsl.y, 0), 1);
+  const l = Math.min(Math.max(hsl.z, 0), 1);
+  if (s === 0) {
+    return result.set(1, 1, 1);
+  }
+  const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
+  const q = 2 * l - p;
+  return result.set(hue2rgb(q, p, h + 1 / 3), hue2rgb(q, p, h), hue2rgb(q, p, h - 1 / 3));
+}
+function rgbToHSL(rgb, result = new Vec3()) {
+  // h,s,l ranges are in 0.0 - 1.0
+  const r = rgb.x,
+    g = rgb.y,
+    b = rgb.z;
+  const max = Math.max(r, g, b);
+  const min = Math.min(r, g, b);
+  let hue = 0;
+  let saturation = 0;
+  const lightness = (min + max) / 2;
+  if (min === max) {
+    hue = 0;
+    saturation = 0;
+  } else {
+    const delta = max - min;
+    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
+    switch (max) {
+      case r:
+        hue = (g - b) / delta + (g < b ? 6 : 0);
+        break;
+      case g:
+        hue = (b - r) / delta + 2;
+        break;
+      case b:
+        hue = (r - g) / delta + 4;
+        break;
+    }
+    hue /= 6;
+  }
+  return result.set(hue, saturation, lightness);
+}
+function hexToRGB(hex, result = new Vec3()) {
+  hex = Math.floor(hex);
+  return result.set((hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255);
+}
+function rgbToHex(rgb) {
+  return rgb.x * 255 << 16 ^ rgb.y * 255 << 8 ^ rgb.z * 255 << 0;
+}
+
+// from three.js
+function mat3ToEuler(m, result = new Vec3()) {
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  const te = m.elements;
+  const m11 = te[0],
+    m12 = te[3],
+    m13 = te[6];
+  te[1];
+    const m22 = te[4],
+    m23 = te[7];
+  te[2];
+    const m32 = te[5],
+    m33 = te[8];
+  result.y = Math.asin(clamp(m13, -1, 1));
+  if (Math.abs(m13) < 0.9999999) {
+    result.x = Math.atan2(-m23, m33);
+    result.z = Math.atan2(-m12, m11);
+  } else {
+    result.x = Math.atan2(m32, m22);
+    result.z = 0;
+  }
+  return result;
+}
+
+// from three.js
+function mat4ToEuler(m, result = new Vec3()) {
+  return mat3ToEuler(mat4ToMat3(m), result);
+}
+function quatToEuler(q, result = new Vec3()) {
+  return mat3ToEuler(quatToMat3(q), result);
+}
+
+const ColorValue = new ValueType('color', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const EulerValue = new ValueType('euler', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+class Vec4 {
+  constructor(x = 0, y = 0, z = 0, w = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+  }
+  clone(result = new Vec4()) {
+    return result.set(this.x, this.y, this.z, this.w);
+  }
+  set(x, y, z, w) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+    return this;
+  }
+}
+function vec4Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance) && equalsTolerance(a.w, b.w, tolerance);
+}
+function vec4Add(a, b, result = new Vec4()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
+}
+function vec4Subtract(a, b, result = new Vec4()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
+}
+function vec4MultiplyByScalar(a, b, result = new Vec4()) {
+  return result.set(a.x * b, a.y * b, a.z * b, a.w * b);
+}
+function vec4Negate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, -a.w);
+}
+function vec4Length(a) {
+  return Math.sqrt(vec4Dot(a, a));
+}
+function vec4Normalize(a, result = new Vec4()) {
+  const invLength = 1 / vec4Length(a);
+  return vec4MultiplyByScalar(a, invLength, result);
+}
+function vec4Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+function vec4Mix(a, b, t, result = new Vec4()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
+}
+function vec4FromArray(array, offset = 0, result = new Vec4()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2], array[offset + 3]);
+}
+function vec4ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+  array[offset + 3] = a.w;
+}
+function vec4ToString(a) {
+  return toSafeString([a.x, a.y, a.z, a.w]);
+}
+function vec4Parse(text, result = new Vec4()) {
+  return vec4FromArray(parseSafeFloats(text), 0, result);
+}
+function quatConjugate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, a.w);
+}
+function quatMultiply(a, b, result = new Vec4()) {
+  // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
+
+  const qax = a.x;
+  const qay = a.y;
+  const qaz = a.z;
+  const qaw = a.w;
+  const qbx = b.x;
+  const qby = b.y;
+  const qbz = b.z;
+  const qbw = b.w;
+  return result.set(qax * qbw + qaw * qbx + qay * qbz - qaz * qby, qay * qbw + qaw * qby + qaz * qbx - qax * qbz, qaz * qbw + qaw * qbz + qax * qby - qay * qbx, qaw * qbw - qax * qbx - qay * qby - qaz * qbz);
+}
+function quatSlerp(a, b, t, result = new Vec4()) {
+  if (t <= 0) return a.clone(result);
+  if (t >= 1) return b.clone(result);
+
+  // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
+
+  let cosHalfTheta = vec4Dot(a, b);
+  if (cosHalfTheta < 0) {
+    vec4Negate(b, result);
+    cosHalfTheta = -cosHalfTheta;
+  } else {
+    b.clone(result);
+  }
+  if (cosHalfTheta >= 1) {
+    return result;
+  }
+  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
+  if (sqrSinHalfTheta <= Number.EPSILON) {
+    vec4Mix(a, result, t);
+    vec4Normalize(result, result);
+    return result;
+  }
+  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
+  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
+  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
+  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
+  result.w = a.w * ratioA + result.w * ratioB;
+  result.x = a.x * ratioA + result.x * ratioB;
+  result.y = a.y * ratioA + result.y * ratioB;
+  result.z = a.z * ratioA + result.z * ratioB;
+  return result;
+}
+
+/**
+ * Calculate the exponential of a unit quaternion.
+ *
+ * @param {quat} out the receiving quaternion
+ * @param {ReadonlyQuat} a quat to calculate the exponential of
+ * @returns {quat} out
+ */
+function quatExp(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const et = Math.exp(w);
+  const s = r > 0 ? et * Math.sin(r) / r : 0;
+  return result.set(x * s, y * s, z * s, et * Math.cos(r));
+}
+
+// from gl-matrix
+function quatLn(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const t = r > 0 ? Math.atan2(r, w) / r : 0;
+  return result.set(x * t, y * t, z * t, 0.5 * Math.log(x * x + y * y + z * z + w * w));
+}
+
+// from gl-matrix
+function quatPow(a, b, result = new Vec4()) {
+  const ln = quatLn(a);
+  const lnScaled = vec4MultiplyByScalar(ln, b);
+  quatExp(lnScaled, result);
+  return result;
+}
+function eulerToQuat(euler, result = new Vec4()) {
+  // eslint-disable-next-line max-len
+  // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
+
+  const c1 = Math.cos(euler.x / 2);
+  const c2 = Math.cos(euler.y / 2);
+  const c3 = Math.cos(euler.z / 2);
+  const s1 = Math.sin(euler.x / 2);
+  const s2 = Math.sin(euler.y / 2);
+  const s3 = Math.sin(euler.z / 2);
+
+  // XYZ order only
+  return result.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
+}
+function angleAxisToQuat(angle, axis, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
+
+  // assumes axis is normalized
+
+  const halfAngle = angle / 2;
+  const s = Math.sin(halfAngle);
+  return result.set(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
+}
+
+// from gl-matrix
+function quatToAngleAxis(q, result = new Vec3()) {
+  const rad = Math.acos(q.w) * 2;
+  const s = Math.sin(rad / 2);
+  if (s > EPSILON) {
+    result.x = q.x / s;
+    result.y = q.y / s;
+    result.z = q.z / s;
+  } else {
+    // If s is zero, return any axis (no rotation - axis does not matter)
+    result.x = 1;
+    result.y = 0;
+    result.z = 0;
+  }
+  return [rad, result];
+}
+function mat4ToQuat(m, result = new Vec4()) {
+  return mat3ToQuat(mat4ToMat3(m), result);
+}
+function mat3ToQuat(m, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
+
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  // TODO, allocate x, y, z, w and only set q.* at the end.
+
+  const te = m.elements,
+    m11 = te[0],
+    m12 = te[3],
+    m13 = te[6],
+    m21 = te[1],
+    m22 = te[4],
+    m23 = te[7],
+    m31 = te[2],
+    m32 = te[5],
+    m33 = te[8],
+    trace = m11 + m22 + m33;
+  if (trace > 0) {
+    const _s = 0.5 / Math.sqrt(trace + 1);
+    return result.set((m32 - m23) * _s, (m13 - m31) * _s, (m21 - m12) * _s, 0.25 / _s);
+  }
+  if (m11 > m22 && m11 > m33) {
+    const _s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
+    return result.set(0.25 * _s2, (m12 + m21) / _s2, (m13 + m31) / _s2, (m32 - m23) / _s2);
+  }
+  if (m22 > m33) {
+    const _s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
+    return result.set((m12 + m21) / _s3, 0.25 * _s3, (m23 + m32) / _s3, (m13 - m31) / _s3);
+  }
+  const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
+  return result.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
+}
+
+const QuatValue = new ValueType('quat', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => quatSlerp(start, end, t));
+
+const Vec2Value = new ValueType('vec2', () => new Vec2(), value => typeof value === 'string' ? vec2Parse(value) : new Vec2(value[0], value[1]), value => [value.x, value.y], (start, end, t) => vec2Mix(start, end, t));
+
+const Vec3Value = new ValueType('vec3', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const Vec4Value = new ValueType('vec4', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => vec4Mix(start, end, t));
+
+class DummyScene {
+  constructor() {
+    _defineProperty(this, "onSceneChanged", new EventEmitter());
+    _defineProperty(this, "valueRegistry", new ValueTypeRegistry());
+    const values = this.valueRegistry;
+    // pull in value type nodes
+    values.register(BooleanValue);
+    values.register(StringValue);
+    values.register(IntegerValue);
+    values.register(FloatValue);
+    values.register(Vec2Value);
+    values.register(Vec3Value);
+    values.register(Vec4Value);
+    values.register(ColorValue);
+    values.register(EulerValue);
+    values.register(QuatValue);
+  }
+  getProperty(jsonPath, valueTypeName) {
+    return this.valueRegistry.get(valueTypeName).creator();
+  }
+  setProperty() {
+    this.onSceneChanged.emit();
+  }
+  addOnClickedListener(jsonPath, callback) {
+    throw new Error('Method not implemented.');
+  }
+}
+
+class SetSceneProperty extends FlowNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/set/${valueTypeName}`, 'Action', `Set Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new SetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'jsonPath'), new Socket(valueTypeName, 'value')], [new Socket('flow', 'flow')]);
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const scene = this.scene;
+    const value = this.readInput('value');
+    scene.setProperty(this.readInput('jsonPath'), this.valueTypeName, value);
+    fiber.commit(this, 'flow');
+  }
+}
+
+var _class;
+
+// very 3D specific.
+class OnSceneNodeClick extends EventNode {
+  constructor(description, graph) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'nodeIndex')]);
+  }
+}
+_class = OnSceneNodeClick;
+_defineProperty(OnSceneNodeClick, "Description", new NodeDescription('scene/nodeClick', 'Event', 'On Node Click', (description, graph) => new _class(description, graph)));
+
+class VecElements extends ImmediateNode {
+  constructor(description, graph, valueTypeName, elementNames = ['x', 'y', 'z', 'w'], toArray) {
+    super(description, graph, [new Socket(valueTypeName, 'value')], elementNames.map(elementName => new Socket('float', elementName)), () => {
+      const value = this.readInput('value');
+      const elementValues = elementNames.map(() => 0);
+      toArray(value, elementValues, 0);
+      elementNames.forEach((elementName, index) => this.writeOutput(elementName, elementValues[index]));
+    });
+  }
+}
+
+class GetSceneProperty extends ImmediateNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/get/${valueTypeName}`, 'Query', `Get Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new GetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('string', 'jsonPath')], [new Socket(valueTypeName, 'value')], () => {
+      this.writeOutput('value', this.scene.getProperty(this.readInput('jsonPath'), valueTypeName));
+    });
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+}
+
+const Constant$7 = new NodeDescription('math/color', 'Logic', 'Color', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', a => a));
+const Create$5 = new NodeDescription('math/toColor/rgb', 'Logic', 'RGB To Color', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'color', (r, g, b) => new Vec3(r, g, b), ['r', 'g', 'b']));
+const Elements$7 = new NodeDescription('math/toRgb/color', 'Logic', 'Color to RGB', (description, graph) => new VecElements(description, graph, 'color', ['r', 'g', 'b'], vec3ToArray));
+const Add$6 = new NodeDescription('math/add/color', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Add));
+const Subtract$6 = new NodeDescription('math/subtract/color', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Subtract));
+const Negate$7 = new NodeDescription('math/negate/color', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', vec3Negate));
+const Scale$7 = new NodeDescription('math/scale/color', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'float'], 'color', vec3MultiplyByScalar));
+const Mix$6 = new NodeDescription('math/mix/color', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'color', vec3Mix, ['a', 'b', 't']));
+const HslToColor = new NodeDescription('math/ToColor/hsl', 'Logic', 'HSL to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'color', hslToRGB));
+const ColorToHsl = new NodeDescription('math/toHsl/color', 'Logic', 'Color to HSL', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'vec3', rgbToHSL));
+const HexToColor = new NodeDescription('math/toColor/hex', 'Logic', 'HEX to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'color', hexToRGB));
+const ColorToHex = new NodeDescription('math/toHex/color', 'Logic', 'Color to HEX', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'float', rgbToHex));
+const Equal$7 = new NodeDescription('math/equal/color', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var ColorNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$7,
+  Create: Create$5,
+  Elements: Elements$7,
+  Add: Add$6,
+  Subtract: Subtract$6,
+  Negate: Negate$7,
+  Scale: Scale$7,
+  Mix: Mix$6,
+  HslToColor: HslToColor,
+  ColorToHsl: ColorToHsl,
+  HexToColor: HexToColor,
+  ColorToHex: ColorToHex,
+  Equal: Equal$7
+});
+
+const Constant$6 = new NodeDescription('math/euler', 'Logic', 'Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', a => a));
+const Create$4 = new NodeDescription('math/toEuler/float', 'Logic', 'Float to Euler', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'euler', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$6 = new NodeDescription('math/toFloat/euler', 'Logic', 'Euler to Float', (description, graph) => new VecElements(description, graph, 'euler', ['x', 'y', 'z'], vec3ToArray));
+const Add$5 = new NodeDescription('math/add/euler', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Add));
+const Subtract$5 = new NodeDescription('math/subtract/euler', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Subtract));
+const Negate$6 = new NodeDescription('math/negate/euler', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', vec3Negate));
+const Scale$6 = new NodeDescription('math/scale/euler', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'float'], 'euler', vec3MultiplyByScalar));
+const Mix$5 = new NodeDescription('math/mix/euler', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'euler', vec3Mix, ['a', 'b', 't']));
+const Mat3ToEuler = new NodeDescription('math/toEuler/mat3', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'euler', mat3ToEuler));
+const Mat4ToEuler = new NodeDescription('math/toEuler/mat4', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'euler', mat4ToEuler));
+const QuatToEuler = new NodeDescription('math/toEuler/quat', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'euler', quatToEuler));
+const Equal$6 = new NodeDescription('math/equal/euler', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var EulerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$6,
+  Create: Create$4,
+  Elements: Elements$6,
+  Add: Add$5,
+  Subtract: Subtract$5,
+  Negate: Negate$6,
+  Scale: Scale$6,
+  Mix: Mix$5,
+  Mat3ToEuler: Mat3ToEuler,
+  Mat4ToEuler: Mat4ToEuler,
+  QuatToEuler: QuatToEuler,
+  Equal: Equal$6
+});
+
+const Constant$5 = new NodeDescription('math/vec2', 'Logic', 'Vec2', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', a => a));
+const Create$3 = new NodeDescription('math/toVec2/float', 'Logic', 'Float to Vec2', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'vec2', (x, y) => new Vec2(x, y), ['x', 'y']));
+const Elements$5 = new NodeDescription('math/toFloat/vec2', 'Logic', 'Vec2 To Float', (description, graph) => new VecElements(description, graph, 'vec2', ['x', 'y', 'z'], vec2ToArray));
+const Add$4 = new NodeDescription('math/add/vec2', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Add));
+const Subtract$4 = new NodeDescription('math/subtract/vec2', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Subtract));
+const Negate$5 = new NodeDescription('math/negate/vec2', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Negate));
+const Scale$5 = new NodeDescription('math/scale/vec2', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'float'], 'vec2', vec2MultiplyByScalar));
+const Length$3 = new NodeDescription('math/length/vec2', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'float', vec2Length));
+const Normalize$3 = new NodeDescription('math/normalize/vec2', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Normalize));
+const Dot$3 = new NodeDescription('math/dot/vec2', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'float', vec2Dot));
+const Mix$4 = new NodeDescription('math/mix/vec2', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'vec2', vec2Mix, ['a', 'b', 't']));
+const Equal$5 = new NodeDescription('math/equal/vec2', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'boolean', vec2Equals, ['a', 'b', 'tolerance']));
+
+var Vec2Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$5,
+  Create: Create$3,
+  Elements: Elements$5,
+  Add: Add$4,
+  Subtract: Subtract$4,
+  Negate: Negate$5,
+  Scale: Scale$5,
+  Length: Length$3,
+  Normalize: Normalize$3,
+  Dot: Dot$3,
+  Mix: Mix$4,
+  Equal: Equal$5
+});
+
+const Constant$4 = new NodeDescription('math/vec3', 'Logic', 'Vec3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', a => a));
+const Create$2 = new NodeDescription('math/toVec3/float', 'Logic', 'Float to Vec3', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'vec3', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$4 = new NodeDescription('math/toFloat/vec3', 'Logic', 'Vec3 To Float', (description, graph) => new VecElements(description, graph, 'vec3', ['x', 'y', 'z'], vec3ToArray));
+const Add$3 = new NodeDescription('math/add/vec3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Add));
+const Subtract$3 = new NodeDescription('math/subtract/vec3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Subtract));
+const Negate$4 = new NodeDescription('math/negate/vec3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Negate));
+const Scale$4 = new NodeDescription('math/scale/vec3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'float'], 'vec3', vec3MultiplyByScalar));
+const Length$2 = new NodeDescription('math/length/vec3', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'float', vec3Length));
+const Normalize$2 = new NodeDescription('math/normalize/vec3', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Normalize));
+const Cross = new NodeDescription('math/cross/vec3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Cross));
+const Dot$2 = new NodeDescription('math/dot/vec3', 'Logic', 'Dot', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'float', vec3Dot));
+const Mix$3 = new NodeDescription('math/mix/vec3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'vec3', vec3Mix, ['a', 'b', 't']));
+const Equal$4 = new NodeDescription('math/equal/vec3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var Vec3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$4,
+  Create: Create$2,
+  Elements: Elements$4,
+  Add: Add$3,
+  Subtract: Subtract$3,
+  Negate: Negate$4,
+  Scale: Scale$4,
+  Length: Length$2,
+  Normalize: Normalize$2,
+  Cross: Cross,
+  Dot: Dot$2,
+  Mix: Mix$3,
+  Equal: Equal$4
+});
+
+const Constant$3 = new NodeDescription('math/vec4', 'Logic', 'Vec4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', a => a));
+const Create$1 = new NodeDescription('math/toVec4/float', 'Logic', 'Float to Vec4', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'vec4', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$3 = new NodeDescription('math/toFloat/vec4', 'Logic', 'Vec4 to Float', (description, graph) => new VecElements(description, graph, 'vec4', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Add$2 = new NodeDescription('math/add/vec4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Add));
+const Subtract$2 = new NodeDescription('math/subtract/vec4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Subtract));
+const Negate$3 = new NodeDescription('math/negate/vec4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Negate));
+const Scale$3 = new NodeDescription('math/scale/vec4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'float'], 'vec4', vec4MultiplyByScalar));
+const Length$1 = new NodeDescription('math/length/vec4', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'float', vec4Length));
+const Normalize$1 = new NodeDescription('math/normalize/vec4', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Normalize));
+const Dot$1 = new NodeDescription('math/dot/vec4', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'float', vec4Dot));
+const Mix$2 = new NodeDescription('math/mix/vec4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'vec4', vec4Mix, ['a', 'b', 't']));
+const Equal$3 = new NodeDescription('math/equal/vec4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var Vec4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$3,
+  Create: Create$1,
+  Elements: Elements$3,
+  Add: Add$2,
+  Subtract: Subtract$2,
+  Negate: Negate$3,
+  Scale: Scale$3,
+  Length: Length$1,
+  Normalize: Normalize$1,
+  Dot: Dot$1,
+  Mix: Mix$2,
+  Equal: Equal$3
+});
+
+/*
+- from Angle Axis
+- from Euler
+- to Angle Axis
+- to Euler
+- Conjugate
+- Multiply
+- Slerp
+- Squad
+- Scale
+- 
+*/
+
+const Constant$2 = new NodeDescription('math/quat', 'Logic', 'Quaternion', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', a => a));
+const Create = new NodeDescription('math/toQuat/float', 'Logic', 'Float to Quat', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'quat', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$2 = new NodeDescription('math/toFloat/quat', 'Logic', 'Quat to Float', (description, graph) => new VecElements(description, graph, 'quat', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Negate$2 = new NodeDescription('math/conjugate/quat', 'Logic', 'Conjugate', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatConjugate));
+const Multiply$2 = new NodeDescription('math/multiply/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'quat', quatMultiply));
+const Scale$2 = new NodeDescription('math/scale/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', vec4MultiplyByScalar));
+const Length = new NodeDescription('math/length/quat', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'float', vec4Length));
+const Normalize = new NodeDescription('math/normalize/quat', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', vec4Normalize));
+const Dot = new NodeDescription('math/dot/quat', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'float', vec4Dot));
+const Ln = new NodeDescription('math/ln/quat', 'Logic', 'Ln', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatLn));
+const Exp = new NodeDescription('math/exp/quat', 'Logic', 'Exp', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatExp));
+const Pow = new NodeDescription('math/pow/quat', 'Logic', 'Pow', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', quatPow));
+const Mat3ToQuat = new NodeDescription('math/toQuat/mat3', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'quat', mat3ToQuat));
+const Mat4ToQuat = new NodeDescription('math/toQuat/mat4', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'quat', mat4ToQuat));
+const EulerToQuat = new NodeDescription('math/toQuat/euler', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'quat', eulerToQuat));
+const AngleAxisToQuat = new NodeDescription('math/toQuat/angleAxis', 'Logic', 'Angle Axis to Quat', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'vec3'], 'quat', angleAxisToQuat));
+const Slerp = new NodeDescription('math/slerp/quat', 'Logic', 'Slerp', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'quat', quatSlerp, ['a', 'b', 't']));
+const Equal$2 = new NodeDescription('math/equal/quat', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var QuatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$2,
+  Create: Create,
+  Elements: Elements$2,
+  Negate: Negate$2,
+  Multiply: Multiply$2,
+  Scale: Scale$2,
+  Length: Length,
+  Normalize: Normalize,
+  Dot: Dot,
+  Ln: Ln,
+  Exp: Exp,
+  Pow: Pow,
+  Mat3ToQuat: Mat3ToQuat,
+  Mat4ToQuat: Mat4ToQuat,
+  EulerToQuat: EulerToQuat,
+  AngleAxisToQuat: AngleAxisToQuat,
+  Slerp: Slerp,
+  Equal: Equal$2
+});
+
+const Constant$1 = new NodeDescription('math/mat3', 'Logic', 'Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', a => a));
+const Column3ToMat3 = new NodeDescription('math/toMat3/column3', 'Logic', 'Columns to Mat3', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat3', column3ToMat3));
+const SetColumn$1 = new NodeDescription('math/setColumn/mat3', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetColumn3));
+const SetRow$1 = new NodeDescription('math/setRow/mat3', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetRow3));
+const Elements$1 = new NodeDescription('math/toVec3/mat3', 'Logic', 'Mat3 To Vec3', (description, graph) => new VecElements(description, graph, 'mat3', ['x', 'y', 'z'], () => {
+  throw new Error('not implemented');
+}));
+const Add$1 = new NodeDescription('math/add/mat3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Add));
+const Subtract$1 = new NodeDescription('math/subtract/mat3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Subtract));
+const Negate$1 = new NodeDescription('math/negate/mat3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Negate));
+const Scale$1 = new NodeDescription('math/scale/mat3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'float'], 'mat3', mat3MultiplyByScalar));
+const Determinant$1 = new NodeDescription('math/determinant/mat3', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'float', mat3Determinant));
+const Inverse$1 = new NodeDescription('math/inverse/mat3', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Inverse));
+const Mat4ToMat3 = new NodeDescription('math/toMat3/mat4', 'Logic', 'Mat4 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat3', mat4ToMat3));
+const Transpose$1 = new NodeDescription('math/transpose/mat3', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Transpose));
+const Multiply$1 = new NodeDescription('math/multiply/mat3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Multiply));
+const Mix$1 = new NodeDescription('math/mix/mat3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'mat3', mat3Mix, ['a', 'b', 't']));
+const Equal$1 = new NodeDescription('math/equal/mat3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'boolean', mat3Equals, ['a', 'b', 'tolerance']));
+const EulerToMat3 = new NodeDescription('math/toMat3/euler', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat3', eulerToMat3));
+const QuatToMat3 = new NodeDescription('math/toMat3/quat', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat3', eulerToMat3));
+const Scale2ToMat3 = new NodeDescription('math/toMat3/scale2', 'Logic', 'Scale2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', scale2ToMat3));
+const Mat3ToScale2 = new NodeDescription('math/toScale2/mat3', 'Logic', 'Mat3 to Scale2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToScale2));
+const Translation2ToMat3 = new NodeDescription('math/toMat3/translation2', 'Logic', 'Translation2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', translation2ToMat3));
+const Mat3ToTranslation3 = new NodeDescription('math/toTranslation2/mat3', 'Logic', 'Mat3 to Translation2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToTranslation2));
+
+var Mat3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$1,
+  Column3ToMat3: Column3ToMat3,
+  SetColumn: SetColumn$1,
+  SetRow: SetRow$1,
+  Elements: Elements$1,
+  Add: Add$1,
+  Subtract: Subtract$1,
+  Negate: Negate$1,
+  Scale: Scale$1,
+  Determinant: Determinant$1,
+  Inverse: Inverse$1,
+  Mat4ToMat3: Mat4ToMat3,
+  Transpose: Transpose$1,
+  Multiply: Multiply$1,
+  Mix: Mix$1,
+  Equal: Equal$1,
+  EulerToMat3: EulerToMat3,
+  QuatToMat3: QuatToMat3,
+  Scale2ToMat3: Scale2ToMat3,
+  Mat3ToScale2: Mat3ToScale2,
+  Translation2ToMat3: Translation2ToMat3,
+  Mat3ToTranslation3: Mat3ToTranslation3
+});
+
+const Mat3Value = new ValueType('mat3', () => new Mat3(), value => typeof value === 'string' ? mat3Parse(value) : new Mat3(value), value => value.elements, (start, end, t) => mat3Mix(start, end, t));
+
+class In5Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e']) {
+    if (inputValueTypes.length !== 5) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 5, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 5) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 5, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In6Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e', 'f']) {
+    if (inputValueTypes.length !== 6) {
+      throw new Error(`inputValueTypes of ${description.typeName} must have a length of 6, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 6) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 6, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4]), new Socket(inputValueTypes[5], inputNames[5])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4]), this.readInput(inputNames[5])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, z, 1 ) x [ 0  4   8  12] = ( x', y', z', 1 )
+//                  [ 1  5   9  13]
+//                  [ 2  6  10  14]
+//                  [ 3  7  11  15]
+// where elements 3, 7, 11 would be translation in 3D, as they would multiplied
+// by the last virtual element of the 3D vector.
+const NUM_ROWS = 4;
+const NUM_COLUMNS = 4;
+const NUM_ELEMENTS = NUM_ROWS * NUM_COLUMNS;
+class Mat4 {
+  constructor(elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat4()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat4SetColumn4(m, columnIndex, column, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(columnIndex) * NUM_ROWS;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  re[base + 3] = column.w;
+  return result;
+}
+function mat4SetRow4(m, rowIndex, row, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(rowIndex);
+  re[base + NUM_COLUMNS * 0] = row.x;
+  re[base + NUM_COLUMNS * 1] = row.y;
+  re[base + NUM_COLUMNS * 2] = row.z;
+  re[base + NUM_COLUMNS * 3] = row.w;
+  return result;
+}
+function column4ToMat4(a, b, c, d, result = new Mat4()) {
+  const re = result.elements;
+  const columns = [a, b, c, d];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+    re[base + 3] = column.w;
+  }
+  return result;
+}
+function mat4Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat4Add(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat4Subtract(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat4MultiplyByScalar(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat4Negate(a, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat4Multiply(a, b, result = new Mat4()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[4],
+    a13 = ae[8],
+    a14 = ae[12];
+  const a21 = ae[1],
+    a22 = ae[5],
+    a23 = ae[9],
+    a24 = ae[13];
+  const a31 = ae[2],
+    a32 = ae[6],
+    a33 = ae[10],
+    a34 = ae[14];
+  const a41 = ae[3],
+    a42 = ae[7],
+    a43 = ae[11],
+    a44 = ae[15];
+  const b11 = be[0],
+    b12 = be[4],
+    b13 = be[8],
+    b14 = be[12];
+  const b21 = be[1],
+    b22 = be[5],
+    b23 = be[9],
+    b24 = be[13];
+  const b31 = be[2],
+    b32 = be[6],
+    b33 = be[10],
+    b34 = be[14];
+  const b41 = be[3],
+    b42 = be[7],
+    b43 = be[11],
+    b44 = be[15];
+
+  // TODO: Replace with set(...)
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
+  te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
+  te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
+  te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
+  te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
+  te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
+  te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
+  te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
+  te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
+  te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
+  te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
+  te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
+  te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
+  te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
+  return result;
+}
+function mat4Determinant(m) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  return n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+}
+function mat4Adjoint(m, result = new Mat4()) {
+  // from gl-matrix
+  const a = m.elements;
+  const out = result.elements;
+  const a00 = a[0],
+    a01 = a[1],
+    a02 = a[2],
+    a03 = a[3];
+  const a10 = a[4],
+    a11 = a[5],
+    a12 = a[6],
+    a13 = a[7];
+  const a20 = a[8],
+    a21 = a[9],
+    a22 = a[10],
+    a23 = a[11];
+  const a30 = a[12],
+    a31 = a[13],
+    a32 = a[14],
+    a33 = a[15];
+  const b00 = a00 * a11 - a01 * a10;
+  const b01 = a00 * a12 - a02 * a10;
+  const b02 = a00 * a13 - a03 * a10;
+  const b03 = a01 * a12 - a02 * a11;
+  const b04 = a01 * a13 - a03 * a11;
+  const b05 = a02 * a13 - a03 * a12;
+  const b06 = a20 * a31 - a21 * a30;
+  const b07 = a20 * a32 - a22 * a30;
+  const b08 = a20 * a33 - a23 * a30;
+  const b09 = a21 * a32 - a22 * a31;
+  const b10 = a21 * a33 - a23 * a31;
+  const b11 = a22 * a33 - a23 * a32;
+  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
+  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
+  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
+  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
+  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
+  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
+  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
+  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
+  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
+  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
+  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
+  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
+  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
+  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
+  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
+  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
+  return result;
+}
+function mat4Transpose(m, result = new Mat4()) {
+  const re = m.clone(result).elements;
+  let tmp;
+
+  // TODO: replace this with just reading from me and setting re, no need for a temporary
+  tmp = re[1];
+  re[1] = re[4];
+  re[4] = tmp;
+  tmp = re[2];
+  re[2] = re[8];
+  re[8] = tmp;
+  tmp = re[6];
+  re[6] = re[9];
+  re[9] = tmp;
+  tmp = re[3];
+  re[3] = re[12];
+  re[12] = tmp;
+  tmp = re[7];
+  re[7] = re[13];
+  re[13] = tmp;
+  tmp = re[11];
+  re[11] = re[14];
+  re[14] = tmp;
+  return result;
+}
+function mat4Inverse(m, result = new Mat4()) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+
+  // TODO: replace with a set
+  const re = result.elements;
+  re[0] = t11 * detInv;
+  re[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
+  re[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
+  re[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
+  re[4] = t12 * detInv;
+  re[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
+  re[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
+  re[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
+  re[8] = t13 * detInv;
+  re[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
+  re[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
+  re[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
+  re[12] = t14 * detInv;
+  re[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
+  re[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
+  re[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
+  return result;
+}
+function mat4Mix(a, b, t, result = new Mat4()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat4FromArray(array, offset = 0, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat4Parse(text, result = new Mat4()) {
+  return mat4FromArray(parseSafeFloats(text), 0, result);
+}
+function mat3ToMat4(a, result = new Mat4()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], 0, ae[3], ae[4], ae[5], 0, ae[6], ae[7], ae[8], 0, 0, 0, 0, 1]);
+}
+function eulerToMat4(e, result = new Mat4()) {
+  return mat3ToMat4(eulerToMat3(e), result);
+}
+function quatToMat4(q, result = new Mat4()) {
+  return mat3ToMat4(quatToMat3(q), result);
+}
+function scale3ToMat4(s, result = new Mat4()) {
+  return result.set([s.x, 0, 0, 0, 0, s.y, 0, 0, 0, 0, s.z, 0, 0, 0, 0, 1]);
+}
+function translation3ToMat4(t, result = new Mat4()) {
+  return result.set([1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1]);
+}
+function mat4Translate(m, t, result = new Mat4()) {
+  return mat4Multiply(m, translation3ToMat4(t), result);
+}
+function mat4Scale(m, s, result = new Mat4()) {
+  return mat4Multiply(m, scale3ToMat4(s), result);
+}
+function mat4RotateByQuat(m, q, result = new Mat4()) {
+  return mat4Multiply(m, quatToMat4(q), result);
+}
+function mat4RotateByEuler(m, e, result = new Mat4()) {
+  return mat4Multiply(m, eulerToMat4(e), result);
+}
+function mat4TransformPoint3(m, v, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
+  result.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
+  result.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
+  result.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
+  return result;
+}
+function mat4TransformNormal3(v, m, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  result.x = e[0] * x + e[4] * y + e[8] * z;
+  result.y = e[1] * x + e[5] * y + e[9] * z;
+  result.z = e[2] * x + e[6] * y + e[10] * z;
+  return vec3Normalize(result, result);
+}
+function mat4Perspective(left, right, top, bottom, near, far, result = new Mat4()) {
+  const x = 2 * near / (right - left);
+  const y = 2 * near / (top - bottom);
+  const a = (right + left) / (right - left);
+  const b = (top + bottom) / (top - bottom);
+  const c = -(far + near) / (far - near);
+  const d = -2 * far * near / (far - near);
+  return result.set([x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0]);
+}
+function mat4PerspectiveFov(verticalFov, near, far, zoom, aspectRatio, result = new Mat4()) {
+  const height = 2 * near * Math.tan(verticalFov * Math.PI / 180) / zoom;
+  const width = height * aspectRatio;
+
+  // NOTE: OpenGL screen coordinates are -bottomt to +top, -left to +right.
+
+  const right = width * 0.5;
+  const left = right - width;
+  const top = height * 0.5;
+  const bottom = top - height;
+  return mat4Perspective(left, right, top, bottom, near, far, result);
+}
+
+// TODO: Replace with a Box3?
+function mat4Orthogonal(left, right, top, bottom, near, far, result = new Mat4()) {
+  const w = 1 / (right - left);
+  const h = 1 / (top - bottom);
+  const p = 1 / (far - near);
+  const x = (right + left) * w;
+  const y = (top + bottom) * h;
+  const z = (far + near) * p;
+  return result.set([2 * w, 0, 0, -x, 0, 2 * h, 0, -y, 0, 0, -2 * p, -z, 0, 0, 0, 1]);
+}
+function mat4OrthogonalSimple(height, center, near, far, zoom, aspectRatio = 1, result = new Mat4()) {
+  height /= zoom;
+  const width = height * aspectRatio;
+  const left = -width * 0.5 + center.x;
+  const right = left + width;
+  const top = -height * 0.5 + center.y;
+  const bottom = top + height;
+  return mat4Orthogonal(left, right, top, bottom, near, far, result);
+}
+function mat4LookAt(eye, target, up, result = new Mat4()) {
+  const te = result.elements;
+  const look = vec3Subtract(eye, target);
+  const lookLength = vec3Length(look);
+  if (lookLength === 0) {
+    look.z = 1;
+  } else {
+    vec3MultiplyByScalar(look, 1 / lookLength, look);
+  }
+  const right = vec3Cross(up, look);
+  const rightLength = vec3Length(right);
+  if (rightLength === 0) {
+    // up and z are parallel
+
+    if (Math.abs(up.z) === 1) {
+      up.x += 0.0001;
+    } else {
+      up.z += 0.0001;
+    }
+    vec3Normalize(up, up);
+    vec3Cross(right, up, right);
+  } else {
+    vec3MultiplyByScalar(right, 1 / rightLength, right);
+  }
+  const up2 = vec3Cross(look, right);
+  te[0] = right.x;
+  te[4] = up2.x;
+  te[8] = look.x;
+  te[1] = right.y;
+  te[5] = up2.y;
+  te[9] = look.y;
+  te[2] = right.z;
+  te[6] = up2.z;
+  te[10] = look.z;
+  return result;
+}
+
+const Constant = new NodeDescription('math/mat4', 'Logic', 'Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', a => a));
+const Column4ToMat4 = new NodeDescription('math/toMat4/column4', 'Logic', 'Columns to Mat4', (description, graph) => new In4Out1FuncNode(description, graph, ['vec4', 'vec4', 'vec4', 'vec4'], 'mat4', column4ToMat4));
+const SetColumn = new NodeDescription('math/setColumn/mat4', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetColumn4));
+const SetRow = new NodeDescription('math/setRow/mat4', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetRow4));
+const Elements = new NodeDescription('math/toVec4/mat4', 'Logic', 'Mat4 To Vec4', (description, graph) => new VecElements(description, graph, 'mat4', ['x', 'y', 'z', 'w'], () => {
+  throw new Error('not implemented');
+}));
+const Add = new NodeDescription('math/add/mat4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Add));
+const Subtract = new NodeDescription('math/subtract/mat4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Subtract));
+const Negate = new NodeDescription('math/negate/mat4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Negate));
+const MultiplyByScalar = new NodeDescription('math/multiplyByScalar/mat4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'float'], 'mat4', mat4MultiplyByScalar));
+const Determinant = new NodeDescription('math/determinant/mat4', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'float', mat4Determinant));
+const Adjoint = new NodeDescription('math/adjoint/mat4', 'Logic', 'Adjoint', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Adjoint));
+const Inverse = new NodeDescription('math/inverse/mat4', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Inverse));
+const Transpose = new NodeDescription('math/transpose/mat4', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Transpose));
+const Mat3ToMat4 = new NodeDescription('math/toMat4/mat3', 'Logic', 'Mat3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat4', mat3ToMat4));
+const Scale3ToMat4 = new NodeDescription('math/toMat4/scale3', 'Logic', 'Scale3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', scale3ToMat4));
+const Translate3ToMat4 = new NodeDescription('math/toMat4/translate3', 'Logic', 'Translate3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', translation3ToMat4));
+const QuatToMat4 = new NodeDescription('math/toMat4/quat', 'Logic', 'Quat To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat4', quatToMat4));
+const EulerToMat4 = new NodeDescription('math/toMat4/euler', 'Logic', 'Euler To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat4', eulerToMat4));
+const Translate = new NodeDescription('math/translate/mat4', 'Logic', 'Translate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Translate));
+const Scale = new NodeDescription('math/scale/mat4', 'Logic', 'Scale', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Scale));
+const RotateByQuat = new NodeDescription('math/rotateByQuat/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'quat'], 'mat4', mat4RotateByQuat));
+const RotateByEuler = new NodeDescription('math/rotateByEuler/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'euler'], 'mat4', mat4RotateByEuler));
+const Multiply = new NodeDescription('math/multiply/mat4', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Multiply));
+const Mix = new NodeDescription('math/mix/mat4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'mat4', mat4Mix, ['a', 'b', 't']));
+const Equal = new NodeDescription('math/equal/mat4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'boolean', mat4Equals, ['a', 'b', 'tolerance']));
+const TransformPoint3 = new NodeDescription('math/transformPoint3/mat4', 'Logic', 'Transform Point3', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformPoint3));
+const TransformNormal3 = new NodeDescription('math/transformNormal3/mat4', 'Logic', 'Transform Normal', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformNormal3));
+const Perspective = new NodeDescription('math/perspective/mat4', 'Logic', 'Perspective', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Perspective, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const PerspectiveFov = new NodeDescription('math/perspectiveFov/mat4', 'Logic', 'Perspective FOV', (description, graph) => new In5Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float'], 'mat4', mat4PerspectiveFov, ['verticalFov', 'near', 'far', 'zoom', 'aspectRatio']));
+const Orthographic = new NodeDescription('math/orthographic/mat4', 'Logic', 'Orthographic', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Orthogonal, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const OrthographicSimple = new NodeDescription('math/orthographicSimple/mat4', 'Logic', 'Orthographic Simple', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'vec2', 'float', 'float', 'float', 'float'], 'mat4', mat4OrthogonalSimple, ['height', 'center', 'near', 'far', 'zoom', 'aspectRatio']));
+const LookAt = new NodeDescription('math/lookAt/mat4', 'Logic', 'Look At', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat4', mat4LookAt, ['eye', 'target', 'up']));
+
+var Mat4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant,
+  Column4ToMat4: Column4ToMat4,
+  SetColumn: SetColumn,
+  SetRow: SetRow,
+  Elements: Elements,
+  Add: Add,
+  Subtract: Subtract,
+  Negate: Negate,
+  MultiplyByScalar: MultiplyByScalar,
+  Determinant: Determinant,
+  Adjoint: Adjoint,
+  Inverse: Inverse,
+  Transpose: Transpose,
+  Mat3ToMat4: Mat3ToMat4,
+  Scale3ToMat4: Scale3ToMat4,
+  Translate3ToMat4: Translate3ToMat4,
+  QuatToMat4: QuatToMat4,
+  EulerToMat4: EulerToMat4,
+  Translate: Translate,
+  Scale: Scale,
+  RotateByQuat: RotateByQuat,
+  RotateByEuler: RotateByEuler,
+  Multiply: Multiply,
+  Mix: Mix,
+  Equal: Equal,
+  TransformPoint3: TransformPoint3,
+  TransformNormal3: TransformNormal3,
+  Perspective: Perspective,
+  PerspectiveFov: PerspectiveFov,
+  Orthographic: Orthographic,
+  OrthographicSimple: OrthographicSimple,
+  LookAt: LookAt
+});
+
+const Mat4Value = new ValueType('mat4', () => new Mat4(), value => typeof value === 'string' ? mat4Parse(value) : new Mat4(value), value => value.elements, (start, end, t) => mat4Mix(start, end, t));
+
+/* eslint-disable max-len */
+function registerSceneProfile(registry, scene = new DummyScene()) {
+  const {
+    values,
+    nodes
+  } = registry;
+
+  // pull in value type nodes
+  values.register(Vec2Value);
+  values.register(Vec3Value);
+  values.register(Vec4Value);
+  values.register(ColorValue);
+  values.register(EulerValue);
+  values.register(QuatValue);
+  values.register(Mat3Value);
+  values.register(Mat4Value);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(Vec2Nodes));
+  nodes.register(...getNodeDescriptions(Vec3Nodes));
+  nodes.register(...getNodeDescriptions(Vec4Nodes));
+  nodes.register(...getNodeDescriptions(ColorNodes));
+  nodes.register(...getNodeDescriptions(EulerNodes));
+  nodes.register(...getNodeDescriptions(QuatNodes));
+  nodes.register(...getNodeDescriptions(Mat3Nodes));
+  nodes.register(...getNodeDescriptions(Mat4Nodes));
+
+  // events
+
+  nodes.register(OnSceneNodeClick.Description);
+
+  // actions
+  const allValueTypeNames = values.getAllNames();
+  nodes.register(...SetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  nodes.register(...GetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  const newValueTypeNames = ['vec2', 'vec3', 'vec4', 'quat', 'euler', 'color', 'mat3', 'mat4'];
+
+  // variables
+
+  newValueTypeNames.forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+exports.Assert = Assert;
+exports.AsyncNode = AsyncNode;
+exports.AsyncNode2 = AsyncNode2;
+exports.BooleanNodes = BooleanNodes;
+exports.BooleanValue = BooleanValue;
+exports.Branch = Branch;
+exports.ColorNodes = ColorNodes;
+exports.ColorValue = ColorValue;
+exports.Counter = Counter;
+exports.CustomEvent = CustomEvent;
+exports.Debounce = Debounce;
+exports.DefaultLogger = DefaultLogger;
+exports.Delay = Delay;
+exports.DoN = DoN;
+exports.DoOnce = DoOnce;
+exports.DummyScene = DummyScene;
+exports.Engine = Engine;
+exports.EulerNodes = EulerNodes;
+exports.EulerValue = EulerValue;
+exports.EventEmitter = EventEmitter;
+exports.EventNode = EventNode;
+exports.EventNode2 = EventNode2;
+exports.ExpectTrue = ExpectTrue;
+exports.Fiber = Fiber;
+exports.FlipFlop = FlipFlop;
+exports.FloatNodes = FloatNodes;
+exports.FloatValue = FloatValue;
+exports.FlowNode = FlowNode;
+exports.FlowNode2 = FlowNode2;
+exports.ForLoop = ForLoop;
+exports.Gate = Gate;
+exports.GetSceneProperty = GetSceneProperty;
+exports.Graph = Graph;
+exports.ImmediateNode = ImmediateNode;
+exports.ImmediateNode2 = ImmediateNode2;
+exports.In0Out1FuncNode = In0Out1FuncNode;
+exports.In1Out1FuncNode = In1Out1FuncNode;
+exports.In2Out1FuncNode = In2Out1FuncNode;
+exports.In3Out1FuncNode = In3Out1FuncNode;
+exports.In4Out1FuncNode = In4Out1FuncNode;
+exports.IntegerNodes = IntegerNodes;
+exports.IntegerValue = IntegerValue;
+exports.LifecycleOnEnd = LifecycleOnEnd;
+exports.LifecycleOnStart = LifecycleOnStart;
+exports.LifecycleOnTick = LifecycleOnTick;
+exports.Link = Link;
+exports.Log = Log;
+exports.Logger = Logger;
+exports.ManualLifecycleEventEmitter = ManualLifecycleEventEmitter;
+exports.MultiGate = MultiGate;
+exports.Node = Node;
+exports.NodeDescription = NodeDescription;
+exports.NodeDescription2 = NodeDescription2;
+exports.NodeTypeRegistry = NodeTypeRegistry;
+exports.OnCustomEvent = OnCustomEvent;
+exports.OnSceneNodeClick = OnSceneNodeClick;
+exports.QuatNodes = QuatNodes;
+exports.QuatValue = QuatValue;
+exports.Registry = Registry;
+exports.Sequence = Sequence;
+exports.SetSceneProperty = SetSceneProperty;
+exports.Socket = Socket;
+exports.StringNodes = StringNodes;
+exports.StringValue = StringValue;
+exports.Throttle = Throttle;
+exports.TriggerCustomEvent = TriggerCustomEvent;
+exports.ValueType = ValueType;
+exports.ValueTypeRegistry = ValueTypeRegistry;
+exports.Variable = Variable;
+exports.VariableGet = VariableGet;
+exports.VariableSet = VariableSet;
+exports.Vec2 = Vec2;
+exports.Vec2Nodes = Vec2Nodes;
+exports.Vec2Value = Vec2Value;
+exports.Vec3 = Vec3;
+exports.Vec3Nodes = Vec3Nodes;
+exports.Vec3Value = Vec3Value;
+exports.Vec4 = Vec4;
+exports.Vec4Nodes = Vec4Nodes;
+exports.Vec4Value = Vec4Value;
+exports.VecElements = VecElements;
+exports.WaitAll = WaitAll;
+exports.angleAxisToQuat = angleAxisToQuat;
+exports.eulerToQuat = eulerToQuat;
+exports.getNodeDescriptions = getNodeDescriptions;
+exports.hexToRGB = hexToRGB;
+exports.hslToRGB = hslToRGB;
+exports.mat3ToEuler = mat3ToEuler;
+exports.mat3ToQuat = mat3ToQuat;
+exports.mat4ToEuler = mat4ToEuler;
+exports.mat4ToQuat = mat4ToQuat;
+exports.parseSafeFloat = parseSafeFloat;
+exports.parseSafeFloats = parseSafeFloats;
+exports.quatConjugate = quatConjugate;
+exports.quatExp = quatExp;
+exports.quatLn = quatLn;
+exports.quatMultiply = quatMultiply;
+exports.quatPow = quatPow;
+exports.quatSlerp = quatSlerp;
+exports.quatToAngleAxis = quatToAngleAxis;
+exports.quatToEuler = quatToEuler;
+exports.readGraphFromJSON = readGraphFromJSON;
+exports.registerCoreProfile = registerCoreProfile;
+exports.registerSceneProfile = registerSceneProfile;
+exports.rgbToHSL = rgbToHSL;
+exports.rgbToHex = rgbToHex;
+exports.toSafeString = toSafeString;
+exports.validateGraph = validateGraph;
+exports.validateGraphAcyclic = validateGraphAcyclic;
+exports.validateGraphLinks = validateGraphLinks;
+exports.validateNodeRegistry = validateNodeRegistry;
+exports.validateRegistry = validateRegistry;
+exports.validateValueRegistry = validateValueRegistry;
+exports.vec2Add = vec2Add;
+exports.vec2Dot = vec2Dot;
+exports.vec2Equals = vec2Equals;
+exports.vec2FromArray = vec2FromArray;
+exports.vec2Length = vec2Length;
+exports.vec2Mix = vec2Mix;
+exports.vec2MultiplyByScalar = vec2MultiplyByScalar;
+exports.vec2Negate = vec2Negate;
+exports.vec2Normalize = vec2Normalize;
+exports.vec2Parse = vec2Parse;
+exports.vec2Subtract = vec2Subtract;
+exports.vec2ToArray = vec2ToArray;
+exports.vec2ToString = vec2ToString;
+exports.vec3Add = vec3Add;
+exports.vec3Cross = vec3Cross;
+exports.vec3Dot = vec3Dot;
+exports.vec3Equals = vec3Equals;
+exports.vec3FromArray = vec3FromArray;
+exports.vec3Length = vec3Length;
+exports.vec3Mix = vec3Mix;
+exports.vec3MultiplyByScalar = vec3MultiplyByScalar;
+exports.vec3Negate = vec3Negate;
+exports.vec3Normalize = vec3Normalize;
+exports.vec3Parse = vec3Parse;
+exports.vec3Subtract = vec3Subtract;
+exports.vec3ToArray = vec3ToArray;
+exports.vec3ToString = vec3ToString;
+exports.vec4Add = vec4Add;
+exports.vec4Dot = vec4Dot;
+exports.vec4Equals = vec4Equals;
+exports.vec4FromArray = vec4FromArray;
+exports.vec4Length = vec4Length;
+exports.vec4Mix = vec4Mix;
+exports.vec4MultiplyByScalar = vec4MultiplyByScalar;
+exports.vec4Negate = vec4Negate;
+exports.vec4Normalize = vec4Normalize;
+exports.vec4Parse = vec4Parse;
+exports.vec4Subtract = vec4Subtract;
+exports.vec4ToArray = vec4ToArray;
+exports.vec4ToString = vec4ToString;
+exports.writeGraphToJSON = writeGraphToJSON;
+exports.writeNodeSpecsToJSON = writeNodeSpecsToJSON;
diff --git a/node_modules/@behave-graph/core/dist/behave-graph-core.esm.js b/node_modules/@behave-graph/core/dist/behave-graph-core.esm.js
new file mode 100644
index 0000000..bc17e8b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/behave-graph-core.esm.js
@@ -0,0 +1,4013 @@
+function _toPrimitive(input, hint) {
+  if (typeof input !== "object" || input === null) return input;
+  var prim = input[Symbol.toPrimitive];
+  if (prim !== undefined) {
+    var res = prim.call(input, hint || "default");
+    if (typeof res !== "object") return res;
+    throw new TypeError("@@toPrimitive must return a primitive value.");
+  }
+  return (hint === "string" ? String : Number)(input);
+}
+
+function _toPropertyKey(arg) {
+  var key = _toPrimitive(arg, "string");
+  return typeof key === "symbol" ? key : String(key);
+}
+
+function _defineProperty(obj, key, value) {
+  key = _toPropertyKey(key);
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+  return obj;
+}
+
+class EventEmitter {
+  constructor() {
+    _defineProperty(this, "listeners", []);
+  }
+  addListener(listener) {
+    this.listeners.push(listener);
+  }
+  removeListener(listener) {
+    this.listeners.splice(this.listeners.indexOf(listener), 1);
+  }
+  clear() {
+    this.listeners.splice(0, this.listeners.length);
+  }
+  emit(event) {
+    if (this.listeners.length === 0) return;
+    // copy array before emitting event to ensure even if listener array is modified, everyone listening initially gets the event.
+    // inspired by mrdoob's EventDispatcher
+    this.listeners.slice(0).forEach(listener => {
+      listener(event);
+    });
+  }
+  get listenerCount() {
+    return this.listeners.length;
+  }
+}
+
+var _class$o;
+class Logger {
+  static verbose(text) {
+    this.onVerbose.emit(text);
+  }
+  static info(text) {
+    this.onInfo.emit(text);
+  }
+  static warn(text) {
+    this.onWarn.emit(text);
+  }
+  static error(text) {
+    this.onError.emit(text);
+  }
+}
+_class$o = Logger;
+_defineProperty(Logger, "onVerbose", new EventEmitter());
+_defineProperty(Logger, "onInfo", new EventEmitter());
+_defineProperty(Logger, "onWarn", new EventEmitter());
+_defineProperty(Logger, "onError", new EventEmitter());
+(() => {
+  const prefix = () => {
+    return new Date().toLocaleTimeString().padStart(11, '0');
+  };
+  _class$o.onVerbose.addListener(text => {
+    console.log(prefix() + ` VERB:  ${text}`);
+  });
+  _class$o.onInfo.addListener(text => {
+    console.log(prefix() + ` INFO:  ${text}`);
+  });
+  _class$o.onWarn.addListener(text => {
+    console.warn(prefix() + ` WARN:  ${text}`);
+  });
+  _class$o.onError.addListener(text => {
+    console.error(prefix() + ` ERR:  ${text}`);
+  });
+})();
+
+class Assert {
+  static mustBeTrue(condition, msg = '') {
+    if (!condition) {
+      throw new Error(`failed assertion: ${msg}`);
+    }
+  }
+  static mustBeDefined(variable, msg = '') {
+    if (variable === undefined) {
+      throw new Error(`failed assertion: variable must be defined ${msg}`);
+    }
+  }
+}
+
+/* eslint-disable no-mixed-operators */
+/* eslint-disable no-bitwise */
+
+// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
+const lut = [];
+for (let i = 0; i < 256; i++) {
+  lut[i] = (i < 16 ? '0' : '') + i.toString(16);
+}
+function generateUuid() {
+  const d0 = Math.random() * 0xffffffff | 0;
+  const d1 = Math.random() * 0xffffffff | 0;
+  const d2 = Math.random() * 0xffffffff | 0;
+  const d3 = Math.random() * 0xffffffff | 0;
+  const uuid = `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;
+
+  // .toUpperCase() here flattens concatenated strings to save heap memory space.
+  return uuid.toUpperCase();
+}
+
+// Purpose:
+//  - stores the node graph
+class Graph {
+  constructor(registry) {
+    _defineProperty(this, "name", '');
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "nodes", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "variables", {});
+    // TODO: think about whether I can replace this with an immutable strategy?  Rather than having this mutable?
+    _defineProperty(this, "customEvents", {});
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    this.registry = registry;
+  }
+  createNode(nodeTypeName, nodeId = generateUuid(), nodeConfiguration = {}) {
+    if (nodeId in this.nodes) {
+      throw new Error(`can not create new node of type ${nodeTypeName} with id ${nodeId} as one with that id already exists.`);
+    }
+    let nodeDescription = undefined;
+    if (this.registry.nodes.contains(nodeTypeName)) {
+      nodeDescription = this.registry.nodes.get(nodeTypeName);
+    }
+    if (nodeDescription === undefined) {
+      throw new Error(`no registered node descriptions with the typeName ${nodeTypeName}`);
+    }
+    const node = nodeDescription.factory(nodeDescription, this, nodeConfiguration);
+    node.id = nodeId;
+    this.nodes[nodeId] = node;
+    node.inputs.forEach(socket => {
+      if (socket.valueTypeName !== 'flow' && socket.value === undefined) {
+        socket.value = this.registry.values.get(socket.valueTypeName).creator();
+      }
+    });
+    return node;
+  }
+}
+
+class Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    _defineProperty(this, "id", '');
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    this.description = description;
+    this.graph = graph;
+    this.inputs = inputs;
+    this.outputs = outputs;
+    this.configuration = configuration;
+  }
+
+  // TODO: this may want to cache the values on the creation of the NodeEvalContext
+  // for re-entrant async operations, otherwise the inputs may change during operation.
+  readInput(inputName) {
+    const inputSocket = this.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`can not find input socket with name ${inputName} on node of type ${this.description.typeName}`);
+    }
+    return inputSocket.value;
+  }
+  writeOutput(outputName, value) {
+    const outputSocket = this.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find output socket with name ${outputSocket} on node of type ${this.description.typeName}`);
+    }
+    if (outputSocket.valueTypeName === 'flow') {
+      throw new Error(`can not set the value of Flow output socket ${outputName}, use commit() instead`);
+    }
+    outputSocket.value = value;
+  }
+}
+
+// async flow node with only a single flow input
+class AsyncNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(engine, triggeringSocketName, finished) {
+    throw new Error('not implemented');
+  }
+  dispose() {
+    throw new Error('not implemented');
+  }
+}
+class AsyncNode2 extends AsyncNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs);
+  }
+}
+
+// no flow inputs, always evaluated on startup
+class EventNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+    // no input flow sockets allowed.
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have at least one output flow socket
+    Assert.mustBeTrue(this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  init(engine) {
+    throw new Error('not implemented');
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  dispose(engine) {
+    throw new Error('not implemented');
+  }
+}
+class EventNode2 extends EventNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class FlowNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], configuration = {}) {
+    // determine if this is an eval node
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have at least one input flow socket
+    Assert.mustBeTrue(this.inputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+
+  // eslint-disable-next-line unused-imports/no-unused-vars, @typescript-eslint/no-unused-vars
+  triggered(fiber, triggeringSocketName) {
+    throw new Error('not implemented');
+  }
+}
+class FlowNode2 extends FlowNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.configuration);
+  }
+}
+
+class ImmediateNode extends Node {
+  constructor(description, graph, inputs = [], outputs = [], exec, configuration = {}) {
+    super(description, graph, inputs, outputs, configuration);
+
+    // must have no input flow sockets
+    this.exec = exec;
+    Assert.mustBeTrue(!this.inputs.some(socket => socket.valueTypeName === 'flow'));
+
+    // must have no output flow sockets
+    Assert.mustBeTrue(!this.outputs.some(socket => socket.valueTypeName === 'flow'));
+  }
+}
+class ImmediateNode2 extends ImmediateNode {
+  constructor(props) {
+    super(props.description, props.graph, props.inputs, props.outputs, props.exec);
+  }
+}
+
+class Link {
+  constructor(nodeId = '', socketName = '') {
+    _defineProperty(this, "_targetNode", undefined);
+    _defineProperty(this, "_targetSocket", undefined);
+    this.nodeId = nodeId;
+    this.socketName = socketName;
+  }
+}
+
+class ValueType {
+  constructor(name, creator, deserialize, serialize, lerp) {
+    this.name = name;
+    this.creator = creator;
+    this.deserialize = deserialize;
+    this.serialize = serialize;
+    this.lerp = lerp;
+  }
+}
+
+class Socket {
+  constructor(valueTypeName, name, value = undefined, label = undefined, valueChoices = [] // if not empty, value must be one of these.
+  ) {
+    _defineProperty(this, "links", []);
+    this.valueTypeName = valueTypeName;
+    this.name = name;
+    this.value = value;
+    this.label = label;
+    this.valueChoices = valueChoices;
+  }
+}
+
+class CustomEvent {
+  constructor(id, name, parameters = []) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "eventEmitter", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.parameters = parameters;
+  }
+}
+
+class Variable {
+  constructor(id, name, valueTypeName, initialValue // this is assumed to be properly deseriealized from a string.
+  ) {
+    _defineProperty(this, "label", '');
+    _defineProperty(this, "metadata", {});
+    _defineProperty(this, "version", 0);
+    // this is updated on each change to the variable state.
+    _defineProperty(this, "onChanged", new EventEmitter());
+    this.id = id;
+    this.name = name;
+    this.valueTypeName = valueTypeName;
+    this.initialValue = initialValue;
+    this.value = this.initialValue;
+  }
+  get() {
+    return this.value;
+  }
+  set(newValue) {
+    if (newValue !== this.value) {
+      this.value = newValue;
+      this.version++;
+      this.onChanged.emit(this);
+    }
+  }
+}
+
+const inputSocketName = {
+  a: 'a',
+  b: 'b',
+  c: 'c',
+  d: 'd'
+};
+const resultNodeName = 'result';
+
+class In4Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c, inputSocketName.d]) {
+    if (inputValueTypes.length !== 4) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 4, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 4) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 4, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In3Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b, inputSocketName.c]) {
+    if (inputValueTypes.length !== 3) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 3, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 3) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 3, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In2Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a, inputSocketName.b]) {
+    if (inputValueTypes.length !== 2) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 2, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 2) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 2, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In1Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = [inputSocketName.a]) {
+    if (inputValueTypes.length !== 1) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 1, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 1) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 1, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0])], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc(this.readInput(inputNames[0])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In0Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, outputValueType, evalFunc) {
+    super(description, graph, [], [new Socket(outputValueType, resultNodeName)], () => {
+      this.writeOutput(resultNodeName, this.evalFunc());
+    });
+    this.evalFunc = evalFunc;
+  }
+}
+
+/* eslint-disable no-promise-executor-return */
+function sleep(durationInSeconds) {
+  return new Promise(resolve => setTimeout(resolve, Math.round(durationInSeconds * 1000)));
+}
+
+function resolveSocketValue(engine, inputSocket) {
+  // if it has no links, leave value on input socket alone.
+  if (inputSocket.links.length === 0) {
+    return 0;
+  }
+  const graph = engine.graph;
+  const upstreamLink = inputSocket.links[0];
+  // caching the target node + socket here increases engine performance by 8% on average.  This is a hotspot.
+  if (upstreamLink._targetNode === undefined || upstreamLink._targetSocket === undefined) {
+    Assert.mustBeTrue(inputSocket.links.length === 1);
+
+    // if upstream node is an eval, we just return its last value.
+    upstreamLink._targetNode = graph.nodes[upstreamLink.nodeId];
+    // what is inputSocket connected to?
+    upstreamLink._targetSocket = upstreamLink._targetNode.outputs.find(socket => socket.name === upstreamLink.socketName);
+    if (upstreamLink._targetSocket === undefined) {
+      throw new Error(`can not find socket with the name ${upstreamLink.socketName}`);
+    }
+  }
+  const upstreamNode = upstreamLink._targetNode;
+  const upstreamOutputSocket = upstreamLink._targetSocket;
+
+  // if upstream is a flow/event/async node, do not evaluate it rather just use its existing output socket values
+  if (!(upstreamNode instanceof ImmediateNode)) {
+    inputSocket.value = upstreamOutputSocket.value;
+    return 0;
+  }
+  let executionSteps = 0;
+  if (upstreamNode instanceof ImmediateNode) {
+    // resolve all inputs for the upstream node (this is where the recursion happens)
+    // TODO: This is a bit dangerous as if there are loops in the graph, this will blow up the stack
+    for (const upstreamInputSocket of upstreamNode.inputs) {
+      executionSteps += resolveSocketValue(engine, upstreamInputSocket);
+    }
+    engine.onNodeExecutionStart.emit(upstreamNode);
+    upstreamNode.exec();
+    executionSteps++;
+    engine.onNodeExecutionEnd.emit(upstreamNode);
+
+    // get the output value we wanted.
+    inputSocket.value = upstreamOutputSocket.value;
+    return executionSteps;
+  }
+  return 0;
+}
+
+class Fiber {
+  constructor(engine, nextEval, fiberCompletedListener = undefined) {
+    _defineProperty(this, "fiberCompletedListenerStack", []);
+    _defineProperty(this, "executionSteps", 0);
+    this.engine = engine;
+    this.nextEval = nextEval;
+    this.graph = engine.graph;
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // this is syncCommit.
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars, no-unused-vars
+  commit(node, outputSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof FlowNode);
+    Assert.mustBeTrue(this.nextEval === null);
+    const outputSocket = node.outputs.find(socket => socket.name === outputSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`can not find socket with the name ${outputSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const link = outputSocket.links[0];
+      if (link === undefined) {
+        throw new Error('link must be defined');
+      }
+      this.nextEval = link;
+    }
+    if (fiberCompletedListener !== undefined) {
+      this.fiberCompletedListenerStack.push(fiberCompletedListener);
+    }
+  }
+
+  // returns the number of new execution steps created as a result of this one step
+  executeStep() {
+    // pop the next node off the queue
+    const link = this.nextEval;
+    this.nextEval = null;
+
+    // nothing waiting, thus go back and start to evaluate any callbacks, in stack order.
+    if (link === null) {
+      if (this.fiberCompletedListenerStack.length === 0) {
+        return;
+      }
+      const awaitingCallback = this.fiberCompletedListenerStack.pop();
+      if (awaitingCallback === undefined) {
+        throw new Error('awaitingCallback is empty');
+      }
+      awaitingCallback();
+      return;
+    }
+    const node = this.graph.nodes[link.nodeId];
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName !== 'flow') {
+        this.executionSteps += resolveSocketValue(this.engine, inputSocket);
+      }
+    });
+
+    // first resolve all input values
+    // flow socket is set to true for the one flowing in, while all others are set to false.
+    this.engine.onNodeExecutionStart.emit(node);
+    if (node instanceof AsyncNode) {
+      this.engine.asyncNodes.push(node);
+      node.triggered(this.engine, link.socketName, () => {
+        // remove from the list of pending async nodes
+        const index = this.engine.asyncNodes.indexOf(node);
+        this.engine.asyncNodes.splice(index, 1);
+        this.engine.onNodeExecutionEnd.emit(node);
+        this.executionSteps++;
+      });
+      return;
+    }
+    if (node instanceof FlowNode) {
+      node.triggered(this, link.socketName);
+      this.engine.onNodeExecutionEnd.emit(node);
+      this.executionSteps++;
+      return;
+    }
+    throw new TypeError(`should not get here, unhandled node ${node.description.typeName}`);
+  }
+  isCompleted() {
+    return this.fiberCompletedListenerStack.length === 0 && this.nextEval === null;
+  }
+}
+
+class Engine {
+  constructor(graph) {
+    // tracking the next node+input socket to execute.
+    _defineProperty(this, "fiberQueue", []);
+    _defineProperty(this, "asyncNodes", []);
+    _defineProperty(this, "eventNodes", []);
+    _defineProperty(this, "onNodeExecutionStart", new EventEmitter());
+    _defineProperty(this, "onNodeExecutionEnd", new EventEmitter());
+    _defineProperty(this, "executionSteps", 0);
+    this.graph = graph;
+    // collect all event nodes
+    Object.values(graph.nodes).forEach(node => {
+      if (node instanceof EventNode) {
+        this.eventNodes.push(node);
+      }
+    });
+    // init all event nodes at startup
+    this.eventNodes.forEach(eventNode => {
+      // evaluate input parameters
+      eventNode.inputs.forEach(inputSocket => {
+        Assert.mustBeTrue(inputSocket.valueTypeName !== 'flow');
+        this.executionSteps += resolveSocketValue(this, inputSocket);
+      });
+      this.onNodeExecutionStart.emit(eventNode);
+      eventNode.init(this);
+      this.executionSteps++;
+      this.onNodeExecutionEnd.emit(eventNode);
+    });
+  }
+  dispose() {
+    // dispose all, possibly in-progress, async nodes
+    this.asyncNodes.forEach(asyncNode => asyncNode.dispose());
+
+    // dispose all event nodes
+    this.eventNodes.forEach(eventNode => eventNode.dispose(this));
+  }
+
+  // asyncCommit
+  commitToNewFiber(node, outputFlowSocketName, fiberCompletedListener = undefined) {
+    Assert.mustBeTrue(node instanceof EventNode || node instanceof AsyncNode);
+    const outputSocket = node.outputs.find(socket => socket.name === outputFlowSocketName);
+    if (outputSocket === undefined) {
+      throw new Error(`no socket with the name ${outputFlowSocketName}`);
+    }
+    if (outputSocket.links.length > 1) {
+      throw new Error('invalid for an output flow socket to have multiple downstream links:' + `${node.description.typeName}.${outputSocket.name} has ${outputSocket.links.length} downlinks`);
+    }
+    if (outputSocket.links.length === 1) {
+      const fiber = new Fiber(this, outputSocket.links[0], fiberCompletedListener);
+      this.fiberQueue.push(fiber);
+    }
+  }
+
+  // NOTE: This does not execute all if there are promises.
+  executeAllSync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSeconds = 0;
+    let elapsedSteps = 0;
+    while (elapsedSteps < limitInSteps && elapsedSeconds < limitInSeconds && this.fiberQueue.length > 0) {
+      const currentFiber = this.fiberQueue[0];
+      const startingFiberExecutionSteps = currentFiber.executionSteps;
+      currentFiber.executeStep();
+      elapsedSteps += currentFiber.executionSteps - startingFiberExecutionSteps;
+      if (currentFiber.isCompleted()) {
+        // remove first element
+        this.fiberQueue.shift();
+      }
+      elapsedSeconds = (Date.now() - startDateTime) * 0.001;
+    }
+    this.executionSteps += elapsedSteps;
+    return elapsedSteps;
+  }
+  async executeAllAsync(limitInSeconds = 100, limitInSteps = 100000000) {
+    const startDateTime = Date.now();
+    let elapsedSteps = 0;
+    let elapsedTime = 0;
+    let iterations = 0;
+    do {
+      if (iterations > 0) {
+        // eslint-disable-next-line no-await-in-loop
+        await sleep(0);
+      }
+      elapsedSteps += this.executeAllSync(limitInSeconds - elapsedTime, limitInSteps - elapsedSteps);
+      elapsedTime = (Date.now() - startDateTime) * 0.001;
+      iterations += 1;
+    } while ((this.asyncNodes.length > 0 || this.fiberQueue.length > 0) && elapsedTime < limitInSeconds && elapsedSteps < limitInSteps);
+    return elapsedSteps;
+  }
+}
+
+// Purpose:
+//  - loads a node graph
+function readGraphFromJSON(graphJson, registry) {
+  var _graphJson$name, _graphJson$metadata, _graphJson$nodes;
+  const graph = new Graph(registry);
+  graph.name = (_graphJson$name = graphJson === null || graphJson === void 0 ? void 0 : graphJson.name) !== null && _graphJson$name !== void 0 ? _graphJson$name : graph.name;
+  graph.metadata = (_graphJson$metadata = graphJson === null || graphJson === void 0 ? void 0 : graphJson.metadata) !== null && _graphJson$metadata !== void 0 ? _graphJson$metadata : graph.metadata;
+  if ('variables' in graphJson) {
+    var _graphJson$variables;
+    readVariablesJSON(graph, (_graphJson$variables = graphJson.variables) !== null && _graphJson$variables !== void 0 ? _graphJson$variables : []);
+  }
+  if ('customEvents' in graphJson) {
+    var _graphJson$customEven;
+    readCustomEventsJSON(graph, (_graphJson$customEven = graphJson.customEvents) !== null && _graphJson$customEven !== void 0 ? _graphJson$customEven : []);
+  }
+  const nodesJson = (_graphJson$nodes = graphJson === null || graphJson === void 0 ? void 0 : graphJson.nodes) !== null && _graphJson$nodes !== void 0 ? _graphJson$nodes : [];
+  if (nodesJson.length === 0) {
+    Logger.warn('readGraphFromJSON: no nodes specified');
+  }
+
+  // create new BehaviorNode instances for each node in the json.
+  for (let i = 0; i < nodesJson.length; i += 1) {
+    const nodeJson = nodesJson[i];
+    readNodeJSON(graph, nodeJson);
+  }
+
+  // connect up the graph edges from BehaviorNode inputs to outputs.  This is required to follow execution
+  Object.values(graph.nodes).forEach(node => {
+    // initialize the inputs by resolving to the reference nodes.
+    node.inputs.forEach(inputSocket => {
+      inputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent upstream node id: ${link.nodeId}`);
+        }
+        const upstreamNode = graph.nodes[link.nodeId];
+        const upstreamOutputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (upstreamOutputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an input '${inputSocket.name}' whose link goes to ` + `a nonexistent output '${link.socketName}' on upstream node '${upstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const upstreamLink = new Link(node.id, inputSocket.name);
+        if (upstreamOutputSocket.links.findIndex(value => value.nodeId == upstreamLink.nodeId && value.socketName == upstreamLink.socketName) < 0) {
+          upstreamOutputSocket.links.push(upstreamLink);
+        }
+      });
+    });
+    node.outputs.forEach(outputSocket => {
+      outputSocket.links.forEach(link => {
+        if (!(link.nodeId in graph.nodes)) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent downstream node id ${link.nodeId}`);
+        }
+        const downstreamNode = graph.nodes[link.nodeId];
+        const downstreamInputSocket = downstreamNode.inputs.find(socket => socket.name === link.socketName);
+        if (downstreamInputSocket === undefined) {
+          throw new Error(`node '${node.description.typeName}' specifies an output '${outputSocket.name}' whose link goes to ` + `a nonexistent input '${link.socketName}' on downstream node '${downstreamNode.description.typeName}'`);
+        }
+
+        // add, only if unique
+        const downstreamLink = new Link(node.id, outputSocket.name);
+        if (downstreamInputSocket.links.findIndex(value => value.nodeId == downstreamLink.nodeId && value.socketName == downstreamLink.socketName) < 0) {
+          downstreamInputSocket.links.push(downstreamLink);
+        }
+      });
+    });
+  });
+  return graph;
+}
+function readNodeJSON(graph, nodeJson) {
+  var _nodeJson$label, _nodeJson$metadata;
+  if (nodeJson.type === undefined) {
+    throw new Error('readGraphFromJSON: no type for node');
+  }
+  const nodeName = nodeJson.type;
+  const nodeConfigurationJson = nodeJson.configuration;
+  const nodeConfiguration = {};
+  if (nodeConfigurationJson !== undefined) {
+    Object.keys(nodeConfigurationJson).forEach(key => {
+      nodeConfiguration[key] = nodeConfigurationJson[key];
+    });
+  }
+  const node = graph.createNode(nodeName, nodeJson.id, nodeConfiguration);
+  node.label = (_nodeJson$label = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.label) !== null && _nodeJson$label !== void 0 ? _nodeJson$label : node.label;
+  node.metadata = (_nodeJson$metadata = nodeJson === null || nodeJson === void 0 ? void 0 : nodeJson.metadata) !== null && _nodeJson$metadata !== void 0 ? _nodeJson$metadata : node.metadata;
+  if (nodeJson.parameters !== undefined) {
+    readNodeParameterJSON(graph, node, nodeJson.parameters);
+  }
+  if (nodeJson.flows !== undefined) {
+    readNodeFlowsJSON(graph, node, nodeJson.flows);
+  }
+}
+function readNodeParameterJSON(graph, node, parametersJson) {
+  node.inputs.forEach(socket => {
+    if (!(socket.name in parametersJson)) {
+      return;
+    }
+    const inputJson = parametersJson[socket.name];
+    if ('value' in inputJson) {
+      // eslint-disable-next-line no-param-reassign
+      socket.value = graph.registry.values.get(socket.valueTypeName).deserialize(inputJson.value);
+    }
+    if ('link' in inputJson) {
+      const linkJson = inputJson.link;
+      socket.links.push(new Link(linkJson.nodeId, linkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const inputName in parametersJson) {
+    const inputSocket = node.inputs.find(socket => socket.name === inputName);
+    if (inputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an input '${inputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readNodeFlowsJSON(graph, node, flowsJson) {
+  node.outputs.forEach(socket => {
+    if (socket.name in flowsJson) {
+      const outputLinkJson = flowsJson[socket.name];
+      socket.links.push(new Link(outputLinkJson.nodeId, outputLinkJson.socket));
+    }
+  });
+
+  // validate that there are no additional input sockets specified that were not read.
+  for (const outputName in flowsJson) {
+    const outputSocket = node.outputs.find(socket => socket.name === outputName);
+    if (outputSocket === undefined) {
+      throw new Error(`node '${node.description.typeName}' specifies an output '${outputName}' that doesn't exist on its node type`);
+    }
+  }
+}
+function readVariablesJSON(graph, variablesJson) {
+  for (let i = 0; i < variablesJson.length; i += 1) {
+    var _variableJson$label, _variableJson$metadat;
+    const variableJson = variablesJson[i];
+    const variable = new Variable(variableJson.id, variableJson.name, variableJson.valueTypeName, graph.registry.values.get(variableJson.valueTypeName).deserialize(variableJson.initialValue));
+    variable.label = (_variableJson$label = variableJson === null || variableJson === void 0 ? void 0 : variableJson.label) !== null && _variableJson$label !== void 0 ? _variableJson$label : variable.label;
+    variable.metadata = (_variableJson$metadat = variableJson === null || variableJson === void 0 ? void 0 : variableJson.metadata) !== null && _variableJson$metadat !== void 0 ? _variableJson$metadat : variable.metadata;
+    if (variableJson.id in graph.variables) {
+      throw new Error(`duplicate variable id ${variable.id}`);
+    }
+    graph.variables[variableJson.id] = variable;
+  }
+}
+function readCustomEventsJSON(graph, customEventsJson) {
+  for (let i = 0; i < customEventsJson.length; i += 1) {
+    var _customEventJson$para, _customEventJson$labe, _customEventJson$meta;
+    const customEventJson = customEventsJson[i];
+    const parameters = [];
+    ((_customEventJson$para = customEventJson.parameters) !== null && _customEventJson$para !== void 0 ? _customEventJson$para : []).forEach(parameterJson => {
+      parameters.push(new Socket(parameterJson.valueTypeName, parameterJson.name, graph.registry.values.get(parameterJson.valueTypeName).deserialize(parameterJson.defaultValue)));
+    });
+    const customEvent = new CustomEvent(customEventJson.id, customEventJson.name, parameters);
+    customEvent.label = (_customEventJson$labe = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.label) !== null && _customEventJson$labe !== void 0 ? _customEventJson$labe : customEvent.label;
+    customEvent.metadata = (_customEventJson$meta = customEventJson === null || customEventJson === void 0 ? void 0 : customEventJson.metadata) !== null && _customEventJson$meta !== void 0 ? _customEventJson$meta : customEvent.metadata;
+    if (customEvent.id in graph.customEvents) {
+      throw new Error(`duplicate variable id ${customEvent.id}`);
+    }
+    graph.customEvents[customEvent.id] = customEvent;
+  }
+}
+
+function writeGraphToJSON(graph) {
+  const graphJson = {};
+  if (Object.keys(graph.metadata).length > 0) {
+    graphJson.metadata = graph.metadata;
+  }
+
+  // save custom events
+  Object.values(graph.customEvents).forEach(customEvent => {
+    const customEventJson = {
+      name: customEvent.name,
+      id: customEvent.id
+    };
+    if (customEvent.label.length > 0) {
+      customEventJson.label = customEvent.label;
+    }
+    if (customEvent.parameters.length > 0) {
+      const parametersJson = [];
+      customEvent.parameters.forEach(parameter => {
+        parametersJson.push({
+          name: parameter.name,
+          valueTypeName: parameter.valueTypeName,
+          defaultValue: parameter.value
+        });
+      });
+      customEventJson.parameters = parametersJson;
+    }
+    if (Object.keys(customEvent.metadata).length > 0) {
+      customEventJson.metadata = customEvent.metadata;
+    }
+    if (graphJson.customEvents === undefined) {
+      graphJson.customEvents = [];
+    }
+    graphJson.customEvents.push(customEventJson);
+  });
+
+  // save variables
+  Object.values(graph.variables).forEach(variable => {
+    const variableJson = {
+      valueTypeName: variable.valueTypeName,
+      name: variable.name,
+      id: variable.id,
+      initialValue: graph.registry.values.get(variable.valueTypeName).serialize(variable.initialValue)
+    };
+    if (variable.label.length > 0) {
+      variableJson.label = variable.label;
+    }
+    if (Object.keys(variable.metadata).length > 0) {
+      variableJson.metadata = variable.metadata;
+    }
+    if (graphJson.variables === undefined) {
+      graphJson.variables = [];
+    }
+    graphJson.variables.push(variableJson);
+  });
+
+  // save nodes
+  Object.values(graph.nodes).forEach(node => {
+    const nodeJson = {
+      type: node.description.typeName,
+      id: node.id
+    };
+    if (node.label.length > 0) {
+      nodeJson.label = node.label;
+    }
+    if (Object.keys(node.metadata).length > 0) {
+      nodeJson.metadata = node.metadata;
+    }
+    if (Object.keys(node.description.configuration).length > 0) {
+      const configurationJson = {};
+      Object.keys(node.configuration).forEach(key => {
+        configurationJson[key] = node.configuration[key];
+      });
+      nodeJson.configuration = configurationJson;
+    }
+    const parametersJson = {};
+    node.inputs.forEach(inputSocket => {
+      if (inputSocket.valueTypeName === 'flow') return;
+      let parameterJson = undefined;
+      if (inputSocket.links.length === 0) {
+        parameterJson = {
+          value: graph.registry.values.get(inputSocket.valueTypeName).serialize(inputSocket.value)
+        };
+      } else if (inputSocket.links.length === 1) {
+        const link = inputSocket.links[0];
+        parameterJson = {
+          link: {
+            nodeId: link.nodeId,
+            socket: link.socketName
+          }
+        };
+      } else {
+        throw new Error(`should not get here, inputSocket.links.length = ${inputSocket.links.length} > 1`);
+      }
+      parametersJson[inputSocket.name] = parameterJson;
+    });
+    if (Object.keys(parametersJson).length > 0) {
+      nodeJson.parameters = parametersJson;
+    }
+    const flowsJson = {};
+    node.outputs.forEach(outputSocket => {
+      if (outputSocket.valueTypeName !== 'flow') return;
+      if (outputSocket.links.length === 0) return;
+      const linkJson = {
+        nodeId: outputSocket.links[0].nodeId,
+        socket: outputSocket.links[0].socketName
+      };
+      flowsJson[outputSocket.name] = linkJson;
+    });
+    if (Object.keys(flowsJson).length > 0) {
+      nodeJson.flows = flowsJson;
+    }
+    if (graphJson.nodes === undefined) {
+      graphJson.nodes = [];
+    }
+    graphJson.nodes.push(nodeJson);
+  });
+  return graphJson;
+}
+
+function writeNodeSpecsToJSON(registry) {
+  const nodeSpecsJSON = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+    const nodeSpecJSON = {
+      type: nodeTypeName,
+      category: node.description.category,
+      label: node.description.label,
+      inputs: [],
+      outputs: [],
+      configuration: []
+    };
+    node.inputs.forEach(inputSocket => {
+      const valueType = inputSocket.valueTypeName === 'flow' ? undefined : registry.values.get(inputSocket.valueTypeName);
+      let defaultValue = inputSocket.value;
+      if (valueType !== undefined) {
+        defaultValue = valueType.serialize(defaultValue);
+      }
+      if (defaultValue === undefined && valueType !== undefined) {
+        defaultValue = valueType.serialize(valueType.creator());
+      }
+      const socketSpecJSON = {
+        name: inputSocket.name,
+        valueType: inputSocket.valueTypeName,
+        defaultValue
+      };
+      nodeSpecJSON.inputs.push(socketSpecJSON);
+    });
+    node.outputs.forEach(outputSocket => {
+      const socketSpecJSON = {
+        name: outputSocket.name,
+        valueType: outputSocket.valueTypeName
+      };
+      nodeSpecJSON.outputs.push(socketSpecJSON);
+    });
+    nodeSpecsJSON.push(nodeSpecJSON);
+  });
+  return nodeSpecsJSON;
+}
+
+function getNodeDescriptions(importWildcard) {
+  return Object.keys(importWildcard).map(key => importWildcard[key]).filter(value => value instanceof NodeDescription);
+}
+class NodeDescription {
+  constructor(typeName, category, label = '', factory, otherTypeNames = [], helpDescription = '', configuration = {}) {
+    this.typeName = typeName;
+    this.category = category;
+    this.label = label;
+    this.factory = factory;
+    this.otherTypeNames = otherTypeNames;
+    this.helpDescription = helpDescription;
+    this.configuration = configuration;
+  }
+}
+class NodeDescription2 extends NodeDescription {
+  constructor(properties) {
+    super(properties.typeName, properties.category, properties.label, properties.factory, properties.otherTypeNames, properties.helpDescription, properties.configuration);
+    this.properties = properties;
+  }
+}
+
+class NodeTypeRegistry {
+  constructor() {
+    _defineProperty(this, "typeNameToNodeDescriptions", {});
+  }
+  clear() {
+    for (const nodeTypeName in this.typeNameToNodeDescriptions) {
+      delete this.typeNameToNodeDescriptions[nodeTypeName];
+    }
+  }
+  register(...descriptions) {
+    descriptions.forEach(description => {
+      description.otherTypeNames.concat([description.typeName]).forEach(typeName => {
+        if (typeName in this.typeNameToNodeDescriptions) {
+          throw new Error(`already registered node type ${typeName} (string)`);
+        }
+        this.typeNameToNodeDescriptions[typeName] = description;
+      });
+    });
+  }
+  contains(typeName) {
+    return typeName in this.typeNameToNodeDescriptions;
+  }
+  get(typeName) {
+    if (!(typeName in this.typeNameToNodeDescriptions)) {
+      throw new Error(`no registered node with type name ${typeName}`);
+    }
+    return this.typeNameToNodeDescriptions[typeName];
+  }
+  getAllNames() {
+    return Object.keys(this.typeNameToNodeDescriptions);
+  }
+  getAllDescriptions() {
+    return Object.values(this.typeNameToNodeDescriptions);
+  }
+}
+
+class ValueTypeRegistry {
+  constructor() {
+    _defineProperty(this, "valueTypeNameToValueType", {});
+  }
+  register(...valueTypes) {
+    valueTypes.forEach(valueType => {
+      if (valueType.name in this.valueTypeNameToValueType) {
+        throw new Error(`already registered value type ${valueType.name}`);
+      }
+      this.valueTypeNameToValueType[valueType.name] = valueType;
+    });
+  }
+  get(valueTypeName) {
+    if (!(valueTypeName in this.valueTypeNameToValueType)) {
+      throw new Error(`can not find value type with name '${valueTypeName}`);
+    }
+    return this.valueTypeNameToValueType[valueTypeName];
+  }
+  getAllNames() {
+    return Object.keys(this.valueTypeNameToValueType);
+  }
+}
+
+class Registry {
+  constructor() {
+    _defineProperty(this, "values", new ValueTypeRegistry());
+    _defineProperty(this, "nodes", new NodeTypeRegistry());
+  }
+}
+
+const nodeTypeNameRegex = /^\w+(\/\w+)*$/;
+const socketNameRegex = /^\w+$/;
+function validateNodeRegistry(registry) {
+  const errorList = [];
+  const graph = new Graph(registry);
+  registry.nodes.getAllNames().forEach(nodeTypeName => {
+    const node = graph.createNode(nodeTypeName);
+
+    // ensure node is registered correctly.
+    if (node.description.typeName !== nodeTypeName) {
+      if (!node.description.otherTypeNames.includes(nodeTypeName)) {
+        errorList.push(`node with typeName '${node.description.typeName}' is registered under a different name '${nodeTypeName}'`);
+      }
+    }
+    if (!nodeTypeNameRegex.test(node.description.typeName)) {
+      errorList.push(`invalid node type name on node ${node.description.typeName}`);
+    }
+    node.inputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for input socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on input socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+    node.outputs.forEach(socket => {
+      if (!socketNameRegex.test(socket.name)) {
+        errorList.push(`invalid socket name for output socket ${socket.name} on node ${node.description.typeName}`);
+      }
+      if (socket.valueTypeName === 'flow') {
+        return;
+      }
+      const valueType = registry.values.get(socket.valueTypeName);
+      // check to ensure all value types are supported.
+      if (valueType === undefined) {
+        errorList.push(`node '${node.description.typeName}' has on output socket '${socket.name}' an unregistered value type '${socket.valueTypeName}'`);
+      }
+    });
+  });
+  return errorList;
+}
+
+const valueTypeNameRegex = /^\w+$/;
+function validateValueRegistry(graphRegistry) {
+  const errorList = [];
+  graphRegistry.values.getAllNames().forEach(valueTypeName => {
+    if (!valueTypeNameRegex.test(valueTypeName)) {
+      errorList.push(`invalid value type name ${valueTypeName}`);
+    }
+    const valueType = graphRegistry.values.get(valueTypeName);
+    const value = valueType.creator();
+    const serializedValue = valueType.serialize(value);
+    const deserializedValue = valueType.deserialize(serializedValue);
+    const reserializedValue = valueType.serialize(deserializedValue);
+    const redeserializedValue = valueType.deserialize(reserializedValue);
+    if (JSON.stringify(serializedValue) !== JSON.stringify(reserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) reserialization mismatch between ${JSON.stringify(serializedValue)} and ${JSON.stringify(reserializedValue)}`);
+    }
+    if (typeof deserializedValue !== 'bigint' && JSON.stringify(deserializedValue) !== JSON.stringify(redeserializedValue)) {
+      errorList.push(`value type (${valueTypeName}) redeserialization mismatch between ${JSON.stringify(deserializedValue)} and ${JSON.stringify(redeserializedValue)}`);
+    }
+  });
+  return errorList;
+}
+
+function validateRegistry(registry) {
+  const errorList = [];
+  errorList.push(...validateValueRegistry(registry), ...validateNodeRegistry(registry));
+  return errorList;
+}
+
+function validateGraphAcyclic(graph) {
+  // apparently if you can topological sort, it is a DAG according to: https://stackoverflow.com/questions/4168/graph-serialization/4577#4577
+
+  // instead of modifying the graph, I will use metadata to mark it in place.
+  Object.values(graph.nodes).forEach(node => {
+    // eslint-disable-next-line no-param-reassign
+    node.metadata['dag.marked'] = 'false';
+  });
+
+  // it appears that we can just keep trimming nodes whose input sockets have no connections.
+  // if we can remove all nodes, that means that there are no cycles.
+
+  const nodesToMark = [];
+  do {
+    // clear array: https://stackoverflow.com/a/1232046
+    nodesToMark.length = 0;
+    Object.values(graph.nodes).forEach(node => {
+      // ignore existing marked nodes.
+      if (node.metadata['dag.marked'] === 'true') {
+        return;
+      }
+      let inputsConnected = false;
+      node.inputs.forEach(inputSocket => {
+        inputSocket.links.forEach(link => {
+          // is the other end marked?  If not, then it is still connected.
+          if (graph.nodes[link.nodeId].metadata['dag.marked'] === 'false') {
+            inputsConnected = true;
+          }
+        });
+      });
+      if (!inputsConnected) {
+        nodesToMark.push(node);
+      }
+    });
+    nodesToMark.forEach(node => {
+      // eslint-disable-next-line no-param-reassign
+      node.metadata['dag.marked'] = 'true';
+    });
+  } while (nodesToMark.length > 0);
+  const errorList = [];
+
+  // output errors for each unmarked node
+  // also remove the metadata related to DAG marking
+  Object.values(graph.nodes).forEach(node => {
+    if (node.metadata['dag.marked'] === 'false') {
+      errorList.push(`node ${node.description.typeName} is part of a cycle, not a directed acyclic graph`);
+    }
+    // eslint-disable-next-line no-param-reassign
+    delete node.metadata['dag.marked'];
+  });
+  return errorList;
+}
+
+function validateGraphLinks(graph) {
+  const errorList = [];
+  // for each node
+  Object.values(graph.nodes).forEach(node => {
+    // for each input socket
+    node.inputs.forEach(inputSocket => {
+      // ensure that connected output sockets are the same type
+      inputSocket.links.forEach(link => {
+        // check if the node id is correct
+        if (!(link.nodeId in graph.nodes)) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using invalid nodeId: ${link.nodeId}`);
+          return;
+        }
+
+        // check if the socketName is correct
+        const upstreamNode = graph.nodes[link.nodeId];
+        const outputSocket = upstreamNode.outputs.find(socket => socket.name === link.socketName);
+        if (outputSocket === undefined) {
+          errorList.push(`node ${node.description.typeName}.${inputSocket.name} has link using a non-existent socket name: ` + `${link.socketName}, it can not be found on upstream output node: ${upstreamNode.description.typeName}`);
+          return;
+        }
+
+        // check if the socket types align
+        if (inputSocket.valueTypeName !== outputSocket.valueTypeName) {
+          errorList.push(`type mismatch between ${node.description.typeName}.${inputSocket.name} [${inputSocket.valueTypeName}] ` + `and ${upstreamNode.description.typeName}.${outputSocket.name} [${outputSocket.valueTypeName}]`);
+        }
+      });
+    });
+  });
+  return errorList;
+}
+
+function validateGraph(graph) {
+  const errorList = [];
+  errorList.push(...validateGraphAcyclic(graph), ...validateGraphLinks(graph));
+  return errorList;
+}
+
+/* eslint-disable class-methods-use-this */
+class DefaultLogger {
+  verbose(text) {
+    Logger.verbose(text);
+  }
+  info(text) {
+    Logger.info(text);
+  }
+  warn(text) {
+    Logger.warn(text);
+  }
+  error(text) {
+    Logger.error(text);
+  }
+}
+
+class ManualLifecycleEventEmitter {
+  constructor() {
+    _defineProperty(this, "startEvent", new EventEmitter());
+    _defineProperty(this, "endEvent", new EventEmitter());
+    _defineProperty(this, "tickEvent", new EventEmitter());
+  }
+}
+
+var _class$n;
+class OnCustomEvent extends EventNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      outputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      configuration
+    });
+    _defineProperty(this, "onCustomEvent", undefined);
+    this.customEvent = customEvent;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onCustomEvent === undefined);
+    this.onCustomEvent = parameters => {
+      this.customEvent.parameters.forEach(parameterSocket => {
+        if (!(parameterSocket.name in parameters)) {
+          throw new Error(`parameters of custom event do not align with parameters of custom event node, missing ${parameterSocket.name}`);
+        }
+        this.writeOutput(parameterSocket.name, parameters[parameterSocket.name]);
+      });
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.customEvent.eventEmitter.addListener(this.onCustomEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onCustomEvent !== undefined);
+    if (this.onCustomEvent !== undefined) {
+      this.customEvent.eventEmitter.removeListener(this.onCustomEvent);
+    }
+  }
+}
+_class$n = OnCustomEvent;
+_defineProperty(OnCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/onTriggered',
+  category: 'Event',
+  label: 'On Triggered',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$n(description, graph, configuration)
+}));
+
+var _class$m;
+class TriggerCustomEvent extends FlowNode2 {
+  constructor(description, graph, configuration) {
+    const customEvent = graph.customEvents[configuration.customEventId] || new CustomEvent('-1', 'undefined');
+    super({
+      description,
+      graph,
+      inputs: [new Socket('flow', 'flow'), ...customEvent.parameters.map(parameter => new Socket(parameter.valueTypeName, parameter.name, parameter.value, parameter.label))],
+      outputs: [new Socket('flow', 'flow')],
+      configuration
+    });
+    this.customEvent = customEvent;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const parameters = {};
+    this.customEvent.parameters.forEach(parameterSocket => {
+      parameters[parameterSocket.name] = this.readInput(parameterSocket.name);
+    });
+    this.customEvent.eventEmitter.emit(parameters);
+  }
+}
+_class$m = TriggerCustomEvent;
+_defineProperty(TriggerCustomEvent, "Description", new NodeDescription2({
+  typeName: 'customEvent/trigger',
+  category: 'Action',
+  label: 'Trigger',
+  configuration: {
+    customEventId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$m(description, graph, configuration)
+}));
+
+var _class$l;
+class ExpectTrue extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition'), new Socket('string', 'description')], [new Socket('flow', 'flow')]);
+  }
+  triggered(fiber, triggeredSocketName) {
+    Assert.mustBeTrue(this.readInput('condition'), this.readInput('description'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$l = ExpectTrue;
+_defineProperty(ExpectTrue, "Description", new NodeDescription('debug/expectTrue', 'Action', 'Assert Expect True', (description, graph) => new _class$l(description, graph)));
+
+var _class$k;
+class Log extends FlowNode {
+  constructor(description, graph, logger) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'text'), new Socket('string', 'severity', 'info', undefined, ['verbose', 'info', 'warning', 'error'])], [new Socket('flow', 'flow')]);
+    this.logger = logger;
+  }
+  triggered(fiber, triggeredSocketName) {
+    const text = this.readInput('text');
+    switch (this.readInput('severity')) {
+      case 'verbose':
+        this.logger.verbose(text);
+        break;
+      case 'info':
+        this.logger.info(text);
+        break;
+      case 'warning':
+        this.logger.warn(text);
+        break;
+      case 'error':
+        this.logger.error(text);
+        break;
+    }
+    fiber.commit(this, 'flow');
+  }
+}
+_class$k = Log;
+_defineProperty(Log, "Description", logger => new NodeDescription('debug/log', 'Action', 'Debug Log', (description, graph) => new _class$k(description, graph, logger)));
+
+var _class$j;
+class Branch extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('boolean', 'condition')], [new Socket('flow', 'true'), new Socket('flow', 'false')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    fiber.commit(this, this.readInput('condition') === true ? 'true' : 'false');
+  }
+}
+_class$j = Branch;
+_defineProperty(Branch, "Description", new NodeDescription2({
+  typeName: 'flow/branch',
+  category: 'Flow',
+  label: 'Branch',
+  factory: (description, graph) => new _class$j(description, graph),
+  helpDescription: "Checks the value of the 'condition' input and if true, executes the 'true' branch, otherwise it executes the 'false' branch."
+}));
+
+var _class$i;
+class Counter extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          this.count++;
+          this.writeOutput('count', this.count);
+          fiber.commit(this, 'flow');
+          break;
+        }
+      case 'reset':
+        {
+          this.count = 0;
+          break;
+        }
+      default:
+        throw new Error('should not get here');
+    }
+  }
+}
+_class$i = Counter;
+_defineProperty(Counter, "Description", new NodeDescription('flow/counter', 'Flow', 'Counter', (description, graph) => new _class$i(description, graph)));
+
+var _class$h;
+
+// ASYNC - asynchronous evaluation
+// also called "delay"
+
+class Delay extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.timeoutPending = true;
+    setTimeout(() => {
+      // check if cancelled
+      if (!this.timeoutPending) return;
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.timeoutPending = false;
+  }
+}
+_class$h = Delay;
+_defineProperty(Delay, "Description", new NodeDescription2({
+  typeName: 'time/delay',
+  otherTypeNames: ['flow/delay'],
+  category: 'Time',
+  label: 'Delay',
+  factory: (description, graph) => new _class$h(description, graph)
+}));
+
+var _class$g;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoN extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'n', 1), new Socket('flow', 'reset')], [new Socket('flow', 'flow'), new Socket('integer', 'count')]);
+    _defineProperty(this, "count", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.count = 0;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (this.count < Number(this.readInput('n'))) {
+        this.writeOutput('count', this.count);
+        this.count++;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$g = DoN;
+_defineProperty(DoN, "Description", new NodeDescription('flow/doN', 'Flow', 'DoN', (description, graph) => new _class$g(description, graph)));
+
+var _class$f;
+
+// based on Unreal Engine Blueprint DoN node
+
+class DoOnce extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "firedOnce", false);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.firedOnce = false;
+      return;
+    }
+    if (triggeringSocketName === 'flow') {
+      if (!this.firedOnce) {
+        this.firedOnce = true;
+        fiber.commit(this, 'flow');
+      }
+      return;
+    }
+    throw new Error('should not get here');
+  }
+}
+_class$f = DoOnce;
+_defineProperty(DoOnce, "Description", new NodeDescription('flow/doOnce', 'Flow', 'DoOnce', (description, graph) => new _class$f(description, graph)));
+
+var _class$e;
+
+// as long as this continues to be triggered within the duration period, it will not fire.
+// based lousy on https://www.npmjs.com/package/debounce
+
+class Debounce extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'waitDuration'), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    this.triggerVersion++;
+
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      return;
+    }
+    const localTriggerCount = this.triggerVersion;
+    setTimeout(() => {
+      if (this.triggerVersion >= localTriggerCount) {
+        // ignore this timer, as it isn't for the most recent trigger
+        return;
+      }
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('waitDuration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+  }
+}
+_class$e = Debounce;
+_defineProperty(Debounce, "Description", new NodeDescription('flow/debounce', 'Flow', 'Debounce', (description, graph) => new _class$e(description, graph)));
+
+var _class$d;
+class FlipFlop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow')], [new Socket('flow', 'on'), new Socket('flow', 'off'), new Socket('boolean', 'isOn')]);
+    _defineProperty(this, "isOn", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    this.writeOutput('isOn', this.isOn);
+    fiber.commit(this, this.isOn ? 'on' : 'off');
+    this.isOn = !this.isOn;
+  }
+}
+_class$d = FlipFlop;
+_defineProperty(FlipFlop, "Description", new NodeDescription('flow/flipFlop', 'Flow', 'Flip Flop', (description, graph) => new _class$d(description, graph)));
+
+var _class$c;
+class ForLoop extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('integer', 'startIndex'), new Socket('integer', 'endIndex')], [new Socket('flow', 'loopBody'), new Socket('integer', 'index'), new Socket('flow', 'completed')]);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an async fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const startIndex = this.readInput('startIndex');
+    const endIndex = this.readInput('endIndex');
+    const loopBodyIteration = i => {
+      if (i < endIndex) {
+        this.writeOutput('index', i);
+        fiber.commit(this, 'loopBody', () => {
+          loopBodyIteration(i + BigInt(1));
+        });
+      } else {
+        fiber.commit(this, 'completed');
+      }
+    };
+    loopBodyIteration(startIndex);
+  }
+}
+_class$c = ForLoop;
+_defineProperty(ForLoop, "Description", new NodeDescription2({
+  typeName: 'flow/forLoop',
+  category: 'Flow',
+  label: 'For Loop',
+  factory: (description, graph) => new _class$c(description, graph)
+}));
+
+var _class$b;
+
+// based on Unreal Engine Blueprint Gate node
+
+class Gate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'open'), new Socket('flow', 'close'), new Socket('flow', 'toggle'), new Socket('boolean', 'startClosed', true)], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "isClosed", true);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.isClosed = this.readInput('startClosed');
+      this.isInitialized = true;
+    }
+    switch (triggeringSocketName) {
+      case 'flow':
+        {
+          if (!this.isClosed) {
+            fiber.commit(this, 'flow');
+          }
+          break;
+        }
+      case 'open':
+        {
+          this.isClosed = false;
+          return;
+        }
+      case 'close':
+        {
+          this.isClosed = true;
+          return;
+        }
+      case 'toggle':
+        {
+          this.isClosed = !this.isClosed;
+          return;
+        }
+    }
+  }
+}
+_class$b = Gate;
+_defineProperty(Gate, "Description", new NodeDescription('flow/gate', 'Flow', 'Gate', (description, graph) => new _class$b(description, graph)));
+
+var _class$a;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class MultiGate extends FlowNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('flow', 'reset'), new Socket('boolean', 'loop', true), new Socket('integer', 'startIndex', 0)], [new Socket('flow', '1'), new Socket('flow', '2'), new Socket('flow', '3')]);
+    _defineProperty(this, "isInitialized", false);
+    _defineProperty(this, "nextIndex", 0);
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (!this.isInitialized) {
+      this.nextIndex = Number(this.readInput('startIndex'));
+    }
+    if (this.readInput('loop')) {
+      this.nextIndex = this.nextIndex % this.outputs.length;
+    }
+    switch (triggeringSocketName) {
+      case 'reset':
+        {
+          this.nextIndex = 0;
+          return;
+        }
+      case 'flow':
+        {
+          if (0 <= this.nextIndex && this.nextIndex < this.outputs.length) {
+            fiber.commit(this, this.outputs[this.nextIndex].name);
+          }
+          this.nextIndex++;
+          return;
+        }
+    }
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$a = MultiGate;
+_defineProperty(MultiGate, "Description", new NodeDescription('flow/multiGate', 'Flow', 'MultiGate', (description, graph) => new _class$a(description, graph)));
+
+var _class$9;
+
+// https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/flow/
+
+class Sequence extends FlowNode {
+  constructor(description, graph, configuration) {
+    const outputs = [];
+    const numOutputs = configuration.numOutputs;
+    for (let outputIndex = 1; outputIndex <= numOutputs; outputIndex++) {
+      outputs.push(new Socket('flow', `${outputIndex}`));
+    }
+    super(description, graph, [new Socket('flow', 'flow')], outputs);
+  }
+  triggered(fiber, triggeringSocketName) {
+    // these outputs are fired sequentially in an sync fashion but without delays.
+    // Thus a promise is returned and it continually returns a promise until each of the sequences has been executed.
+    const sequenceIteration = i => {
+      if (i < this.outputs.length) {
+        const outputSocket = this.outputs[i];
+        fiber.commit(this, outputSocket.name, () => {
+          sequenceIteration(i + 1);
+        });
+      }
+    };
+    sequenceIteration(0);
+  }
+}
+_class$9 = Sequence;
+_defineProperty(Sequence, "Description", new NodeDescription2({
+  typeName: 'flow/sequence',
+  category: 'Flow',
+  label: 'Sequence',
+  configuration: {
+    numOutputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$9(description, graph, configuration)
+}));
+
+var _class$8;
+
+// based on the description here: https://blog.webdevsimplified.com/2022-03/debounce-vs-throttle/
+
+class Throttle extends AsyncNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('float', 'duration', 1), new Socket('flow', 'cancel')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "triggerVersion", 0);
+    _defineProperty(this, "timeoutPending", false);
+  }
+  triggered(engine, triggeringSocketName, finished) {
+    // if cancelling, just increment triggerVersion and do not set a timer. :)
+    if (triggeringSocketName === 'cancel') {
+      if (this.timeoutPending) {
+        this.triggerVersion++;
+        this.timeoutPending = false;
+      }
+      return;
+    }
+
+    // if there is a valid timeout running, leave it.
+    if (this.timeoutPending) {
+      return;
+    }
+
+    // otherwise start it.
+    this.triggerVersion++;
+    const localTriggerCount = this.triggerVersion;
+    this.timeoutPending = true;
+    setTimeout(() => {
+      if (this.triggerVersion !== localTriggerCount) {
+        return;
+      }
+      Assert.mustBeTrue(this.timeoutPending);
+      this.timeoutPending = false;
+      engine.commitToNewFiber(this, 'flow');
+      finished();
+    }, this.readInput('duration') * 1000);
+  }
+  dispose() {
+    this.triggerVersion++; // equivalent to 'cancel' trigger behavior.
+    this.timeoutPending = false;
+  }
+}
+_class$8 = Throttle;
+_defineProperty(Throttle, "Description", new NodeDescription('flow/throttle', 'Flow', 'Throttle', (description, graph) => new _class$8(description, graph)));
+
+var _class$7;
+
+// this is equivalent to Promise.all()
+class WaitAll extends FlowNode {
+  constructor(description, graph, numInputs) {
+    const inputs = [];
+    for (let inputIndex = 1; inputIndex <= numInputs; inputIndex++) {
+      inputs.push(new Socket('flow', `${inputIndex}`));
+    }
+    super(description, graph, [...inputs, new Socket('flow', 'reset'), new Socket('boolean', 'autoReset')], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "isOn", true);
+    _defineProperty(this, "triggeredMap", {});
+    _defineProperty(this, "triggeredCount", 0);
+    _defineProperty(this, "outputTriggered", false);
+    this.numInputs = numInputs;
+    this.reset();
+  }
+  reset() {
+    for (let inputIndex = 1; inputIndex <= this.numInputs; inputIndex++) {
+      this.triggeredMap[`${inputIndex}`] = false;
+    }
+    this.triggeredCount = 0;
+    this.outputTriggered = false;
+  }
+  triggered(fiber, triggeringSocketName) {
+    if (triggeringSocketName === 'reset') {
+      this.reset();
+      return;
+    }
+    if (this.triggeredMap[triggeringSocketName]) {
+      return;
+    }
+    this.triggeredMap[triggeringSocketName] = true;
+    this.triggeredCount++;
+
+    // if a & b are triggered, first output!
+    if (this.triggeredCount === this.numInputs && !this.outputTriggered) {
+      fiber.commit(this, 'flow');
+      this.outputTriggered = true;
+
+      // auto-reset if required.
+      if (this.readInput('autoReset') === true) {
+        this.reset();
+      }
+    }
+  }
+}
+_class$7 = WaitAll;
+_defineProperty(WaitAll, "Description", new NodeDescription2({
+  typeName: 'flow/waitAll',
+  category: 'Flow',
+  label: 'WaitAll',
+  configuration: {
+    numInputs: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$7(description, graph, (configuration === null || configuration === void 0 ? void 0 : configuration.numInputs) || 3)
+}));
+
+var _class$6;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnEnd extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onEndEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onEndEvent === undefined);
+    this.onEndEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.endEvent.addListener(this.onEndEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onEndEvent !== undefined);
+    if (this.onEndEvent !== undefined) {
+      this.lifecycleEventEmitter.endEvent.removeListener(this.onEndEvent);
+    }
+  }
+}
+_class$6 = LifecycleOnEnd;
+_defineProperty(LifecycleOnEnd, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onEnd', 'Event', 'On End', (description, graph) => new _class$6(description, graph, lifecycleEventEmitter)));
+
+var _class$5;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnStart extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow')]);
+    _defineProperty(this, "onStartEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onStartEvent === undefined);
+    this.onStartEvent = () => {
+      engine.commitToNewFiber(this, 'flow');
+    };
+    this.lifecycleEventEmitter.startEvent.addListener(this.onStartEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onStartEvent !== undefined);
+    if (this.onStartEvent !== undefined) {
+      this.lifecycleEventEmitter.startEvent.removeListener(this.onStartEvent);
+    }
+  }
+}
+_class$5 = LifecycleOnStart;
+_defineProperty(LifecycleOnStart, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onStart', 'Event', 'On Start', (description, graph) => new _class$5(description, graph, lifecycleEventEmitter)));
+
+var _class$4;
+// inspired by: https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Events/
+class LifecycleOnTick extends EventNode {
+  constructor(description, graph, lifecycleEventEmitter) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'deltaSeconds')]);
+    _defineProperty(this, "onTickEvent", undefined);
+    this.lifecycleEventEmitter = lifecycleEventEmitter;
+  }
+  init(engine) {
+    Assert.mustBeTrue(this.onTickEvent === undefined);
+    let lastTickTime = Date.now();
+    this.onTickEvent = () => {
+      const currentTime = Date.now();
+      const deltaSeconds = (currentTime - lastTickTime) * 0.001;
+      this.writeOutput('deltaSeconds', deltaSeconds);
+      engine.commitToNewFiber(this, 'flow');
+      lastTickTime = currentTime;
+    };
+    this.lifecycleEventEmitter.tickEvent.addListener(this.onTickEvent);
+  }
+  dispose(engine) {
+    Assert.mustBeTrue(this.onTickEvent !== undefined);
+    if (this.onTickEvent !== undefined) {
+      this.lifecycleEventEmitter.tickEvent.removeListener(this.onTickEvent);
+    }
+  }
+}
+_class$4 = LifecycleOnTick;
+_defineProperty(LifecycleOnTick, "Description", lifecycleEventEmitter => new NodeDescription('lifecycle/onTick', 'Event', 'On Tick', (description, graph) => new _class$4(description, graph, lifecycleEventEmitter)));
+
+const Constant$b = new NodeDescription('math/boolean', 'Logic', 'Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => a));
+const And = new NodeDescription('math/and/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a && b));
+const Or = new NodeDescription('math/or/boolean', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a || b));
+const Not = new NodeDescription('math/negate/boolean', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'boolean', a => !a));
+const ToFloat$2 = new NodeDescription('math/toFloat/boolean', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'float', a => a ? 1 : 0));
+const Equal$b = new NodeDescription('math/equal/boolean', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['boolean', 'boolean'], 'boolean', (a, b) => a === b));
+const toInteger = new NodeDescription('math/toInteger/boolean', 'Logic', 'To Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['boolean'], 'integer', a => a ? 1n : 0n));
+
+var BooleanNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$b,
+  And: And,
+  Or: Or,
+  Not: Not,
+  ToFloat: ToFloat$2,
+  Equal: Equal$b,
+  toInteger: toInteger
+});
+
+const BooleanValue = new ValueType('boolean', () => false, value => typeof value === 'string' ? value.toLowerCase() === 'true' : value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+const EPSILON = 0.000001; // chosen from gl-matrix
+
+function equalsTolerance(a, b, tolerance = EPSILON) {
+  return Math.abs(a - b) < tolerance;
+}
+function degreesToRadians(a) {
+  return a * (Math.PI / 180);
+}
+function radiansToDegrees(a) {
+  return a * (180 / Math.PI);
+}
+function clamp(a, min, max) {
+  return a < min ? min : a > max ? max : a;
+}
+
+// Unreal Engine Blueprint Float nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Float/
+
+const Constant$a = new NodeDescription('math/float', 'Logic', 'Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => a));
+const Add$8 = new NodeDescription('math/add/float', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a + b));
+const Subtract$8 = new NodeDescription('math/subtract/float', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a - b));
+const Negate$9 = new NodeDescription('math/negate/float', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => -a));
+const Multiply$4 = new NodeDescription('math/multiply/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a * b));
+const Divide$1 = new NodeDescription('math/divide/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a / b));
+const Modulus$1 = new NodeDescription('math/modulus/float', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => a % b));
+const Power = new NodeDescription('math/pow/float', 'Logic', 'POW', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', Math.pow));
+const SquareRoot = new NodeDescription('math/sqrt/float', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sqrt));
+const E = new NodeDescription('math/e/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.E));
+const Exp$1 = new NodeDescription('math/exp/float', 'Logic', 'EXP', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.exp));
+const Ln$1 = new NodeDescription('math/ln/float', 'Logic', 'LN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log));
+const Log2 = new NodeDescription('math/log2/float', 'Logic', 'LOG2', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log2));
+const Log10 = new NodeDescription('math/log10/float', 'Logic', 'LOG10', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.log10));
+const PI = new NodeDescription('math/pi/float', 'Logic', '', (description, graph) => new In0Out1FuncNode(description, graph, 'float', () => Math.PI));
+const Sin = new NodeDescription('math/sin/float', 'Logic', 'SIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sin));
+const Asin = new NodeDescription('math/asin/float', 'Logic', 'ASIN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.asin));
+const Cos = new NodeDescription('math/cos/float', 'Logic', 'COS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.cos));
+const Acos = new NodeDescription('math/acos/float', 'Logic', 'ACOS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.acos));
+const Tan = new NodeDescription('math/tan/float', 'Logic', 'TAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.tan));
+const RadiansToDegrees = new NodeDescription('math/radiansToDegrees/float', 'Logic', 'To Degrees', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => radiansToDegrees(a), ['radian']));
+const DegreesToRadians = new NodeDescription('math/degreesToRadians/float', 'Logic', 'To Radians', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => degreesToRadians(a), ['degrees']));
+const Atan = new NodeDescription('math/atan/float', 'Logic', 'ATAN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.atan));
+const Mix$7 = new NodeDescription('math/mix/float', 'Logic', 'MIX', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (a, b, t) => {
+  const s = 1 - t;
+  return a * s + b * t;
+}, ['a', 'b', 't']));
+const ToFloat$1 = new NodeDescription('math/toFloat/float', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', a => Number(a)));
+const Min$1 = new NodeDescription('math/min/float', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.min(a, b) // TODO: can I jsut pass in Math.min?
+));
+
+const Max$1 = new NodeDescription('math/max/float', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'float', (a, b) => Math.max(a, b) // TODO: can I jsut pass in Math.max?
+));
+
+const Clamp$1 = new NodeDescription('math/clamp/float', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'float', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs$1 = new NodeDescription('math/abs/float', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.abs));
+const Sign$1 = new NodeDescription('math/sign/float', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.sign));
+const Floor = new NodeDescription('math/floor/float', 'Logic', 'FLOOR', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.floor));
+const Ceil = new NodeDescription('math/ceil/float', 'Logic', 'CEIL', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.ceil));
+const Round = new NodeDescription('math/round/float', 'Logic', 'ROUND', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.round));
+const Trunc = new NodeDescription('math/trunc/float', 'Logic', 'TRUNC', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'float', Math.trunc));
+const Random = new NodeDescription('math/random/float', 'Logic', 'RANDOM', (description, graph) => new In0Out1FuncNode(description, graph, 'float', Math.random));
+const Equal$a = new NodeDescription('math/equal/float', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a === b, ['a', 'b']));
+const EqualTolerance = new NodeDescription('math/equalTolerance/float', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'boolean', (a, b, tolerance) => equalsTolerance(a, b, tolerance), ['a', 'b', 'tolerance']));
+const GreaterThan$1 = new NodeDescription('math/greaterThan/float', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual$1 = new NodeDescription('math/greaterThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a >= b));
+const LessThan$1 = new NodeDescription('math/lessThan/float', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual$1 = new NodeDescription('math/lessThanOrEqual/float', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'boolean', (a, b) => a <= b));
+const IsNaN = new NodeDescription('math/isNaN/float', 'Logic', 'isNaN', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', Number.isNaN));
+const IsInf = new NodeDescription('math/isInf/float', 'Logic', 'isInf', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'boolean', a => !Number.isFinite(a) && !Number.isNaN(a)));
+
+var FloatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$a,
+  Add: Add$8,
+  Subtract: Subtract$8,
+  Negate: Negate$9,
+  Multiply: Multiply$4,
+  Divide: Divide$1,
+  Modulus: Modulus$1,
+  Power: Power,
+  SquareRoot: SquareRoot,
+  E: E,
+  Exp: Exp$1,
+  Ln: Ln$1,
+  Log2: Log2,
+  Log10: Log10,
+  PI: PI,
+  Sin: Sin,
+  Asin: Asin,
+  Cos: Cos,
+  Acos: Acos,
+  Tan: Tan,
+  RadiansToDegrees: RadiansToDegrees,
+  DegreesToRadians: DegreesToRadians,
+  Atan: Atan,
+  Mix: Mix$7,
+  ToFloat: ToFloat$1,
+  Min: Min$1,
+  Max: Max$1,
+  Clamp: Clamp$1,
+  Abs: Abs$1,
+  Sign: Sign$1,
+  Floor: Floor,
+  Ceil: Ceil,
+  Round: Round,
+  Trunc: Trunc,
+  Random: Random,
+  Equal: Equal$a,
+  EqualTolerance: EqualTolerance,
+  GreaterThan: GreaterThan$1,
+  GreaterThanOrEqual: GreaterThanOrEqual$1,
+  LessThan: LessThan$1,
+  LessThanOrEqual: LessThanOrEqual$1,
+  IsNaN: IsNaN,
+  IsInf: IsInf
+});
+
+const cSeparator = /[^\d+.-]+/;
+function parseSafeFloat(text, fallback = 0) {
+  try {
+    return Number.parseFloat(text);
+  } catch (_unused) {
+    return fallback;
+  }
+}
+function parseSafeFloats(text, fallback = 0) {
+  return text.split(cSeparator).filter(Boolean).map(value => parseSafeFloat(value, fallback));
+}
+function toSafeString(elements) {
+  return `[${elements.join(',')}]`;
+}
+
+const FloatValue = new ValueType('float', () => 0, value => typeof value === 'string' ? parseSafeFloat(value, 0) : value, value => value, (start, end, t) => start * (1 - t) + end * t);
+
+// Unreal Engine Integer Blueprints API: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Math/Integer/
+
+const Constant$9 = new NodeDescription('math/integer', 'Logic', 'Integer', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a));
+const Add$7 = new NodeDescription('math/add/integer', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a + b));
+const Subtract$7 = new NodeDescription('math/subtract/integer', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a - b));
+const Negate$8 = new NodeDescription('math/negate/integer', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => -a));
+const Multiply$3 = new NodeDescription('math/multiply/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a * b));
+const Divide = new NodeDescription('math/divide/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a / b));
+const Modulus = new NodeDescription('math/modulus/integer', 'Logic', 'MOD', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a % b));
+const ToFloat = new NodeDescription('math/toFloat/integer', 'Logic', 'To Float', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'float', a => Number(a)));
+const Min = new NodeDescription('math/min/integer', 'Logic', 'MIN', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? b : a));
+const Max = new NodeDescription('math/max/integer', 'Logic', 'MAX', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'integer', (a, b) => a > b ? a : b));
+const Clamp = new NodeDescription('math/clamp/integer', 'Logic', 'CLAMP', (description, graph) => new In3Out1FuncNode(description, graph, ['integer', 'integer', 'integer'], 'integer', (value, min, max) => value < min ? min : value > max ? max : value, ['value', 'min', 'max']));
+const Abs = new NodeDescription('math/abs/integer', 'Logic', 'ABS', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => a < BigInt(0) ? -a : a));
+const Sign = new NodeDescription('math/sign/integer', 'Logic', 'SIGN', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'integer', a => BigInt(a < 0 ? -1 : a > 0 ? 1 : 0)));
+const Equal$9 = new NodeDescription('math/equal/integer', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a === b));
+const GreaterThan = new NodeDescription('math/greaterThan/integer', 'Logic', '>', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a > b));
+const GreaterThanOrEqual = new NodeDescription('math/greaterThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a >= b));
+const LessThan = new NodeDescription('math/lessThan/integer', 'Logic', '<', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a < b));
+const LessThanOrEqual = new NodeDescription('math/lessThanOrEqual/integer', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['integer', 'integer'], 'boolean', (a, b) => a <= b));
+const toBoolean = new NodeDescription('math/toBoolean/integer', 'Logic', 'To Boolean', (description, graph) => new In1Out1FuncNode(description, graph, ['integer'], 'boolean', a => a !== 0n));
+
+var IntegerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$9,
+  Add: Add$7,
+  Subtract: Subtract$7,
+  Negate: Negate$8,
+  Multiply: Multiply$3,
+  Divide: Divide,
+  Modulus: Modulus,
+  ToFloat: ToFloat,
+  Min: Min,
+  Max: Max,
+  Clamp: Clamp,
+  Abs: Abs,
+  Sign: Sign,
+  Equal: Equal$9,
+  GreaterThan: GreaterThan,
+  GreaterThanOrEqual: GreaterThanOrEqual,
+  LessThan: LessThan,
+  LessThanOrEqual: LessThanOrEqual,
+  toBoolean: toBoolean
+});
+
+const IntegerValue = new ValueType('integer', () => BigInt(0), value => BigInt(value), value => Number.MIN_SAFE_INTEGER <= value && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value.toString(),
+// prefer string to ensure full range is covered
+
+(start, end, t) => BigInt(Number(start) * (1 - t) + Number(end) * t));
+
+const Constant$8 = new NodeDescription('logic/string', 'Logic', 'String', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'string', a => a));
+const Concat = new NodeDescription('logic/concat/string', 'Logic', 'Concat', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'string', (a, b) => a.concat(b)));
+const Includes = new NodeDescription('logic/includes/string', 'Logic', 'Includes', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a.includes(b)));
+const Length$4 = new NodeDescription('logic/length/string', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['string'], 'integer', a => BigInt(a.length)));
+const Equal$8 = new NodeDescription('math/equal/string', 'Logic', '=', (description, graph) => new In2Out1FuncNode(description, graph, ['string', 'string'], 'boolean', (a, b) => a === b));
+
+var StringNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$8,
+  Concat: Concat,
+  Includes: Includes,
+  Length: Length$4,
+  Equal: Equal$8
+});
+
+const StringValue = new ValueType('string', () => '', value => value, value => value, (start, end, t) => t < 0.5 ? start : end);
+
+var _class$3;
+class VariableSet extends FlowNode {
+  static GetDescription(graph, variableId) {
+    const variable = graph.variables[variableId];
+    return new NodeDescription(`variable/set/${variable.id}`, 'Action', `Set`, (description, graph) => new VariableSet(description, graph, variable));
+  }
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [new Socket('flow', 'flow'), new Socket(variable.valueTypeName, 'value', undefined, variable.name) // variable name is a label so variable can be renamed without breaking graph.
+    ], [new Socket('flow', 'flow')], configuration);
+    this.variable = variable;
+  }
+  triggered(fiber, triggeredSocketName) {
+    this.variable.set(this.readInput('value'));
+    fiber.commit(this, 'flow');
+  }
+}
+_class$3 = VariableSet;
+_defineProperty(VariableSet, "Description", new NodeDescription2({
+  typeName: 'variable/set',
+  category: 'Action',
+  label: 'Set',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$3(description, graph, configuration)
+}));
+
+var _class$2;
+class VariableGet extends ImmediateNode {
+  constructor(description, graph, configuration) {
+    const variable = graph.variables[configuration.variableId] || new Variable('-1', 'undefined', 'string', '');
+    super(description, graph, [], [new Socket(variable.valueTypeName, 'value', undefined, variable.name)],
+    // output socket label uses variable name like UE4, but name is value to avoid breaking graph when variable is renamed
+    () => {
+      this.writeOutput('value', variable.get());
+    }, configuration);
+  }
+}
+_class$2 = VariableGet;
+_defineProperty(VariableGet, "Description", new NodeDescription2({
+  typeName: 'variable/get',
+  category: 'Query',
+  label: 'Get',
+  configuration: {
+    variableId: {
+      valueType: 'number'
+    }
+  },
+  factory: (description, graph, configuration) => new _class$2(description, graph, configuration)
+}));
+
+const EasingFunctions = {
+  linear: t => t,
+  quadratic: t => t * t,
+  cubic: t => t * t * t,
+  quartric: t => t * t * t * t,
+  quintic: t => t * t * t * t * t,
+  sine: t => 1 - Math.cos(t * Math.PI / 2),
+  exponential: t => Math.pow(2, 10 * (t - 1)),
+  circle: t => 1 - Math.sqrt(1 - t * t),
+  back: t => {
+    const s = 1.70158;
+    return t * t * ((s + 1) * t - s);
+  },
+  elastic: t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * Math.PI),
+  bounce: t => {
+    if (t < 1 / 2.75) {
+      return 7.5625 * t * t;
+    }
+    if (t < 2 / 2.75) {
+      const _t = t - 1.5 / 2.75;
+      return 7.5625 * _t * _t + 0.75;
+    }
+    if (t < 2.5 / 2.75) {
+      const _t2 = t - 2.25 / 2.75;
+      return 7.5625 * _t2 * _t2 + 0.9375;
+    }
+    const t2 = t - 2.625 / 2.75;
+    return 7.5625 * t2 * t2 + 0.984375;
+  }
+};
+const EasingModes = {
+  in: easing => {
+    return easing;
+  },
+  out: easing => {
+    return t => 1 - easing(1 - t);
+  },
+  inOut: easing => {
+    return t => {
+      if (t < 0.5) {
+        return easing(t * 2) / 2;
+      }
+      return 1 - easing((1 - t) * 2) / 2;
+    };
+  }
+};
+
+var _class$1;
+class Easing extends ImmediateNode {
+  constructor(description, graph) {
+    super(description, graph, [new Socket('string', 'easingFunction', 'linear', undefined, Object.keys(EasingFunctions)), new Socket('string', 'easingMode', 'inOut', undefined, Object.keys(EasingModes)), new Socket('float', 't')], [new Socket('float', 't')], () => {
+      const easingFunction = EasingFunctions[this.readInput('easingFunction')];
+      const easingMode = EasingModes[this.readInput('easingMode')];
+      const easing = easingMode(easingFunction);
+      const inputT = this.readInput('t');
+      this.writeOutput('t', easing(inputT));
+    });
+  }
+}
+_class$1 = Easing;
+_defineProperty(Easing, "Description", new NodeDescription('math/easing', 'Logic', 'Easing', (description, graph) => new _class$1(description, graph)));
+
+function toCamelCase(text) {
+  if (text.length > 0) {
+    return text.slice(0, 1).toLocaleUpperCase() + text.slice(1);
+  }
+  return text;
+}
+
+/* eslint-disable @typescript-eslint/no-explicit-any */
+function registerSerializersForValueType(registry, valueTypeName) {
+  const camelCaseValueTypeName = toCamelCase(valueTypeName);
+  registry.nodes.register(new NodeDescription(`math/to${camelCaseValueTypeName}/string`, 'Logic', `To ${camelCaseValueTypeName}`, (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, ['string'], valueTypeName, a => registry.values.get(valueTypeName).deserialize(a))), new NodeDescription(`math/toString/${valueTypeName}`, 'Logic', 'To String', (graph, nodeType) => new In1Out1FuncNode(graph, nodeType, [valueTypeName], 'string', a => registry.values.get(valueTypeName).serialize(a))));
+}
+
+// Unreal Engine Blueprint Time nodes: https://docs.unrealengine.com/4.27/en-US/BlueprintAPI/Utilities/Time/
+
+const Now = new NodeDescription('time/now', 'Logic', 'Now', (description, graph) => {
+  // ensure we do not leak current actual time, just time since initialization?
+  const startTime = Date.now();
+  return new In0Out1FuncNode(description, graph, 'float', () => (Date.now() - startTime) / 1000);
+});
+
+var TimeNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Now: Now
+});
+
+/* eslint-disable max-len */
+function registerCoreProfile(registry, logger = new DefaultLogger(), lifecycleEventEmitter = new ManualLifecycleEventEmitter()) {
+  const {
+    nodes,
+    values
+  } = registry;
+
+  // pull in value type nodes
+  values.register(BooleanValue);
+  values.register(StringValue);
+  values.register(IntegerValue);
+  values.register(FloatValue);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(StringNodes));
+  nodes.register(...getNodeDescriptions(BooleanNodes));
+  nodes.register(...getNodeDescriptions(IntegerNodes));
+  nodes.register(...getNodeDescriptions(FloatNodes));
+
+  // custom events
+
+  nodes.register(OnCustomEvent.Description);
+  nodes.register(TriggerCustomEvent.Description);
+
+  // variables
+
+  nodes.register(VariableGet.Description);
+  nodes.register(VariableSet.Description);
+
+  // complex logic
+
+  nodes.register(Easing.Description);
+
+  // actions
+
+  nodes.register(Log.Description(logger));
+  nodes.register(ExpectTrue.Description);
+
+  // events
+
+  nodes.register(LifecycleOnStart.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnEnd.Description(lifecycleEventEmitter));
+  nodes.register(LifecycleOnTick.Description(lifecycleEventEmitter));
+
+  // time
+
+  nodes.register(Delay.Description);
+  nodes.register(...getNodeDescriptions(TimeNodes));
+
+  // flow control
+
+  nodes.register(Branch.Description);
+  nodes.register(FlipFlop.Description);
+  nodes.register(ForLoop.Description);
+  nodes.register(Sequence.Description);
+  nodes.register(Debounce.Description);
+  nodes.register(Throttle.Description);
+  nodes.register(DoN.Description);
+  nodes.register(DoOnce.Description);
+  nodes.register(Gate.Description);
+  nodes.register(MultiGate.Description);
+  nodes.register(WaitAll.Description);
+  nodes.register(Counter.Description);
+
+  // string converters
+
+  ['boolean', 'float', 'integer'].forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+class Vec2 {
+  constructor(x = 0, y = 0) {
+    this.x = x;
+    this.y = y;
+  }
+  clone(result = new Vec2()) {
+    return result.set(this.x, this.y);
+  }
+  set(x, y) {
+    this.x = x;
+    this.y = y;
+    return this;
+  }
+}
+function vec2Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance);
+}
+function vec2Add(a, b, result = new Vec2()) {
+  return result.set(a.x + b.x, a.y + b.y);
+}
+function vec2Subtract(a, b, result = new Vec2()) {
+  return result.set(a.x - b.x, a.y - b.y);
+}
+function vec2MultiplyByScalar(a, b, result = new Vec2()) {
+  return result.set(a.x * b, a.y * b);
+}
+function vec2Negate(a, result = new Vec2()) {
+  return result.set(-a.x, -a.y);
+}
+function vec2Length(a) {
+  return Math.sqrt(vec2Dot(a, a));
+}
+function vec2Normalize(a, result = new Vec2()) {
+  const invLength = 1 / vec2Length(a);
+  return vec2MultiplyByScalar(a, invLength, result);
+}
+function vec2Dot(a, b) {
+  return a.x * b.x + a.y * b.y;
+}
+function vec2Mix(a, b, t, result = new Vec2()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t);
+}
+function vec2FromArray(array, offset = 0, result = new Vec2()) {
+  return result.set(array[offset + 0], array[offset + 1]);
+}
+function vec2ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+}
+function vec2ToString(a) {
+  return toSafeString([a.x, a.y]);
+}
+function vec2Parse(text, result = new Vec2()) {
+  return vec2FromArray(parseSafeFloats(text), 0, result);
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, 1 ) x [ 0  3  6 ] = ( x', y', 1 )
+//               [ 1  4  7 ]
+//               [ 2  5  8 ]
+// where elements 2 and 5 would be translation in 2D, as they would multiplied
+// by the last virtual element of the 2D vector.
+const NUM_ROWS$1 = 3;
+const NUM_COLUMNS$1 = 3;
+const NUM_ELEMENTS$1 = NUM_ROWS$1 * NUM_COLUMNS$1;
+class Mat3 {
+  constructor(elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat3()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS$1) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS$1}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat3SetColumn3(m, columnIndex, column, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  const base = columnIndex * NUM_ROWS$1;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  return result;
+}
+function mat3SetRow3(m, rowIndex, row, result = new Mat3()) {
+  const re = result.set(m.elements).elements;
+  re[rowIndex + NUM_COLUMNS$1 * 0] = row.x;
+  re[rowIndex + NUM_COLUMNS$1 * 1] = row.y;
+  re[rowIndex + NUM_COLUMNS$1 * 2] = row.z;
+  return result;
+}
+function column3ToMat3(a, b, c, result = new Mat3()) {
+  const re = result.elements;
+  const columns = [a, b, c];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS$1;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+  }
+  return result;
+}
+function mat3Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat3Add(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat3Subtract(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat3MultiplyByScalar(a, b, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat3Negate(a, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat3Multiply(a, b, result = new Mat3()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[3],
+    a13 = ae[6];
+  const a21 = ae[1],
+    a22 = ae[4],
+    a23 = ae[7];
+  const a31 = ae[2],
+    a32 = ae[5],
+    a33 = ae[8];
+  const b11 = be[0],
+    b12 = be[3],
+    b13 = be[6];
+  const b21 = be[1],
+    b22 = be[4],
+    b23 = be[7];
+  const b31 = be[2],
+    b32 = be[5],
+    b33 = be[8];
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31;
+  te[3] = a11 * b12 + a12 * b22 + a13 * b32;
+  te[6] = a11 * b13 + a12 * b23 + a13 * b33;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31;
+  te[4] = a21 * b12 + a22 * b22 + a23 * b32;
+  te[7] = a21 * b13 + a22 * b23 + a23 * b33;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31;
+  te[5] = a31 * b12 + a32 * b22 + a33 * b32;
+  te[8] = a31 * b13 + a32 * b23 + a33 * b33;
+  return result;
+}
+function mat3Determinant(m) {
+  const me = m.elements;
+  const a = me[0],
+    b = me[1],
+    c = me[2],
+    d = me[3],
+    e = me[4],
+    f = me[5],
+    g = me[6],
+    h = me[7],
+    i = me[8];
+  return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
+}
+function mat3Transpose(m, result = new Mat3()) {
+  const me = m.elements;
+  const te = result.elements;
+  te[0] = me[0];
+  te[4] = me[4];
+  te[8] = me[8];
+  te[1] = me[3];
+  te[3] = me[1];
+  te[2] = me[6];
+  te[6] = me[2];
+  te[5] = me[7];
+  te[7] = me[5];
+  return result;
+}
+function mat3Inverse(m, result = new Mat3()) {
+  const e = m.elements;
+  const n11 = e[0],
+    n21 = e[1],
+    n31 = e[2],
+    n12 = e[3],
+    n22 = e[4],
+    n32 = e[5],
+    n13 = e[6],
+    n23 = e[7],
+    n33 = e[8],
+    t11 = n33 * n22 - n32 * n23,
+    t12 = n32 * n13 - n33 * n12,
+    t13 = n23 * n12 - n22 * n13,
+    det = n11 * t11 + n21 * t12 + n31 * t13;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+  const re = result.elements;
+
+  // TODO: replace with a set
+  re[0] = t11 * detInv;
+  re[1] = (n31 * n23 - n33 * n21) * detInv;
+  re[2] = (n32 * n21 - n31 * n22) * detInv;
+  re[3] = t12 * detInv;
+  re[4] = (n33 * n11 - n31 * n13) * detInv;
+  re[5] = (n31 * n12 - n32 * n11) * detInv;
+  re[6] = t13 * detInv;
+  re[7] = (n21 * n13 - n23 * n11) * detInv;
+  re[8] = (n22 * n11 - n21 * n12) * detInv;
+  return result;
+}
+function mat3Mix(a, b, t, result = new Mat3()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat3FromArray(array, offset = 0, result = new Mat3()) {
+  for (let i = 0; i < NUM_ELEMENTS$1; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat3Parse(text, result = new Mat3()) {
+  return mat3FromArray(parseSafeFloats(text), 0, result);
+}
+function eulerToMat3(euler, result = new Mat3()) {
+  const te = result.elements;
+  const x = euler.x,
+    y = euler.y,
+    z = euler.z;
+  const a = Math.cos(x),
+    b = Math.sin(x);
+  const c = Math.cos(y),
+    d = Math.sin(y);
+  const e = Math.cos(z),
+    f = Math.sin(z);
+  const ae = a * e,
+    af = a * f,
+    be = b * e,
+    bf = b * f;
+  te[0] = c * e;
+  te[3] = -c * f;
+  te[6] = d;
+  te[1] = af + be * d;
+  te[4] = ae - bf * d;
+  te[7] = -b * c;
+  te[2] = bf - ae * d;
+  te[5] = be + af * d;
+  te[8] = a * c;
+  return result;
+}
+function quatToMat3(q, result = new Mat3()) {
+  const x = q.x,
+    y = q.y,
+    z = q.z,
+    w = q.w;
+  const x2 = x + x,
+    y2 = y + y,
+    z2 = z + z;
+  const xx = x * x2,
+    xy = x * y2,
+    xz = x * z2;
+  const yy = y * y2,
+    yz = y * z2,
+    zz = z * z2;
+  const wx = w * x2,
+    wy = w * y2,
+    wz = w * z2;
+  return result.set([1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy)]);
+}
+function scale2ToMat3(s, result = new Mat3()) {
+  return result.set([s.x, 0, 0, 0, s.y, 0, 0, 0, 1]);
+}
+// from gl-matrix
+function mat3ToScale2(m, result = new Vec2()) {
+  const mat = m.elements;
+  const m11 = mat[0];
+  const m12 = mat[1];
+  const m21 = mat[3];
+  const m22 = mat[4];
+  return result.set(Math.sqrt(m11 * m11 + m12 * m12), Math.sqrt(m21 * m21 + m22 * m22));
+}
+function translation2ToMat3(t, result = new Mat3()) {
+  return result.set([1, 0, t.x, 0, 1, t.y, 0, 0, 1]);
+}
+function mat3ToTranslation2(m, result = new Vec2()) {
+  return result.set(m.elements[2], m.elements[5]);
+}
+function mat4ToMat3(a, result = new Mat3()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], ae[4], ae[5], ae[6], ae[8], ae[9], ae[10]]);
+}
+
+class Vec3 {
+  constructor(x = 0, y = 0, z = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+  }
+  clone(result = new Vec3()) {
+    return result.set(this.x, this.y, this.z);
+  }
+  set(x, y, z) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    return this;
+  }
+}
+function vec3Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance);
+}
+function vec3Add(a, b, result = new Vec3()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z);
+}
+function vec3Subtract(a, b, result = new Vec3()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z);
+}
+function vec3MultiplyByScalar(a, b, result = new Vec3()) {
+  return result.set(a.x * b, a.y * b, a.z * b);
+}
+function vec3Negate(a, result = new Vec3()) {
+  return result.set(-a.x, -a.y, -a.z);
+}
+function vec3Length(a) {
+  return Math.sqrt(vec3Dot(a, a));
+}
+function vec3Normalize(a, result = new Vec3()) {
+  const invLength = 1 / vec3Length(a);
+  return vec3MultiplyByScalar(a, invLength, result);
+}
+function vec3Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+function vec3Cross(a, b, result = new Vec3()) {
+  const ax = a.x;
+  const ay = a.y;
+  const az = a.z;
+  const bx = b.x;
+  const by = b.y;
+  const bz = b.z;
+  return result.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
+}
+function vec3Mix(a, b, t, result = new Vec3()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t);
+}
+function vec3FromArray(array, offset = 0, result = new Vec3()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2]);
+}
+function vec3ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+}
+function vec3ToString(a) {
+  return toSafeString([a.x, a.y, a.z]);
+}
+function vec3Parse(text, result = new Vec3()) {
+  return vec3FromArray(parseSafeFloats(text), 0, result);
+}
+function hslToRGB(hsl, result = new Vec3()) {
+  function hue2rgb(p, q, t) {
+    if (t < 0) {
+      t += 1;
+    }
+    if (t > 1) {
+      t -= 1;
+    }
+    if (t < 1 / 6) {
+      return p + (q - p) * 6 * t;
+    }
+    if (t < 1 / 2) {
+      return q;
+    }
+    if (t < 2 / 3) {
+      return p + (q - p) * 6 * (2 / 3 - t);
+    }
+    return p;
+  }
+
+  // h,s,l ranges are in 0.0 - 1.0
+  const h = (hsl.x % 1 + 1) % 1; // euclidean modulo
+  const s = Math.min(Math.max(hsl.y, 0), 1);
+  const l = Math.min(Math.max(hsl.z, 0), 1);
+  if (s === 0) {
+    return result.set(1, 1, 1);
+  }
+  const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
+  const q = 2 * l - p;
+  return result.set(hue2rgb(q, p, h + 1 / 3), hue2rgb(q, p, h), hue2rgb(q, p, h - 1 / 3));
+}
+function rgbToHSL(rgb, result = new Vec3()) {
+  // h,s,l ranges are in 0.0 - 1.0
+  const r = rgb.x,
+    g = rgb.y,
+    b = rgb.z;
+  const max = Math.max(r, g, b);
+  const min = Math.min(r, g, b);
+  let hue = 0;
+  let saturation = 0;
+  const lightness = (min + max) / 2;
+  if (min === max) {
+    hue = 0;
+    saturation = 0;
+  } else {
+    const delta = max - min;
+    saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
+    switch (max) {
+      case r:
+        hue = (g - b) / delta + (g < b ? 6 : 0);
+        break;
+      case g:
+        hue = (b - r) / delta + 2;
+        break;
+      case b:
+        hue = (r - g) / delta + 4;
+        break;
+    }
+    hue /= 6;
+  }
+  return result.set(hue, saturation, lightness);
+}
+function hexToRGB(hex, result = new Vec3()) {
+  hex = Math.floor(hex);
+  return result.set((hex >> 16 & 255) / 255, (hex >> 8 & 255) / 255, (hex & 255) / 255);
+}
+function rgbToHex(rgb) {
+  return rgb.x * 255 << 16 ^ rgb.y * 255 << 8 ^ rgb.z * 255 << 0;
+}
+
+// from three.js
+function mat3ToEuler(m, result = new Vec3()) {
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  const te = m.elements;
+  const m11 = te[0],
+    m12 = te[3],
+    m13 = te[6];
+  te[1];
+    const m22 = te[4],
+    m23 = te[7];
+  te[2];
+    const m32 = te[5],
+    m33 = te[8];
+  result.y = Math.asin(clamp(m13, -1, 1));
+  if (Math.abs(m13) < 0.9999999) {
+    result.x = Math.atan2(-m23, m33);
+    result.z = Math.atan2(-m12, m11);
+  } else {
+    result.x = Math.atan2(m32, m22);
+    result.z = 0;
+  }
+  return result;
+}
+
+// from three.js
+function mat4ToEuler(m, result = new Vec3()) {
+  return mat3ToEuler(mat4ToMat3(m), result);
+}
+function quatToEuler(q, result = new Vec3()) {
+  return mat3ToEuler(quatToMat3(q), result);
+}
+
+const ColorValue = new ValueType('color', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const EulerValue = new ValueType('euler', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+class Vec4 {
+  constructor(x = 0, y = 0, z = 0, w = 0) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+  }
+  clone(result = new Vec4()) {
+    return result.set(this.x, this.y, this.z, this.w);
+  }
+  set(x, y, z, w) {
+    this.x = x;
+    this.y = y;
+    this.z = z;
+    this.w = w;
+    return this;
+  }
+}
+function vec4Equals(a, b, tolerance = EPSILON) {
+  return equalsTolerance(a.x, b.x, tolerance) && equalsTolerance(a.y, b.y, tolerance) && equalsTolerance(a.z, b.z, tolerance) && equalsTolerance(a.w, b.w, tolerance);
+}
+function vec4Add(a, b, result = new Vec4()) {
+  return result.set(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
+}
+function vec4Subtract(a, b, result = new Vec4()) {
+  return result.set(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
+}
+function vec4MultiplyByScalar(a, b, result = new Vec4()) {
+  return result.set(a.x * b, a.y * b, a.z * b, a.w * b);
+}
+function vec4Negate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, -a.w);
+}
+function vec4Length(a) {
+  return Math.sqrt(vec4Dot(a, a));
+}
+function vec4Normalize(a, result = new Vec4()) {
+  const invLength = 1 / vec4Length(a);
+  return vec4MultiplyByScalar(a, invLength, result);
+}
+function vec4Dot(a, b) {
+  return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
+}
+function vec4Mix(a, b, t, result = new Vec4()) {
+  const s = 1 - t;
+  return result.set(a.x * s + b.x * t, a.y * s + b.y * t, a.z * s + b.z * t, a.w * s + b.w * t);
+}
+function vec4FromArray(array, offset = 0, result = new Vec4()) {
+  return result.set(array[offset + 0], array[offset + 1], array[offset + 2], array[offset + 3]);
+}
+function vec4ToArray(a, array, offset = 0) {
+  array[offset + 0] = a.x;
+  array[offset + 1] = a.y;
+  array[offset + 2] = a.z;
+  array[offset + 3] = a.w;
+}
+function vec4ToString(a) {
+  return toSafeString([a.x, a.y, a.z, a.w]);
+}
+function vec4Parse(text, result = new Vec4()) {
+  return vec4FromArray(parseSafeFloats(text), 0, result);
+}
+function quatConjugate(a, result = new Vec4()) {
+  return result.set(-a.x, -a.y, -a.z, a.w);
+}
+function quatMultiply(a, b, result = new Vec4()) {
+  // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
+
+  const qax = a.x;
+  const qay = a.y;
+  const qaz = a.z;
+  const qaw = a.w;
+  const qbx = b.x;
+  const qby = b.y;
+  const qbz = b.z;
+  const qbw = b.w;
+  return result.set(qax * qbw + qaw * qbx + qay * qbz - qaz * qby, qay * qbw + qaw * qby + qaz * qbx - qax * qbz, qaz * qbw + qaw * qbz + qax * qby - qay * qbx, qaw * qbw - qax * qbx - qay * qby - qaz * qbz);
+}
+function quatSlerp(a, b, t, result = new Vec4()) {
+  if (t <= 0) return a.clone(result);
+  if (t >= 1) return b.clone(result);
+
+  // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
+
+  let cosHalfTheta = vec4Dot(a, b);
+  if (cosHalfTheta < 0) {
+    vec4Negate(b, result);
+    cosHalfTheta = -cosHalfTheta;
+  } else {
+    b.clone(result);
+  }
+  if (cosHalfTheta >= 1) {
+    return result;
+  }
+  const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
+  if (sqrSinHalfTheta <= Number.EPSILON) {
+    vec4Mix(a, result, t);
+    vec4Normalize(result, result);
+    return result;
+  }
+  const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
+  const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
+  const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
+  const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
+  result.w = a.w * ratioA + result.w * ratioB;
+  result.x = a.x * ratioA + result.x * ratioB;
+  result.y = a.y * ratioA + result.y * ratioB;
+  result.z = a.z * ratioA + result.z * ratioB;
+  return result;
+}
+
+/**
+ * Calculate the exponential of a unit quaternion.
+ *
+ * @param {quat} out the receiving quaternion
+ * @param {ReadonlyQuat} a quat to calculate the exponential of
+ * @returns {quat} out
+ */
+function quatExp(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const et = Math.exp(w);
+  const s = r > 0 ? et * Math.sin(r) / r : 0;
+  return result.set(x * s, y * s, z * s, et * Math.cos(r));
+}
+
+// from gl-matrix
+function quatLn(a, result = new Vec4()) {
+  const x = a.x,
+    y = a.y,
+    z = a.z,
+    w = a.w;
+  const r = Math.sqrt(x * x + y * y + z * z);
+  const t = r > 0 ? Math.atan2(r, w) / r : 0;
+  return result.set(x * t, y * t, z * t, 0.5 * Math.log(x * x + y * y + z * z + w * w));
+}
+
+// from gl-matrix
+function quatPow(a, b, result = new Vec4()) {
+  const ln = quatLn(a);
+  const lnScaled = vec4MultiplyByScalar(ln, b);
+  quatExp(lnScaled, result);
+  return result;
+}
+function eulerToQuat(euler, result = new Vec4()) {
+  // eslint-disable-next-line max-len
+  // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
+
+  const c1 = Math.cos(euler.x / 2);
+  const c2 = Math.cos(euler.y / 2);
+  const c3 = Math.cos(euler.z / 2);
+  const s1 = Math.sin(euler.x / 2);
+  const s2 = Math.sin(euler.y / 2);
+  const s3 = Math.sin(euler.z / 2);
+
+  // XYZ order only
+  return result.set(s1 * c2 * c3 + c1 * s2 * s3, c1 * s2 * c3 - s1 * c2 * s3, c1 * c2 * s3 + s1 * s2 * c3, c1 * c2 * c3 - s1 * s2 * s3);
+}
+function angleAxisToQuat(angle, axis, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
+
+  // assumes axis is normalized
+
+  const halfAngle = angle / 2;
+  const s = Math.sin(halfAngle);
+  return result.set(axis.x * s, axis.y * s, axis.z * s, Math.cos(halfAngle));
+}
+
+// from gl-matrix
+function quatToAngleAxis(q, result = new Vec3()) {
+  const rad = Math.acos(q.w) * 2;
+  const s = Math.sin(rad / 2);
+  if (s > EPSILON) {
+    result.x = q.x / s;
+    result.y = q.y / s;
+    result.z = q.z / s;
+  } else {
+    // If s is zero, return any axis (no rotation - axis does not matter)
+    result.x = 1;
+    result.y = 0;
+    result.z = 0;
+  }
+  return [rad, result];
+}
+function mat4ToQuat(m, result = new Vec4()) {
+  return mat3ToQuat(mat4ToMat3(m), result);
+}
+function mat3ToQuat(m, result = new Vec4()) {
+  // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
+
+  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
+
+  // TODO, allocate x, y, z, w and only set q.* at the end.
+
+  const te = m.elements,
+    m11 = te[0],
+    m12 = te[3],
+    m13 = te[6],
+    m21 = te[1],
+    m22 = te[4],
+    m23 = te[7],
+    m31 = te[2],
+    m32 = te[5],
+    m33 = te[8],
+    trace = m11 + m22 + m33;
+  if (trace > 0) {
+    const _s = 0.5 / Math.sqrt(trace + 1);
+    return result.set((m32 - m23) * _s, (m13 - m31) * _s, (m21 - m12) * _s, 0.25 / _s);
+  }
+  if (m11 > m22 && m11 > m33) {
+    const _s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
+    return result.set(0.25 * _s2, (m12 + m21) / _s2, (m13 + m31) / _s2, (m32 - m23) / _s2);
+  }
+  if (m22 > m33) {
+    const _s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
+    return result.set((m12 + m21) / _s3, 0.25 * _s3, (m23 + m32) / _s3, (m13 - m31) / _s3);
+  }
+  const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
+  return result.set((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
+}
+
+const QuatValue = new ValueType('quat', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => quatSlerp(start, end, t));
+
+const Vec2Value = new ValueType('vec2', () => new Vec2(), value => typeof value === 'string' ? vec2Parse(value) : new Vec2(value[0], value[1]), value => [value.x, value.y], (start, end, t) => vec2Mix(start, end, t));
+
+const Vec3Value = new ValueType('vec3', () => new Vec3(), value => typeof value === 'string' ? vec3Parse(value) : new Vec3(value[0], value[1], value[2]), value => [value.x, value.y, value.z], (start, end, t) => vec3Mix(start, end, t));
+
+const Vec4Value = new ValueType('vec4', () => new Vec4(), value => typeof value === 'string' ? vec4Parse(value) : new Vec4(value[0], value[1], value[2], value[3]), value => [value.x, value.y, value.z, value.w], (start, end, t) => vec4Mix(start, end, t));
+
+class DummyScene {
+  constructor() {
+    _defineProperty(this, "onSceneChanged", new EventEmitter());
+    _defineProperty(this, "valueRegistry", new ValueTypeRegistry());
+    const values = this.valueRegistry;
+    // pull in value type nodes
+    values.register(BooleanValue);
+    values.register(StringValue);
+    values.register(IntegerValue);
+    values.register(FloatValue);
+    values.register(Vec2Value);
+    values.register(Vec3Value);
+    values.register(Vec4Value);
+    values.register(ColorValue);
+    values.register(EulerValue);
+    values.register(QuatValue);
+  }
+  getProperty(jsonPath, valueTypeName) {
+    return this.valueRegistry.get(valueTypeName).creator();
+  }
+  setProperty() {
+    this.onSceneChanged.emit();
+  }
+  addOnClickedListener(jsonPath, callback) {
+    throw new Error('Method not implemented.');
+  }
+}
+
+class SetSceneProperty extends FlowNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/set/${valueTypeName}`, 'Action', `Set Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new SetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('flow', 'flow'), new Socket('string', 'jsonPath'), new Socket(valueTypeName, 'value')], [new Socket('flow', 'flow')]);
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+  triggered(fiber, triggeringSocketName) {
+    const scene = this.scene;
+    const value = this.readInput('value');
+    scene.setProperty(this.readInput('jsonPath'), this.valueTypeName, value);
+    fiber.commit(this, 'flow');
+  }
+}
+
+var _class;
+
+// very 3D specific.
+class OnSceneNodeClick extends EventNode {
+  constructor(description, graph) {
+    super(description, graph, [], [new Socket('flow', 'flow'), new Socket('float', 'nodeIndex')]);
+  }
+}
+_class = OnSceneNodeClick;
+_defineProperty(OnSceneNodeClick, "Description", new NodeDescription('scene/nodeClick', 'Event', 'On Node Click', (description, graph) => new _class(description, graph)));
+
+class VecElements extends ImmediateNode {
+  constructor(description, graph, valueTypeName, elementNames = ['x', 'y', 'z', 'w'], toArray) {
+    super(description, graph, [new Socket(valueTypeName, 'value')], elementNames.map(elementName => new Socket('float', elementName)), () => {
+      const value = this.readInput('value');
+      const elementValues = elementNames.map(() => 0);
+      toArray(value, elementValues, 0);
+      elementNames.forEach((elementName, index) => this.writeOutput(elementName, elementValues[index]));
+    });
+  }
+}
+
+class GetSceneProperty extends ImmediateNode {
+  static GetDescriptions(scene, ...valueTypeNames) {
+    return valueTypeNames.map(valueTypeName => new NodeDescription(`scene/get/${valueTypeName}`, 'Query', `Get Scene ${toCamelCase(valueTypeName)}`, (description, graph) => new GetSceneProperty(description, graph, valueTypeName, scene)));
+  }
+  constructor(description, graph, valueTypeName, scene) {
+    super(description, graph, [new Socket('string', 'jsonPath')], [new Socket(valueTypeName, 'value')], () => {
+      this.writeOutput('value', this.scene.getProperty(this.readInput('jsonPath'), valueTypeName));
+    });
+    this.valueTypeName = valueTypeName;
+    this.scene = scene;
+  }
+}
+
+const Constant$7 = new NodeDescription('math/color', 'Logic', 'Color', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', a => a));
+const Create$5 = new NodeDescription('math/toColor/rgb', 'Logic', 'RGB To Color', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'color', (r, g, b) => new Vec3(r, g, b), ['r', 'g', 'b']));
+const Elements$7 = new NodeDescription('math/toRgb/color', 'Logic', 'Color to RGB', (description, graph) => new VecElements(description, graph, 'color', ['r', 'g', 'b'], vec3ToArray));
+const Add$6 = new NodeDescription('math/add/color', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Add));
+const Subtract$6 = new NodeDescription('math/subtract/color', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'color'], 'color', vec3Subtract));
+const Negate$7 = new NodeDescription('math/negate/color', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'color', vec3Negate));
+const Scale$7 = new NodeDescription('math/scale/color', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['color', 'float'], 'color', vec3MultiplyByScalar));
+const Mix$6 = new NodeDescription('math/mix/color', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'color', vec3Mix, ['a', 'b', 't']));
+const HslToColor = new NodeDescription('math/ToColor/hsl', 'Logic', 'HSL to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'color', hslToRGB));
+const ColorToHsl = new NodeDescription('math/toHsl/color', 'Logic', 'Color to HSL', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'vec3', rgbToHSL));
+const HexToColor = new NodeDescription('math/toColor/hex', 'Logic', 'HEX to Color', (description, graph) => new In1Out1FuncNode(description, graph, ['float'], 'color', hexToRGB));
+const ColorToHex = new NodeDescription('math/toHex/color', 'Logic', 'Color to HEX', (description, graph) => new In1Out1FuncNode(description, graph, ['color'], 'float', rgbToHex));
+const Equal$7 = new NodeDescription('math/equal/color', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['color', 'color', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var ColorNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$7,
+  Create: Create$5,
+  Elements: Elements$7,
+  Add: Add$6,
+  Subtract: Subtract$6,
+  Negate: Negate$7,
+  Scale: Scale$7,
+  Mix: Mix$6,
+  HslToColor: HslToColor,
+  ColorToHsl: ColorToHsl,
+  HexToColor: HexToColor,
+  ColorToHex: ColorToHex,
+  Equal: Equal$7
+});
+
+const Constant$6 = new NodeDescription('math/euler', 'Logic', 'Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', a => a));
+const Create$4 = new NodeDescription('math/toEuler/float', 'Logic', 'Float to Euler', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'euler', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$6 = new NodeDescription('math/toFloat/euler', 'Logic', 'Euler to Float', (description, graph) => new VecElements(description, graph, 'euler', ['x', 'y', 'z'], vec3ToArray));
+const Add$5 = new NodeDescription('math/add/euler', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Add));
+const Subtract$5 = new NodeDescription('math/subtract/euler', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'euler'], 'euler', vec3Subtract));
+const Negate$6 = new NodeDescription('math/negate/euler', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'euler', vec3Negate));
+const Scale$6 = new NodeDescription('math/scale/euler', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['euler', 'float'], 'euler', vec3MultiplyByScalar));
+const Mix$5 = new NodeDescription('math/mix/euler', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'euler', vec3Mix, ['a', 'b', 't']));
+const Mat3ToEuler = new NodeDescription('math/toEuler/mat3', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'euler', mat3ToEuler));
+const Mat4ToEuler = new NodeDescription('math/toEuler/mat4', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'euler', mat4ToEuler));
+const QuatToEuler = new NodeDescription('math/toEuler/quat', 'Logic', 'To Euler', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'euler', quatToEuler));
+const Equal$6 = new NodeDescription('math/equal/euler', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['euler', 'euler', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var EulerNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$6,
+  Create: Create$4,
+  Elements: Elements$6,
+  Add: Add$5,
+  Subtract: Subtract$5,
+  Negate: Negate$6,
+  Scale: Scale$6,
+  Mix: Mix$5,
+  Mat3ToEuler: Mat3ToEuler,
+  Mat4ToEuler: Mat4ToEuler,
+  QuatToEuler: QuatToEuler,
+  Equal: Equal$6
+});
+
+const Constant$5 = new NodeDescription('math/vec2', 'Logic', 'Vec2', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', a => a));
+const Create$3 = new NodeDescription('math/toVec2/float', 'Logic', 'Float to Vec2', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'float'], 'vec2', (x, y) => new Vec2(x, y), ['x', 'y']));
+const Elements$5 = new NodeDescription('math/toFloat/vec2', 'Logic', 'Vec2 To Float', (description, graph) => new VecElements(description, graph, 'vec2', ['x', 'y', 'z'], vec2ToArray));
+const Add$4 = new NodeDescription('math/add/vec2', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Add));
+const Subtract$4 = new NodeDescription('math/subtract/vec2', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'vec2', vec2Subtract));
+const Negate$5 = new NodeDescription('math/negate/vec2', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Negate));
+const Scale$5 = new NodeDescription('math/scale/vec2', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'float'], 'vec2', vec2MultiplyByScalar));
+const Length$3 = new NodeDescription('math/length/vec2', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'float', vec2Length));
+const Normalize$3 = new NodeDescription('math/normalize/vec2', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'vec2', vec2Normalize));
+const Dot$3 = new NodeDescription('math/dot/vec2', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec2', 'vec2'], 'float', vec2Dot));
+const Mix$4 = new NodeDescription('math/mix/vec2', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'vec2', vec2Mix, ['a', 'b', 't']));
+const Equal$5 = new NodeDescription('math/equal/vec2', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec2', 'vec2', 'float'], 'boolean', vec2Equals, ['a', 'b', 'tolerance']));
+
+var Vec2Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$5,
+  Create: Create$3,
+  Elements: Elements$5,
+  Add: Add$4,
+  Subtract: Subtract$4,
+  Negate: Negate$5,
+  Scale: Scale$5,
+  Length: Length$3,
+  Normalize: Normalize$3,
+  Dot: Dot$3,
+  Mix: Mix$4,
+  Equal: Equal$5
+});
+
+const Constant$4 = new NodeDescription('math/vec3', 'Logic', 'Vec3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', a => a));
+const Create$2 = new NodeDescription('math/toVec3/float', 'Logic', 'Float to Vec3', (description, graph) => new In3Out1FuncNode(description, graph, ['float', 'float', 'float'], 'vec3', (x, y, z) => new Vec3(x, y, z), ['x', 'y', 'z']));
+const Elements$4 = new NodeDescription('math/toFloat/vec3', 'Logic', 'Vec3 To Float', (description, graph) => new VecElements(description, graph, 'vec3', ['x', 'y', 'z'], vec3ToArray));
+const Add$3 = new NodeDescription('math/add/vec3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Add));
+const Subtract$3 = new NodeDescription('math/subtract/vec3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Subtract));
+const Negate$4 = new NodeDescription('math/negate/vec3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Negate));
+const Scale$4 = new NodeDescription('math/scale/vec3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'float'], 'vec3', vec3MultiplyByScalar));
+const Length$2 = new NodeDescription('math/length/vec3', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'float', vec3Length));
+const Normalize$2 = new NodeDescription('math/normalize/vec3', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'vec3', vec3Normalize));
+const Cross = new NodeDescription('math/cross/vec3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'vec3', vec3Cross));
+const Dot$2 = new NodeDescription('math/dot/vec3', 'Logic', 'Dot', (description, graph) => new In2Out1FuncNode(description, graph, ['vec3', 'vec3'], 'float', vec3Dot));
+const Mix$3 = new NodeDescription('math/mix/vec3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'vec3', vec3Mix, ['a', 'b', 't']));
+const Equal$4 = new NodeDescription('math/equal/vec3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'float'], 'boolean', vec3Equals, ['a', 'b', 'tolerance']));
+
+var Vec3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$4,
+  Create: Create$2,
+  Elements: Elements$4,
+  Add: Add$3,
+  Subtract: Subtract$3,
+  Negate: Negate$4,
+  Scale: Scale$4,
+  Length: Length$2,
+  Normalize: Normalize$2,
+  Cross: Cross,
+  Dot: Dot$2,
+  Mix: Mix$3,
+  Equal: Equal$4
+});
+
+const Constant$3 = new NodeDescription('math/vec4', 'Logic', 'Vec4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', a => a));
+const Create$1 = new NodeDescription('math/toVec4/float', 'Logic', 'Float to Vec4', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'vec4', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$3 = new NodeDescription('math/toFloat/vec4', 'Logic', 'Vec4 to Float', (description, graph) => new VecElements(description, graph, 'vec4', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Add$2 = new NodeDescription('math/add/vec4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Add));
+const Subtract$2 = new NodeDescription('math/subtract/vec4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'vec4', vec4Subtract));
+const Negate$3 = new NodeDescription('math/negate/vec4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Negate));
+const Scale$3 = new NodeDescription('math/scale/vec4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'float'], 'vec4', vec4MultiplyByScalar));
+const Length$1 = new NodeDescription('math/length/vec4', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'float', vec4Length));
+const Normalize$1 = new NodeDescription('math/normalize/vec4', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['vec4'], 'vec4', vec4Normalize));
+const Dot$1 = new NodeDescription('math/dot/vec4', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['vec4', 'vec4'], 'float', vec4Dot));
+const Mix$2 = new NodeDescription('math/mix/vec4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'vec4', vec4Mix, ['a', 'b', 't']));
+const Equal$3 = new NodeDescription('math/equal/vec4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['vec4', 'vec4', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var Vec4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$3,
+  Create: Create$1,
+  Elements: Elements$3,
+  Add: Add$2,
+  Subtract: Subtract$2,
+  Negate: Negate$3,
+  Scale: Scale$3,
+  Length: Length$1,
+  Normalize: Normalize$1,
+  Dot: Dot$1,
+  Mix: Mix$2,
+  Equal: Equal$3
+});
+
+/*
+- from Angle Axis
+- from Euler
+- to Angle Axis
+- to Euler
+- Conjugate
+- Multiply
+- Slerp
+- Squad
+- Scale
+- 
+*/
+
+const Constant$2 = new NodeDescription('math/quat', 'Logic', 'Quaternion', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', a => a));
+const Create = new NodeDescription('math/toQuat/float', 'Logic', 'Float to Quat', (description, graph) => new In4Out1FuncNode(description, graph, ['float', 'float', 'float', 'float'], 'quat', (x, y, z, w) => new Vec4(x, y, z, w), ['x', 'y', 'z', 'w']));
+const Elements$2 = new NodeDescription('math/toFloat/quat', 'Logic', 'Quat to Float', (description, graph) => new VecElements(description, graph, 'quat', ['x', 'y', 'z', 'w'], vec4ToArray));
+const Negate$2 = new NodeDescription('math/conjugate/quat', 'Logic', 'Conjugate', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatConjugate));
+const Multiply$2 = new NodeDescription('math/multiply/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'quat', quatMultiply));
+const Scale$2 = new NodeDescription('math/scale/quat', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', vec4MultiplyByScalar));
+const Length = new NodeDescription('math/length/quat', 'Logic', 'Length', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'float', vec4Length));
+const Normalize = new NodeDescription('math/normalize/quat', 'Logic', 'Normalize', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', vec4Normalize));
+const Dot = new NodeDescription('math/dot/quat', 'Logic', 'Dot Product', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'quat'], 'float', vec4Dot));
+const Ln = new NodeDescription('math/ln/quat', 'Logic', 'Ln', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatLn));
+const Exp = new NodeDescription('math/exp/quat', 'Logic', 'Exp', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'quat', quatExp));
+const Pow = new NodeDescription('math/pow/quat', 'Logic', 'Pow', (description, graph) => new In2Out1FuncNode(description, graph, ['quat', 'float'], 'quat', quatPow));
+const Mat3ToQuat = new NodeDescription('math/toQuat/mat3', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'quat', mat3ToQuat));
+const Mat4ToQuat = new NodeDescription('math/toQuat/mat4', 'Logic', 'To Quat', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'quat', mat4ToQuat));
+const EulerToQuat = new NodeDescription('math/toQuat/euler', 'Logic', '', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'quat', eulerToQuat));
+const AngleAxisToQuat = new NodeDescription('math/toQuat/angleAxis', 'Logic', 'Angle Axis to Quat', (description, graph) => new In2Out1FuncNode(description, graph, ['float', 'vec3'], 'quat', angleAxisToQuat));
+const Slerp = new NodeDescription('math/slerp/quat', 'Logic', 'Slerp', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'quat', quatSlerp, ['a', 'b', 't']));
+const Equal$2 = new NodeDescription('math/equal/quat', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['quat', 'quat', 'float'], 'boolean', vec4Equals, ['a', 'b', 'tolerance']));
+
+var QuatNodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$2,
+  Create: Create,
+  Elements: Elements$2,
+  Negate: Negate$2,
+  Multiply: Multiply$2,
+  Scale: Scale$2,
+  Length: Length,
+  Normalize: Normalize,
+  Dot: Dot,
+  Ln: Ln,
+  Exp: Exp,
+  Pow: Pow,
+  Mat3ToQuat: Mat3ToQuat,
+  Mat4ToQuat: Mat4ToQuat,
+  EulerToQuat: EulerToQuat,
+  AngleAxisToQuat: AngleAxisToQuat,
+  Slerp: Slerp,
+  Equal: Equal$2
+});
+
+const Constant$1 = new NodeDescription('math/mat3', 'Logic', 'Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', a => a));
+const Column3ToMat3 = new NodeDescription('math/toMat3/column3', 'Logic', 'Columns to Mat3', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat3', column3ToMat3));
+const SetColumn$1 = new NodeDescription('math/setColumn/mat3', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetColumn3));
+const SetRow$1 = new NodeDescription('math/setRow/mat3', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'integer', 'vec3'], 'mat3', mat3SetRow3));
+const Elements$1 = new NodeDescription('math/toVec3/mat3', 'Logic', 'Mat3 To Vec3', (description, graph) => new VecElements(description, graph, 'mat3', ['x', 'y', 'z'], () => {
+  throw new Error('not implemented');
+}));
+const Add$1 = new NodeDescription('math/add/mat3', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Add));
+const Subtract$1 = new NodeDescription('math/subtract/mat3', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Subtract));
+const Negate$1 = new NodeDescription('math/negate/mat3', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Negate));
+const Scale$1 = new NodeDescription('math/scale/mat3', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'float'], 'mat3', mat3MultiplyByScalar));
+const Determinant$1 = new NodeDescription('math/determinant/mat3', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'float', mat3Determinant));
+const Inverse$1 = new NodeDescription('math/inverse/mat3', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Inverse));
+const Mat4ToMat3 = new NodeDescription('math/toMat3/mat4', 'Logic', 'Mat4 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat3', mat4ToMat3));
+const Transpose$1 = new NodeDescription('math/transpose/mat3', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat3', mat3Transpose));
+const Multiply$1 = new NodeDescription('math/multiply/mat3', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat3', 'mat3'], 'mat3', mat3Multiply));
+const Mix$1 = new NodeDescription('math/mix/mat3', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'mat3', mat3Mix, ['a', 'b', 't']));
+const Equal$1 = new NodeDescription('math/equal/mat3', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat3', 'mat3', 'float'], 'boolean', mat3Equals, ['a', 'b', 'tolerance']));
+const EulerToMat3 = new NodeDescription('math/toMat3/euler', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat3', eulerToMat3));
+const QuatToMat3 = new NodeDescription('math/toMat3/quat', 'Logic', 'To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat3', eulerToMat3));
+const Scale2ToMat3 = new NodeDescription('math/toMat3/scale2', 'Logic', 'Scale2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', scale2ToMat3));
+const Mat3ToScale2 = new NodeDescription('math/toScale2/mat3', 'Logic', 'Mat3 to Scale2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToScale2));
+const Translation2ToMat3 = new NodeDescription('math/toMat3/translation2', 'Logic', 'Translation2 To Mat3', (description, graph) => new In1Out1FuncNode(description, graph, ['vec2'], 'mat3', translation2ToMat3));
+const Mat3ToTranslation3 = new NodeDescription('math/toTranslation2/mat3', 'Logic', 'Mat3 to Translation2', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'vec2', mat3ToTranslation2));
+
+var Mat3Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant$1,
+  Column3ToMat3: Column3ToMat3,
+  SetColumn: SetColumn$1,
+  SetRow: SetRow$1,
+  Elements: Elements$1,
+  Add: Add$1,
+  Subtract: Subtract$1,
+  Negate: Negate$1,
+  Scale: Scale$1,
+  Determinant: Determinant$1,
+  Inverse: Inverse$1,
+  Mat4ToMat3: Mat4ToMat3,
+  Transpose: Transpose$1,
+  Multiply: Multiply$1,
+  Mix: Mix$1,
+  Equal: Equal$1,
+  EulerToMat3: EulerToMat3,
+  QuatToMat3: QuatToMat3,
+  Scale2ToMat3: Scale2ToMat3,
+  Mat3ToScale2: Mat3ToScale2,
+  Translation2ToMat3: Translation2ToMat3,
+  Mat3ToTranslation3: Mat3ToTranslation3
+});
+
+const Mat3Value = new ValueType('mat3', () => new Mat3(), value => typeof value === 'string' ? mat3Parse(value) : new Mat3(value), value => value.elements, (start, end, t) => mat3Mix(start, end, t));
+
+class In5Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e']) {
+    if (inputValueTypes.length !== 5) {
+      throw new Error(`inputValueTypes of ${description.typeName}  must have a length of 5, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 5) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 5, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+class In6Out1FuncNode extends ImmediateNode {
+  constructor(description, graph, inputValueTypes, outputValueType, evalFunc, inputNames = ['a', 'b', 'c', 'd', 'e', 'f']) {
+    if (inputValueTypes.length !== 6) {
+      throw new Error(`inputValueTypes of ${description.typeName} must have a length of 6, it is instead ${inputValueTypes.length}`);
+    }
+    if (inputNames.length !== 6) {
+      throw new Error(`inputNames of ${description.typeName}  must have a length of 6, it is instead ${inputNames.length}`);
+    }
+    super(description, graph, [new Socket(inputValueTypes[0], inputNames[0]), new Socket(inputValueTypes[1], inputNames[1]), new Socket(inputValueTypes[2], inputNames[2]), new Socket(inputValueTypes[3], inputNames[3]), new Socket(inputValueTypes[4], inputNames[4]), new Socket(inputValueTypes[5], inputNames[5])], [new Socket(outputValueType, 'result')], () => {
+      this.writeOutput('result', this.evalFunc(this.readInput(inputNames[0]), this.readInput(inputNames[1]), this.readInput(inputNames[2]), this.readInput(inputNames[3]), this.readInput(inputNames[4]), this.readInput(inputNames[5])));
+    });
+    this.evalFunc = evalFunc;
+    this.inputNames = inputNames;
+  }
+}
+
+// uses OpenGL matrix layout where each column is specified subsequently in order from left to right.
+// ( x, y, z, 1 ) x [ 0  4   8  12] = ( x', y', z', 1 )
+//                  [ 1  5   9  13]
+//                  [ 2  6  10  14]
+//                  [ 3  7  11  15]
+// where elements 3, 7, 11 would be translation in 3D, as they would multiplied
+// by the last virtual element of the 3D vector.
+const NUM_ROWS = 4;
+const NUM_COLUMNS = 4;
+const NUM_ELEMENTS = NUM_ROWS * NUM_COLUMNS;
+class Mat4 {
+  constructor(elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {
+    this.elements = elements;
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+  }
+  clone(result = new Mat4()) {
+    return result.set(this.elements);
+  }
+  set(elements) {
+    if (elements.length !== NUM_ELEMENTS) {
+      throw new Error(`elements must have length ${NUM_ELEMENTS}, got ${elements.length}`);
+    }
+    for (let i = 0; i < NUM_ELEMENTS; i++) {
+      this.elements[i] = elements[i];
+    }
+    return this;
+  }
+}
+function mat4SetColumn4(m, columnIndex, column, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(columnIndex) * NUM_ROWS;
+  re[base + 0] = column.x;
+  re[base + 1] = column.y;
+  re[base + 2] = column.z;
+  re[base + 3] = column.w;
+  return result;
+}
+function mat4SetRow4(m, rowIndex, row, result = new Mat4()) {
+  const re = result.set(m.elements).elements;
+  const base = Number(rowIndex);
+  re[base + NUM_COLUMNS * 0] = row.x;
+  re[base + NUM_COLUMNS * 1] = row.y;
+  re[base + NUM_COLUMNS * 2] = row.z;
+  re[base + NUM_COLUMNS * 3] = row.w;
+  return result;
+}
+function column4ToMat4(a, b, c, d, result = new Mat4()) {
+  const re = result.elements;
+  const columns = [a, b, c, d];
+  for (let _c = 0; _c < columns.length; _c++) {
+    const base = _c * NUM_ROWS;
+    const column = columns[_c];
+    re[base + 0] = column.x;
+    re[base + 1] = column.y;
+    re[base + 2] = column.z;
+    re[base + 3] = column.w;
+  }
+  return result;
+}
+function mat4Equals(a, b, tolerance = EPSILON) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    if (!equalsTolerance(a.elements[i], b.elements[i], tolerance)) return false;
+  }
+  return true;
+}
+function mat4Add(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] + b.elements[i];
+  }
+  return result;
+}
+function mat4Subtract(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] - b.elements[i];
+  }
+  return result;
+}
+function mat4MultiplyByScalar(a, b, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * b;
+  }
+  return result;
+}
+function mat4Negate(a, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = -a.elements[i];
+  }
+  return result;
+}
+function mat4Multiply(a, b, result = new Mat4()) {
+  const ae = a.elements;
+  const be = b.elements;
+  const te = result.elements;
+  const a11 = ae[0],
+    a12 = ae[4],
+    a13 = ae[8],
+    a14 = ae[12];
+  const a21 = ae[1],
+    a22 = ae[5],
+    a23 = ae[9],
+    a24 = ae[13];
+  const a31 = ae[2],
+    a32 = ae[6],
+    a33 = ae[10],
+    a34 = ae[14];
+  const a41 = ae[3],
+    a42 = ae[7],
+    a43 = ae[11],
+    a44 = ae[15];
+  const b11 = be[0],
+    b12 = be[4],
+    b13 = be[8],
+    b14 = be[12];
+  const b21 = be[1],
+    b22 = be[5],
+    b23 = be[9],
+    b24 = be[13];
+  const b31 = be[2],
+    b32 = be[6],
+    b33 = be[10],
+    b34 = be[14];
+  const b41 = be[3],
+    b42 = be[7],
+    b43 = be[11],
+    b44 = be[15];
+
+  // TODO: Replace with set(...)
+  te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
+  te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
+  te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
+  te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
+  te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
+  te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
+  te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
+  te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
+  te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
+  te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
+  te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
+  te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
+  te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
+  te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
+  te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
+  te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
+  return result;
+}
+function mat4Determinant(m) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  return n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+}
+function mat4Adjoint(m, result = new Mat4()) {
+  // from gl-matrix
+  const a = m.elements;
+  const out = result.elements;
+  const a00 = a[0],
+    a01 = a[1],
+    a02 = a[2],
+    a03 = a[3];
+  const a10 = a[4],
+    a11 = a[5],
+    a12 = a[6],
+    a13 = a[7];
+  const a20 = a[8],
+    a21 = a[9],
+    a22 = a[10],
+    a23 = a[11];
+  const a30 = a[12],
+    a31 = a[13],
+    a32 = a[14],
+    a33 = a[15];
+  const b00 = a00 * a11 - a01 * a10;
+  const b01 = a00 * a12 - a02 * a10;
+  const b02 = a00 * a13 - a03 * a10;
+  const b03 = a01 * a12 - a02 * a11;
+  const b04 = a01 * a13 - a03 * a11;
+  const b05 = a02 * a13 - a03 * a12;
+  const b06 = a20 * a31 - a21 * a30;
+  const b07 = a20 * a32 - a22 * a30;
+  const b08 = a20 * a33 - a23 * a30;
+  const b09 = a21 * a32 - a22 * a31;
+  const b10 = a21 * a33 - a23 * a31;
+  const b11 = a22 * a33 - a23 * a32;
+  out[0] = a11 * b11 - a12 * b10 + a13 * b09;
+  out[1] = a02 * b10 - a01 * b11 - a03 * b09;
+  out[2] = a31 * b05 - a32 * b04 + a33 * b03;
+  out[3] = a22 * b04 - a21 * b05 - a23 * b03;
+  out[4] = a12 * b08 - a10 * b11 - a13 * b07;
+  out[5] = a00 * b11 - a02 * b08 + a03 * b07;
+  out[6] = a32 * b02 - a30 * b05 - a33 * b01;
+  out[7] = a20 * b05 - a22 * b02 + a23 * b01;
+  out[8] = a10 * b10 - a11 * b08 + a13 * b06;
+  out[9] = a01 * b08 - a00 * b10 - a03 * b06;
+  out[10] = a30 * b04 - a31 * b02 + a33 * b00;
+  out[11] = a21 * b02 - a20 * b04 - a23 * b00;
+  out[12] = a11 * b07 - a10 * b09 - a12 * b06;
+  out[13] = a00 * b09 - a01 * b07 + a02 * b06;
+  out[14] = a31 * b01 - a30 * b03 - a32 * b00;
+  out[15] = a20 * b03 - a21 * b01 + a22 * b00;
+  return result;
+}
+function mat4Transpose(m, result = new Mat4()) {
+  const re = m.clone(result).elements;
+  let tmp;
+
+  // TODO: replace this with just reading from me and setting re, no need for a temporary
+  tmp = re[1];
+  re[1] = re[4];
+  re[4] = tmp;
+  tmp = re[2];
+  re[2] = re[8];
+  re[8] = tmp;
+  tmp = re[6];
+  re[6] = re[9];
+  re[9] = tmp;
+  tmp = re[3];
+  re[3] = re[12];
+  re[12] = tmp;
+  tmp = re[7];
+  re[7] = re[13];
+  re[13] = tmp;
+  tmp = re[11];
+  re[11] = re[14];
+  re[14] = tmp;
+  return result;
+}
+function mat4Inverse(m, result = new Mat4()) {
+  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
+  const me = m.elements,
+    n11 = me[0],
+    n21 = me[1],
+    n31 = me[2],
+    n41 = me[3],
+    n12 = me[4],
+    n22 = me[5],
+    n32 = me[6],
+    n42 = me[7],
+    n13 = me[8],
+    n23 = me[9],
+    n33 = me[10],
+    n43 = me[11],
+    n14 = me[12],
+    n24 = me[13],
+    n34 = me[14],
+    n44 = me[15],
+    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
+    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
+    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
+    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
+  const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
+  if (det === 0) {
+    throw new Error('can not invert degenerate matrix');
+  }
+  const detInv = 1 / det;
+
+  // TODO: replace with a set
+  const re = result.elements;
+  re[0] = t11 * detInv;
+  re[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
+  re[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
+  re[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
+  re[4] = t12 * detInv;
+  re[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
+  re[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
+  re[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
+  re[8] = t13 * detInv;
+  re[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
+  re[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
+  re[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
+  re[12] = t14 * detInv;
+  re[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
+  re[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
+  re[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
+  return result;
+}
+function mat4Mix(a, b, t, result = new Mat4()) {
+  const s = 1 - t;
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = a.elements[i] * s + b.elements[i] * t;
+  }
+  return result;
+}
+function mat4FromArray(array, offset = 0, result = new Mat4()) {
+  for (let i = 0; i < NUM_ELEMENTS; i++) {
+    result.elements[i] = array[offset + i];
+  }
+  return result;
+}
+function mat4Parse(text, result = new Mat4()) {
+  return mat4FromArray(parseSafeFloats(text), 0, result);
+}
+function mat3ToMat4(a, result = new Mat4()) {
+  const ae = a.elements;
+  return result.set([ae[0], ae[1], ae[2], 0, ae[3], ae[4], ae[5], 0, ae[6], ae[7], ae[8], 0, 0, 0, 0, 1]);
+}
+function eulerToMat4(e, result = new Mat4()) {
+  return mat3ToMat4(eulerToMat3(e), result);
+}
+function quatToMat4(q, result = new Mat4()) {
+  return mat3ToMat4(quatToMat3(q), result);
+}
+function scale3ToMat4(s, result = new Mat4()) {
+  return result.set([s.x, 0, 0, 0, 0, s.y, 0, 0, 0, 0, s.z, 0, 0, 0, 0, 1]);
+}
+function translation3ToMat4(t, result = new Mat4()) {
+  return result.set([1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1]);
+}
+function mat4Translate(m, t, result = new Mat4()) {
+  return mat4Multiply(m, translation3ToMat4(t), result);
+}
+function mat4Scale(m, s, result = new Mat4()) {
+  return mat4Multiply(m, scale3ToMat4(s), result);
+}
+function mat4RotateByQuat(m, q, result = new Mat4()) {
+  return mat4Multiply(m, quatToMat4(q), result);
+}
+function mat4RotateByEuler(m, e, result = new Mat4()) {
+  return mat4Multiply(m, eulerToMat4(e), result);
+}
+function mat4TransformPoint3(m, v, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
+  result.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
+  result.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
+  result.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
+  return result;
+}
+function mat4TransformNormal3(v, m, result = new Vec3()) {
+  const x = v.x,
+    y = v.y,
+    z = v.z;
+  const e = m.elements;
+  result.x = e[0] * x + e[4] * y + e[8] * z;
+  result.y = e[1] * x + e[5] * y + e[9] * z;
+  result.z = e[2] * x + e[6] * y + e[10] * z;
+  return vec3Normalize(result, result);
+}
+function mat4Perspective(left, right, top, bottom, near, far, result = new Mat4()) {
+  const x = 2 * near / (right - left);
+  const y = 2 * near / (top - bottom);
+  const a = (right + left) / (right - left);
+  const b = (top + bottom) / (top - bottom);
+  const c = -(far + near) / (far - near);
+  const d = -2 * far * near / (far - near);
+  return result.set([x, 0, a, 0, 0, y, b, 0, 0, 0, c, d, 0, 0, -1, 0]);
+}
+function mat4PerspectiveFov(verticalFov, near, far, zoom, aspectRatio, result = new Mat4()) {
+  const height = 2 * near * Math.tan(verticalFov * Math.PI / 180) / zoom;
+  const width = height * aspectRatio;
+
+  // NOTE: OpenGL screen coordinates are -bottomt to +top, -left to +right.
+
+  const right = width * 0.5;
+  const left = right - width;
+  const top = height * 0.5;
+  const bottom = top - height;
+  return mat4Perspective(left, right, top, bottom, near, far, result);
+}
+
+// TODO: Replace with a Box3?
+function mat4Orthogonal(left, right, top, bottom, near, far, result = new Mat4()) {
+  const w = 1 / (right - left);
+  const h = 1 / (top - bottom);
+  const p = 1 / (far - near);
+  const x = (right + left) * w;
+  const y = (top + bottom) * h;
+  const z = (far + near) * p;
+  return result.set([2 * w, 0, 0, -x, 0, 2 * h, 0, -y, 0, 0, -2 * p, -z, 0, 0, 0, 1]);
+}
+function mat4OrthogonalSimple(height, center, near, far, zoom, aspectRatio = 1, result = new Mat4()) {
+  height /= zoom;
+  const width = height * aspectRatio;
+  const left = -width * 0.5 + center.x;
+  const right = left + width;
+  const top = -height * 0.5 + center.y;
+  const bottom = top + height;
+  return mat4Orthogonal(left, right, top, bottom, near, far, result);
+}
+function mat4LookAt(eye, target, up, result = new Mat4()) {
+  const te = result.elements;
+  const look = vec3Subtract(eye, target);
+  const lookLength = vec3Length(look);
+  if (lookLength === 0) {
+    look.z = 1;
+  } else {
+    vec3MultiplyByScalar(look, 1 / lookLength, look);
+  }
+  const right = vec3Cross(up, look);
+  const rightLength = vec3Length(right);
+  if (rightLength === 0) {
+    // up and z are parallel
+
+    if (Math.abs(up.z) === 1) {
+      up.x += 0.0001;
+    } else {
+      up.z += 0.0001;
+    }
+    vec3Normalize(up, up);
+    vec3Cross(right, up, right);
+  } else {
+    vec3MultiplyByScalar(right, 1 / rightLength, right);
+  }
+  const up2 = vec3Cross(look, right);
+  te[0] = right.x;
+  te[4] = up2.x;
+  te[8] = look.x;
+  te[1] = right.y;
+  te[5] = up2.y;
+  te[9] = look.y;
+  te[2] = right.z;
+  te[6] = up2.z;
+  te[10] = look.z;
+  return result;
+}
+
+const Constant = new NodeDescription('math/mat4', 'Logic', 'Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', a => a));
+const Column4ToMat4 = new NodeDescription('math/toMat4/column4', 'Logic', 'Columns to Mat4', (description, graph) => new In4Out1FuncNode(description, graph, ['vec4', 'vec4', 'vec4', 'vec4'], 'mat4', column4ToMat4));
+const SetColumn = new NodeDescription('math/setColumn/mat4', 'Logic', 'Set Column', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetColumn4));
+const SetRow = new NodeDescription('math/setRow/mat4', 'Logic', 'Set Row', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'integer', 'vec4'], 'mat4', mat4SetRow4));
+const Elements = new NodeDescription('math/toVec4/mat4', 'Logic', 'Mat4 To Vec4', (description, graph) => new VecElements(description, graph, 'mat4', ['x', 'y', 'z', 'w'], () => {
+  throw new Error('not implemented');
+}));
+const Add = new NodeDescription('math/add/mat4', 'Logic', '+', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Add));
+const Subtract = new NodeDescription('math/subtract/mat4', 'Logic', '-', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Subtract));
+const Negate = new NodeDescription('math/negate/mat4', 'Logic', '-', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Negate));
+const MultiplyByScalar = new NodeDescription('math/multiplyByScalar/mat4', 'Logic', '', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'float'], 'mat4', mat4MultiplyByScalar));
+const Determinant = new NodeDescription('math/determinant/mat4', 'Logic', 'Determinant', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'float', mat4Determinant));
+const Adjoint = new NodeDescription('math/adjoint/mat4', 'Logic', 'Adjoint', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Adjoint));
+const Inverse = new NodeDescription('math/inverse/mat4', 'Logic', 'Inverse', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Inverse));
+const Transpose = new NodeDescription('math/transpose/mat4', 'Logic', 'Transpose', (description, graph) => new In1Out1FuncNode(description, graph, ['mat4'], 'mat4', mat4Transpose));
+const Mat3ToMat4 = new NodeDescription('math/toMat4/mat3', 'Logic', 'Mat3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['mat3'], 'mat4', mat3ToMat4));
+const Scale3ToMat4 = new NodeDescription('math/toMat4/scale3', 'Logic', 'Scale3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', scale3ToMat4));
+const Translate3ToMat4 = new NodeDescription('math/toMat4/translate3', 'Logic', 'Translate3 To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['vec3'], 'mat4', translation3ToMat4));
+const QuatToMat4 = new NodeDescription('math/toMat4/quat', 'Logic', 'Quat To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['quat'], 'mat4', quatToMat4));
+const EulerToMat4 = new NodeDescription('math/toMat4/euler', 'Logic', 'Euler To Mat4', (description, graph) => new In1Out1FuncNode(description, graph, ['euler'], 'mat4', eulerToMat4));
+const Translate = new NodeDescription('math/translate/mat4', 'Logic', 'Translate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Translate));
+const Scale = new NodeDescription('math/scale/mat4', 'Logic', 'Scale', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'mat4', mat4Scale));
+const RotateByQuat = new NodeDescription('math/rotateByQuat/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'quat'], 'mat4', mat4RotateByQuat));
+const RotateByEuler = new NodeDescription('math/rotateByEuler/mat4', 'Logic', 'Rotate', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'euler'], 'mat4', mat4RotateByEuler));
+const Multiply = new NodeDescription('math/multiply/mat4', 'Logic', 'Cross', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'mat4'], 'mat4', mat4Multiply));
+const Mix = new NodeDescription('math/mix/mat4', 'Logic', '', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'mat4', mat4Mix, ['a', 'b', 't']));
+const Equal = new NodeDescription('math/equal/mat4', 'Logic', '=', (description, graph) => new In3Out1FuncNode(description, graph, ['mat4', 'mat4', 'float'], 'boolean', mat4Equals, ['a', 'b', 'tolerance']));
+const TransformPoint3 = new NodeDescription('math/transformPoint3/mat4', 'Logic', 'Transform Point3', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformPoint3));
+const TransformNormal3 = new NodeDescription('math/transformNormal3/mat4', 'Logic', 'Transform Normal', (description, graph) => new In2Out1FuncNode(description, graph, ['mat4', 'vec3'], 'vec3', mat4TransformNormal3));
+const Perspective = new NodeDescription('math/perspective/mat4', 'Logic', 'Perspective', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Perspective, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const PerspectiveFov = new NodeDescription('math/perspectiveFov/mat4', 'Logic', 'Perspective FOV', (description, graph) => new In5Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float'], 'mat4', mat4PerspectiveFov, ['verticalFov', 'near', 'far', 'zoom', 'aspectRatio']));
+const Orthographic = new NodeDescription('math/orthographic/mat4', 'Logic', 'Orthographic', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'float', 'float', 'float', 'float', 'float'], 'mat4', mat4Orthogonal, ['left', 'right', 'top', 'bottom', 'near', 'far']));
+const OrthographicSimple = new NodeDescription('math/orthographicSimple/mat4', 'Logic', 'Orthographic Simple', (description, graph) => new In6Out1FuncNode(description, graph, ['float', 'vec2', 'float', 'float', 'float', 'float'], 'mat4', mat4OrthogonalSimple, ['height', 'center', 'near', 'far', 'zoom', 'aspectRatio']));
+const LookAt = new NodeDescription('math/lookAt/mat4', 'Logic', 'Look At', (description, graph) => new In3Out1FuncNode(description, graph, ['vec3', 'vec3', 'vec3'], 'mat4', mat4LookAt, ['eye', 'target', 'up']));
+
+var Mat4Nodes = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  Constant: Constant,
+  Column4ToMat4: Column4ToMat4,
+  SetColumn: SetColumn,
+  SetRow: SetRow,
+  Elements: Elements,
+  Add: Add,
+  Subtract: Subtract,
+  Negate: Negate,
+  MultiplyByScalar: MultiplyByScalar,
+  Determinant: Determinant,
+  Adjoint: Adjoint,
+  Inverse: Inverse,
+  Transpose: Transpose,
+  Mat3ToMat4: Mat3ToMat4,
+  Scale3ToMat4: Scale3ToMat4,
+  Translate3ToMat4: Translate3ToMat4,
+  QuatToMat4: QuatToMat4,
+  EulerToMat4: EulerToMat4,
+  Translate: Translate,
+  Scale: Scale,
+  RotateByQuat: RotateByQuat,
+  RotateByEuler: RotateByEuler,
+  Multiply: Multiply,
+  Mix: Mix,
+  Equal: Equal,
+  TransformPoint3: TransformPoint3,
+  TransformNormal3: TransformNormal3,
+  Perspective: Perspective,
+  PerspectiveFov: PerspectiveFov,
+  Orthographic: Orthographic,
+  OrthographicSimple: OrthographicSimple,
+  LookAt: LookAt
+});
+
+const Mat4Value = new ValueType('mat4', () => new Mat4(), value => typeof value === 'string' ? mat4Parse(value) : new Mat4(value), value => value.elements, (start, end, t) => mat4Mix(start, end, t));
+
+/* eslint-disable max-len */
+function registerSceneProfile(registry, scene = new DummyScene()) {
+  const {
+    values,
+    nodes
+  } = registry;
+
+  // pull in value type nodes
+  values.register(Vec2Value);
+  values.register(Vec3Value);
+  values.register(Vec4Value);
+  values.register(ColorValue);
+  values.register(EulerValue);
+  values.register(QuatValue);
+  values.register(Mat3Value);
+  values.register(Mat4Value);
+
+  // pull in value type nodes
+  nodes.register(...getNodeDescriptions(Vec2Nodes));
+  nodes.register(...getNodeDescriptions(Vec3Nodes));
+  nodes.register(...getNodeDescriptions(Vec4Nodes));
+  nodes.register(...getNodeDescriptions(ColorNodes));
+  nodes.register(...getNodeDescriptions(EulerNodes));
+  nodes.register(...getNodeDescriptions(QuatNodes));
+  nodes.register(...getNodeDescriptions(Mat3Nodes));
+  nodes.register(...getNodeDescriptions(Mat4Nodes));
+
+  // events
+
+  nodes.register(OnSceneNodeClick.Description);
+
+  // actions
+  const allValueTypeNames = values.getAllNames();
+  nodes.register(...SetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  nodes.register(...GetSceneProperty.GetDescriptions(scene, ...allValueTypeNames));
+  const newValueTypeNames = ['vec2', 'vec3', 'vec4', 'quat', 'euler', 'color', 'mat3', 'mat4'];
+
+  // variables
+
+  newValueTypeNames.forEach(valueTypeName => {
+    registerSerializersForValueType(registry, valueTypeName);
+  });
+  return registry;
+}
+
+export { Assert, AsyncNode, AsyncNode2, BooleanNodes, BooleanValue, Branch, ColorNodes, ColorValue, Counter, CustomEvent, Debounce, DefaultLogger, Delay, DoN, DoOnce, DummyScene, Engine, EulerNodes, EulerValue, EventEmitter, EventNode, EventNode2, ExpectTrue, Fiber, FlipFlop, FloatNodes, FloatValue, FlowNode, FlowNode2, ForLoop, Gate, GetSceneProperty, Graph, ImmediateNode, ImmediateNode2, In0Out1FuncNode, In1Out1FuncNode, In2Out1FuncNode, In3Out1FuncNode, In4Out1FuncNode, IntegerNodes, IntegerValue, LifecycleOnEnd, LifecycleOnStart, LifecycleOnTick, Link, Log, Logger, ManualLifecycleEventEmitter, MultiGate, Node, NodeDescription, NodeDescription2, NodeTypeRegistry, OnCustomEvent, OnSceneNodeClick, QuatNodes, QuatValue, Registry, Sequence, SetSceneProperty, Socket, StringNodes, StringValue, Throttle, TriggerCustomEvent, ValueType, ValueTypeRegistry, Variable, VariableGet, VariableSet, Vec2, Vec2Nodes, Vec2Value, Vec3, Vec3Nodes, Vec3Value, Vec4, Vec4Nodes, Vec4Value, VecElements, WaitAll, angleAxisToQuat, eulerToQuat, getNodeDescriptions, hexToRGB, hslToRGB, mat3ToEuler, mat3ToQuat, mat4ToEuler, mat4ToQuat, parseSafeFloat, parseSafeFloats, quatConjugate, quatExp, quatLn, quatMultiply, quatPow, quatSlerp, quatToAngleAxis, quatToEuler, readGraphFromJSON, registerCoreProfile, registerSceneProfile, rgbToHSL, rgbToHex, toSafeString, validateGraph, validateGraphAcyclic, validateGraphLinks, validateNodeRegistry, validateRegistry, validateValueRegistry, vec2Add, vec2Dot, vec2Equals, vec2FromArray, vec2Length, vec2Mix, vec2MultiplyByScalar, vec2Negate, vec2Normalize, vec2Parse, vec2Subtract, vec2ToArray, vec2ToString, vec3Add, vec3Cross, vec3Dot, vec3Equals, vec3FromArray, vec3Length, vec3Mix, vec3MultiplyByScalar, vec3Negate, vec3Normalize, vec3Parse, vec3Subtract, vec3ToArray, vec3ToString, vec4Add, vec4Dot, vec4Equals, vec4FromArray, vec4Length, vec4Mix, vec4MultiplyByScalar, vec4Negate, vec4Normalize, vec4Parse, vec4Subtract, vec4ToArray, vec4ToString, writeGraphToJSON, writeNodeSpecsToJSON };
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Assert.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Assert.d.ts
new file mode 100644
index 0000000..e8c8798
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Assert.d.ts
@@ -0,0 +1,4 @@
+export declare class Assert {
+    static mustBeTrue(condition: boolean, msg?: string): void;
+    static mustBeDefined(variable: any, msg?: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Logger.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Logger.d.ts
new file mode 100644
index 0000000..0d74d1f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Diagnostics/Logger.d.ts
@@ -0,0 +1,11 @@
+import { EventEmitter } from "../Events/EventEmitter.js";
+export declare class Logger {
+    static readonly onVerbose: EventEmitter<string>;
+    static readonly onInfo: EventEmitter<string>;
+    static readonly onWarn: EventEmitter<string>;
+    static readonly onError: EventEmitter<string>;
+    static verbose(text: string): void;
+    static info(text: string): void;
+    static warn(text: string): void;
+    static error(text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Events/CustomEvent.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Events/CustomEvent.d.ts
new file mode 100644
index 0000000..1792f9e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Events/CustomEvent.d.ts
@@ -0,0 +1,14 @@
+import { Metadata } from "../Metadata.js";
+import { Socket } from "../Sockets/Socket.js";
+import { EventEmitter } from "./EventEmitter.js";
+export declare class CustomEvent {
+    readonly id: string;
+    readonly name: string;
+    readonly parameters: Socket[];
+    label: string;
+    metadata: Metadata;
+    readonly eventEmitter: EventEmitter<{
+        [parameterName: string]: any;
+    }>;
+    constructor(id: string, name: string, parameters?: Socket[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Events/EventEmitter.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Events/EventEmitter.d.ts
new file mode 100644
index 0000000..d1fdbfc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Events/EventEmitter.d.ts
@@ -0,0 +1,8 @@
+export declare class EventEmitter<T> {
+    private readonly listeners;
+    addListener(listener: (t: T) => void): void;
+    removeListener(listener: (t: T) => void): void;
+    clear(): void;
+    emit(event: T): void;
+    get listenerCount(): number;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Execution/Engine.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Execution/Engine.d.ts
new file mode 100644
index 0000000..528c854
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Execution/Engine.d.ts
@@ -0,0 +1,19 @@
+import { EventEmitter } from "../Events/EventEmitter.js";
+import { Graph } from "../Graphs/Graph.js";
+import { AsyncNode } from "../Nodes/AsyncNode.js";
+import { EventNode } from "../Nodes/EventNode.js";
+import { Node } from "../Nodes/Node.js";
+export declare class Engine {
+    readonly graph: Graph;
+    private readonly fiberQueue;
+    readonly asyncNodes: AsyncNode[];
+    readonly eventNodes: EventNode[];
+    readonly onNodeExecutionStart: EventEmitter<Node>;
+    readonly onNodeExecutionEnd: EventEmitter<Node>;
+    executionSteps: number;
+    constructor(graph: Graph);
+    dispose(): void;
+    commitToNewFiber(node: Node, outputFlowSocketName: string, fiberCompletedListener?: (() => void) | undefined): void;
+    executeAllSync(limitInSeconds?: number, limitInSteps?: number): number;
+    executeAllAsync(limitInSeconds?: number, limitInSteps?: number): Promise<number>;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Execution/Fiber.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Execution/Fiber.d.ts
new file mode 100644
index 0000000..fb696ac
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Execution/Fiber.d.ts
@@ -0,0 +1,14 @@
+import { Link } from "../Nodes/Link.js";
+import { Node } from "../Nodes/Node.js";
+import { Engine } from "./Engine.js";
+export declare class Fiber {
+    engine: Engine;
+    nextEval: Link | null;
+    private readonly fiberCompletedListenerStack;
+    private readonly graph;
+    executionSteps: number;
+    constructor(engine: Engine, nextEval: Link | null, fiberCompletedListener?: (() => void) | undefined);
+    commit(node: Node, outputSocketName: string, fiberCompletedListener?: (() => void) | undefined): void;
+    executeStep(): void;
+    isCompleted(): boolean;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Graph.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Graph.d.ts
new file mode 100644
index 0000000..835ba38
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Graph.d.ts
@@ -0,0 +1,22 @@
+import { CustomEvent } from "../Events/CustomEvent.js";
+import { Metadata } from "../Metadata.js";
+import { Node, NodeConfiguration } from "../Nodes/Node.js";
+import { Registry } from "../Registry.js";
+import { Variable } from "../Variables/Variable.js";
+export declare class Graph {
+    readonly registry: Registry;
+    name: string;
+    readonly nodes: {
+        [id: string]: Node;
+    };
+    readonly variables: {
+        [id: string]: Variable;
+    };
+    readonly customEvents: {
+        [id: string]: CustomEvent;
+    };
+    metadata: Metadata;
+    version: number;
+    constructor(registry: Registry);
+    createNode(nodeTypeName: string, nodeId?: string, nodeConfiguration?: NodeConfiguration): Node;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/GraphJSON.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/GraphJSON.d.ts
new file mode 100644
index 0000000..8ee5d3a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/GraphJSON.d.ts
@@ -0,0 +1,58 @@
+import { Metadata } from "../../Metadata.js";
+export type ValueJSON = string | boolean | number | number[];
+export type LinkJSON = {
+    nodeId: string;
+    socket: string;
+};
+export type NodeParameterValueJSON = {
+    value: ValueJSON;
+};
+export type NodeParameterLinkJSON = {
+    link: LinkJSON;
+};
+export type NodeParameterJSON = NodeParameterValueJSON | NodeParameterLinkJSON;
+export type NodeParametersJSON = {
+    [key: string]: NodeParameterJSON;
+};
+export type FlowsJSON = {
+    [key: string]: LinkJSON;
+};
+export type NodeConfigurationJSON = {
+    [key: string]: ValueJSON;
+};
+export type NodeJSON = {
+    label?: string;
+    type: string;
+    id: string;
+    configuration?: NodeConfigurationJSON;
+    parameters?: NodeParametersJSON;
+    flows?: FlowsJSON;
+    metadata?: Metadata;
+};
+export type VariableJSON = {
+    label?: string;
+    id: string;
+    name: string;
+    valueTypeName: string;
+    initialValue: ValueJSON;
+    metadata?: Metadata;
+};
+export type CustomEventParameterJSON = {
+    name: string;
+    valueTypeName: string;
+    defaultValue: ValueJSON;
+};
+export type CustomEventJSON = {
+    label?: string;
+    id: string;
+    name: string;
+    parameters?: CustomEventParameterJSON[];
+    metadata?: Metadata;
+};
+export type GraphJSON = {
+    name?: string;
+    nodes?: NodeJSON[];
+    variables?: VariableJSON[];
+    customEvents?: CustomEventJSON[];
+    metadata?: Metadata;
+};
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/NodeSpecJSON.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/NodeSpecJSON.d.ts
new file mode 100644
index 0000000..27cb010
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/NodeSpecJSON.d.ts
@@ -0,0 +1,24 @@
+import { NodeCategory } from "../../Nodes/Registry/NodeCategory.js";
+import { ValueJSON } from "./GraphJSON.js";
+export type InputSocketSpecJSON = {
+    name: string;
+    valueType: string;
+    defaultValue?: ValueJSON;
+};
+export type OutputSocketSpecJSON = {
+    name: string;
+    valueType: string;
+};
+export type ConfigurationSpecJSON = {
+    name: string;
+    valueType: string;
+    defaultValue: ValueJSON;
+};
+export type NodeSpecJSON = {
+    type: string;
+    category: NodeCategory;
+    label: string;
+    configuration: ConfigurationSpecJSON[];
+    inputs: InputSocketSpecJSON[];
+    outputs: OutputSocketSpecJSON[];
+};
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/readGraphFromJSON.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/readGraphFromJSON.d.ts
new file mode 100644
index 0000000..8a88aee
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/readGraphFromJSON.d.ts
@@ -0,0 +1,4 @@
+import { Registry } from "../../Registry.js";
+import { Graph } from "../Graph.js";
+import { GraphJSON } from "./GraphJSON.js";
+export declare function readGraphFromJSON(graphJson: GraphJSON, registry: Registry): Graph;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeGraphToJSON.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeGraphToJSON.d.ts
new file mode 100644
index 0000000..d45f3a5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeGraphToJSON.d.ts
@@ -0,0 +1,3 @@
+import { Graph } from "../Graph.js";
+import { GraphJSON } from "./GraphJSON.js";
+export declare function writeGraphToJSON(graph: Graph): GraphJSON;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeNodeSpecsToJSON.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeNodeSpecsToJSON.d.ts
new file mode 100644
index 0000000..f2b64bf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/IO/writeNodeSpecsToJSON.d.ts
@@ -0,0 +1,3 @@
+import { Registry } from "../../Registry.js";
+import { NodeSpecJSON } from "./NodeSpecJSON.js";
+export declare function writeNodeSpecsToJSON(registry: Registry): NodeSpecJSON[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraph.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraph.d.ts
new file mode 100644
index 0000000..0664798
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraph.d.ts
@@ -0,0 +1,2 @@
+import { Graph } from "../Graph.js";
+export declare function validateGraph(graph: Graph): string[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphAcyclic.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphAcyclic.d.ts
new file mode 100644
index 0000000..138a69b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphAcyclic.d.ts
@@ -0,0 +1,2 @@
+import { Graph } from "../Graph.js";
+export declare function validateGraphAcyclic(graph: Graph): string[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphLinks.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphLinks.d.ts
new file mode 100644
index 0000000..64400e7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Graphs/Validation/validateGraphLinks.d.ts
@@ -0,0 +1,2 @@
+import { Graph } from "../Graph.js";
+export declare function validateGraphLinks(graph: Graph): string[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Metadata.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Metadata.d.ts
new file mode 100644
index 0000000..e737107
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Metadata.d.ts
@@ -0,0 +1,3 @@
+export type Metadata = {
+    [key: string]: string;
+};
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/AsyncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/AsyncNode.d.ts
new file mode 100644
index 0000000..a6a9019
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/AsyncNode.d.ts
@@ -0,0 +1,18 @@
+import { Engine } from "../Execution/Engine.js";
+import { Graph } from "../Graphs/Graph.js";
+import { Socket } from "../Sockets/Socket.js";
+import { Node, NodeConfiguration } from "./Node.js";
+import { NodeDescription } from "./Registry/NodeDescription.js";
+export declare class AsyncNode extends Node {
+    constructor(description: NodeDescription, graph: Graph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
+export declare class AsyncNode2 extends AsyncNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: Graph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/EventNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/EventNode.d.ts
new file mode 100644
index 0000000..a78f1aa
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/EventNode.d.ts
@@ -0,0 +1,19 @@
+import { Engine } from "../Execution/Engine.js";
+import { Graph } from "../Graphs/Graph.js";
+import { Socket } from "../Sockets/Socket.js";
+import { Node, NodeConfiguration } from "./Node.js";
+import { NodeDescription } from "./Registry/NodeDescription.js";
+export declare class EventNode extends Node {
+    constructor(description: NodeDescription, graph: Graph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
+export declare class EventNode2 extends EventNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: Graph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+        configuration?: NodeConfiguration;
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/FlowNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/FlowNode.d.ts
new file mode 100644
index 0000000..222fbaf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/FlowNode.d.ts
@@ -0,0 +1,18 @@
+import { Fiber } from "../Execution/Fiber.js";
+import { Graph } from "../Graphs/Graph.js";
+import { Socket } from "../Sockets/Socket.js";
+import { Node, NodeConfiguration } from "./Node.js";
+import { NodeDescription } from "./Registry/NodeDescription.js";
+export declare class FlowNode extends Node {
+    constructor(description: NodeDescription, graph: Graph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
+export declare class FlowNode2 extends FlowNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: Graph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+        configuration?: NodeConfiguration;
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/ImmediateNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/ImmediateNode.d.ts
new file mode 100644
index 0000000..4aa0f0f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/ImmediateNode.d.ts
@@ -0,0 +1,17 @@
+import { Graph } from "../Graphs/Graph.js";
+import { Socket } from "../Sockets/Socket.js";
+import { Node, NodeConfiguration } from "./Node.js";
+import { NodeDescription } from "./Registry/NodeDescription.js";
+export declare class ImmediateNode extends Node {
+    readonly exec: () => void;
+    constructor(description: NodeDescription, graph: Graph, inputs: Socket[] | undefined, outputs: Socket[] | undefined, exec: () => void, configuration?: NodeConfiguration);
+}
+export declare class ImmediateNode2 extends ImmediateNode {
+    constructor(props: {
+        description: NodeDescription;
+        graph: Graph;
+        inputs?: Socket[];
+        outputs?: Socket[];
+        exec: () => void;
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Link.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Link.d.ts
new file mode 100644
index 0000000..1d91ac5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Link.d.ts
@@ -0,0 +1,9 @@
+import { Socket } from "../Sockets/Socket.js";
+import { Node } from "./Node.js";
+export declare class Link {
+    nodeId: string;
+    socketName: string;
+    _targetNode: Node | undefined;
+    _targetSocket: Socket | undefined;
+    constructor(nodeId?: string, socketName?: string);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Node.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Node.d.ts
new file mode 100644
index 0000000..292c5ed
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Node.d.ts
@@ -0,0 +1,20 @@
+import { Graph } from "../Graphs/Graph.js";
+import { Metadata } from "../Metadata.js";
+import { Socket } from "../Sockets/Socket.js";
+import { NodeDescription } from "./Registry/NodeDescription.js";
+export type NodeConfiguration = {
+    [key: string]: any;
+};
+export declare class Node {
+    readonly description: NodeDescription;
+    readonly graph: Graph;
+    readonly inputs: Socket[];
+    readonly outputs: Socket[];
+    readonly configuration: NodeConfiguration;
+    id: string;
+    label: string;
+    metadata: Metadata;
+    constructor(description: NodeDescription, graph: Graph, inputs?: Socket[], outputs?: Socket[], configuration?: NodeConfiguration);
+    readInput<T>(inputName: string): T;
+    writeOutput<T>(outputName: string, value: T): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeCategory.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeCategory.d.ts
new file mode 100644
index 0000000..e5a19cf
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeCategory.d.ts
@@ -0,0 +1 @@
+export type NodeCategory = 'Action' | 'Query' | 'Logic' | 'Event' | 'Variable' | 'Flow' | 'Time' | 'None';
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeDescription.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeDescription.d.ts
new file mode 100644
index 0000000..8ae6ed5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeDescription.d.ts
@@ -0,0 +1,41 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { Node, NodeConfiguration } from "../Node.js";
+import { NodeCategory } from "./NodeCategory.js";
+export type NodeFactory = (entry: NodeDescription, graph: Graph, config: NodeConfiguration) => Node;
+export type NodeConfigurationDescription = {
+    [key: string]: {
+        valueType: string;
+        defaultValue?: any;
+    };
+};
+export declare function getNodeDescriptions(importWildcard: any): NodeDescription[];
+export declare class NodeDescription {
+    readonly typeName: string;
+    readonly category: NodeCategory;
+    readonly label: string;
+    readonly factory: NodeFactory;
+    readonly otherTypeNames: string[];
+    readonly helpDescription: string;
+    readonly configuration: NodeConfigurationDescription;
+    constructor(typeName: string, category: NodeCategory, label: string, factory: NodeFactory, otherTypeNames?: string[], helpDescription?: string, configuration?: NodeConfigurationDescription);
+}
+export declare class NodeDescription2 extends NodeDescription {
+    properties: {
+        typeName: string;
+        category: NodeCategory;
+        label?: string;
+        configuration?: NodeConfigurationDescription;
+        factory: NodeFactory;
+        otherTypeNames?: string[];
+        helpDescription?: string;
+    };
+    constructor(properties: {
+        typeName: string;
+        category: NodeCategory;
+        label?: string;
+        configuration?: NodeConfigurationDescription;
+        factory: NodeFactory;
+        otherTypeNames?: string[];
+        helpDescription?: string;
+    });
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeTypeRegistry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeTypeRegistry.d.ts
new file mode 100644
index 0000000..c0b6355
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Registry/NodeTypeRegistry.d.ts
@@ -0,0 +1,10 @@
+import { NodeDescription } from "./NodeDescription.js";
+export declare class NodeTypeRegistry {
+    private readonly typeNameToNodeDescriptions;
+    clear(): void;
+    register(...descriptions: Array<NodeDescription>): void;
+    contains(typeName: string): boolean;
+    get(typeName: string): NodeDescription;
+    getAllNames(): string[];
+    getAllDescriptions(): NodeDescription[];
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In0Out1FuncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In0Out1FuncNode.d.ts
new file mode 100644
index 0000000..edb0a77
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In0Out1FuncNode.d.ts
@@ -0,0 +1,7 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { ImmediateNode } from "../ImmediateNode.js";
+import { NodeDescription } from "../Registry/NodeDescription.js";
+export declare class In0Out1FuncNode<Out1> extends ImmediateNode {
+    readonly evalFunc: () => Out1;
+    constructor(description: NodeDescription, graph: Graph, outputValueType: string, evalFunc: () => Out1);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In1Out1FuncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In1Out1FuncNode.d.ts
new file mode 100644
index 0000000..ceb802a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In1Out1FuncNode.d.ts
@@ -0,0 +1,8 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { ImmediateNode } from "../ImmediateNode.js";
+import { NodeDescription } from "../Registry/NodeDescription.js";
+export declare class In1Out1FuncNode<In1, Out1> extends ImmediateNode {
+    readonly evalFunc: (a: In1) => Out1;
+    readonly inputNames: string[];
+    constructor(description: NodeDescription, graph: Graph, inputValueTypes: string[], outputValueType: string, evalFunc: (a: In1) => Out1, inputNames?: string[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In2Out1FuncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In2Out1FuncNode.d.ts
new file mode 100644
index 0000000..a310a29
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In2Out1FuncNode.d.ts
@@ -0,0 +1,8 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { ImmediateNode } from "../ImmediateNode.js";
+import { NodeDescription } from "../Registry/NodeDescription.js";
+export declare class In2Out1FuncNode<In1, In2, Out1> extends ImmediateNode {
+    readonly evalFunc: (a: In1, b: In2) => Out1;
+    readonly inputNames: string[];
+    constructor(description: NodeDescription, graph: Graph, inputValueTypes: string[], outputValueType: string, evalFunc: (a: In1, b: In2) => Out1, inputNames?: string[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In3Out1FuncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In3Out1FuncNode.d.ts
new file mode 100644
index 0000000..a63e757
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In3Out1FuncNode.d.ts
@@ -0,0 +1,8 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { ImmediateNode } from "../ImmediateNode.js";
+import { NodeDescription } from "../Registry/NodeDescription.js";
+export declare class In3Out1FuncNode<In1, In2, In3, Out1> extends ImmediateNode {
+    readonly evalFunc: (a: In1, b: In2, c: In3) => Out1;
+    readonly inputNames: string[];
+    constructor(description: NodeDescription, graph: Graph, inputValueTypes: string[], outputValueType: string, evalFunc: (a: In1, b: In2, c: In3) => Out1, inputNames?: string[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In4Out1FuncNode.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In4Out1FuncNode.d.ts
new file mode 100644
index 0000000..bf2acef
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Templates/In4Out1FuncNode.d.ts
@@ -0,0 +1,8 @@
+import { Graph } from "../../Graphs/Graph.js";
+import { ImmediateNode } from "../ImmediateNode.js";
+import { NodeDescription } from "../Registry/NodeDescription.js";
+export declare class In4Out1FuncNode<In1, In2, In3, In4, Out1> extends ImmediateNode {
+    readonly evalFunc: (a: In1, b: In2, c: In3, d: In4) => Out1;
+    readonly inputNames: string[];
+    constructor(description: NodeDescription, graph: Graph, inputValueTypes: string[], outputValueType: string, evalFunc: (a: In1, b: In2, c: In3, d: In4) => Out1, inputNames?: string[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Validation/validateNodeRegistry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Validation/validateNodeRegistry.d.ts
new file mode 100644
index 0000000..4f32718
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Nodes/Validation/validateNodeRegistry.d.ts
@@ -0,0 +1,2 @@
+import { Registry } from "../../Registry.js";
+export declare function validateNodeRegistry(registry: Registry): string[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts
new file mode 100644
index 0000000..bfb24d2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/DefaultLogger.d.ts
@@ -0,0 +1,7 @@
+import { ILogger } from "../ILogger.js";
+export declare class DefaultLogger implements ILogger {
+    verbose(text: string): void;
+    info(text: string): void;
+    warn(text: string): void;
+    error(text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts
new file mode 100644
index 0000000..a6d846a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.d.ts
@@ -0,0 +1,7 @@
+import { EventEmitter } from "../../../../Events/EventEmitter.js";
+import { ILifecycleEventEmitter } from "../ILifecycleEventEmitter.js";
+export declare class ManualLifecycleEventEmitter implements ILifecycleEventEmitter {
+    readonly startEvent: EventEmitter<void>;
+    readonly endEvent: EventEmitter<void>;
+    readonly tickEvent: EventEmitter<void>;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts
new file mode 100644
index 0000000..70c41ea
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILifecycleEventEmitter.d.ts
@@ -0,0 +1,6 @@
+import { EventEmitter } from "../../../Events/EventEmitter.js";
+export interface ILifecycleEventEmitter {
+    startEvent: EventEmitter<void>;
+    endEvent: EventEmitter<void>;
+    tickEvent: EventEmitter<void>;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILogger.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILogger.d.ts
new file mode 100644
index 0000000..4153468
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Abstractions/ILogger.d.ts
@@ -0,0 +1,6 @@
+export interface ILogger {
+    verbose(text: string): void;
+    info(text: string): void;
+    warn(text: string): void;
+    error(text: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/OnCustomEvent.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/OnCustomEvent.d.ts
new file mode 100644
index 0000000..286caf4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/OnCustomEvent.d.ts
@@ -0,0 +1,13 @@
+import { NodeConfiguration } from "../../../Nodes/Node.js";
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { EventNode2 } from "../../../Nodes/EventNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class OnCustomEvent extends EventNode2 {
+    static Description: NodeDescription2;
+    private readonly customEvent;
+    constructor(description: NodeDescription, graph: Graph, configuration: NodeConfiguration);
+    private onCustomEvent;
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts
new file mode 100644
index 0000000..d6d6172
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/CustomEvents/TriggerCustomEvent.d.ts
@@ -0,0 +1,11 @@
+import { NodeConfiguration } from "../../../Nodes/Node.js";
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode2 } from "../../../Nodes/FlowNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class TriggerCustomEvent extends FlowNode2 {
+    static Description: NodeDescription2;
+    private readonly customEvent;
+    constructor(description: NodeDescription, graph: Graph, configuration: NodeConfiguration);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/AssertExpectTrue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/AssertExpectTrue.d.ts
new file mode 100644
index 0000000..9dc4cce
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/AssertExpectTrue.d.ts
@@ -0,0 +1,9 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class ExpectTrue extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    triggered(fiber: Fiber, triggeredSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/DebugLog.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/DebugLog.d.ts
new file mode 100644
index 0000000..38468d1
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Debug/DebugLog.d.ts
@@ -0,0 +1,11 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { ILogger } from "../Abstractions/ILogger.js";
+export declare class Log extends FlowNode {
+    private readonly logger;
+    static Description: (logger: ILogger) => NodeDescription;
+    constructor(description: NodeDescription, graph: Graph, logger: ILogger);
+    triggered(fiber: Fiber, triggeredSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Branch.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Branch.d.ts
new file mode 100644
index 0000000..d506d86
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Branch.d.ts
@@ -0,0 +1,9 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Branch extends FlowNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: Graph);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Counter.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Counter.d.ts
new file mode 100644
index 0000000..9f498f1
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Counter.d.ts
@@ -0,0 +1,10 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Counter extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private count;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Debounce.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Debounce.d.ts
new file mode 100644
index 0000000..6df01e0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Debounce.d.ts
@@ -0,0 +1,11 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { AsyncNode } from "../../../Nodes/AsyncNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Debounce extends AsyncNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private triggerVersion;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoN.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoN.d.ts
new file mode 100644
index 0000000..e795b6e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoN.d.ts
@@ -0,0 +1,10 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class DoN extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private count;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoOnce.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoOnce.d.ts
new file mode 100644
index 0000000..9bfb20a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/DoOnce.d.ts
@@ -0,0 +1,10 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class DoOnce extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private firedOnce;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/FlipFlop.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/FlipFlop.d.ts
new file mode 100644
index 0000000..157c9b4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/FlipFlop.d.ts
@@ -0,0 +1,10 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class FlipFlop extends FlowNode {
+    static Description: NodeDescription;
+    private isOn;
+    constructor(description: NodeDescription, graph: Graph);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/ForLoop.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/ForLoop.d.ts
new file mode 100644
index 0000000..46ceb89
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/ForLoop.d.ts
@@ -0,0 +1,9 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class ForLoop extends FlowNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: Graph);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Gate.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Gate.d.ts
new file mode 100644
index 0000000..da62383
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Gate.d.ts
@@ -0,0 +1,11 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Gate extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private isInitialized;
+    private isClosed;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/MultieGate.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/MultieGate.d.ts
new file mode 100644
index 0000000..bf02372
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/MultieGate.d.ts
@@ -0,0 +1,11 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class MultiGate extends FlowNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private isInitialized;
+    private nextIndex;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Sequence.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Sequence.d.ts
new file mode 100644
index 0000000..f620a75
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Sequence.d.ts
@@ -0,0 +1,10 @@
+import { NodeConfiguration } from "../../../Nodes/Node.js";
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Sequence extends FlowNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: Graph, configuration: NodeConfiguration);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Throttle.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Throttle.d.ts
new file mode 100644
index 0000000..1e7f2ab
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/Throttle.d.ts
@@ -0,0 +1,12 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { AsyncNode } from "../../../Nodes/AsyncNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Throttle extends AsyncNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+    private triggerVersion;
+    private timeoutPending;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/WaitAll.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/WaitAll.d.ts
new file mode 100644
index 0000000..d54bc27
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Flow/WaitAll.d.ts
@@ -0,0 +1,15 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class WaitAll extends FlowNode {
+    private numInputs;
+    static Description: NodeDescription2;
+    private isOn;
+    constructor(description: NodeDescription, graph: Graph, numInputs: number);
+    private triggeredMap;
+    private triggeredCount;
+    private outputTriggered;
+    private reset;
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts
new file mode 100644
index 0000000..2335dbc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnEnd.d.ts
@@ -0,0 +1,13 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { EventNode } from "../../../Nodes/EventNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { ILifecycleEventEmitter } from "../Abstractions/ILifecycleEventEmitter.js";
+export declare class LifecycleOnEnd extends EventNode {
+    private readonly lifecycleEventEmitter;
+    static Description: (lifecycleEventEmitter: ILifecycleEventEmitter) => NodeDescription;
+    constructor(description: NodeDescription, graph: Graph, lifecycleEventEmitter: ILifecycleEventEmitter);
+    private onEndEvent;
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts
new file mode 100644
index 0000000..18baeff
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnStart.d.ts
@@ -0,0 +1,13 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { EventNode } from "../../../Nodes/EventNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { ILifecycleEventEmitter } from "../Abstractions/ILifecycleEventEmitter.js";
+export declare class LifecycleOnStart extends EventNode {
+    private readonly lifecycleEventEmitter;
+    static Description: (lifecycleEventEmitter: ILifecycleEventEmitter) => NodeDescription;
+    constructor(description: NodeDescription, graph: Graph, lifecycleEventEmitter: ILifecycleEventEmitter);
+    private onStartEvent;
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts
new file mode 100644
index 0000000..bb98f26
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Lifecycle/LifecycleOnTick.d.ts
@@ -0,0 +1,13 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { EventNode } from "../../../Nodes/EventNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { ILifecycleEventEmitter } from "../Abstractions/ILifecycleEventEmitter.js";
+export declare class LifecycleOnTick extends EventNode {
+    private readonly lifecycleEventEmitter;
+    static Description: (lifecycleEventEmitter: ILifecycleEventEmitter) => NodeDescription;
+    constructor(description: NodeDescription, graph: Graph, lifecycleEventEmitter: ILifecycleEventEmitter);
+    private onTickEvent;
+    init(engine: Engine): void;
+    dispose(engine: Engine): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Time/Delay.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Time/Delay.d.ts
new file mode 100644
index 0000000..bfcb362
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Time/Delay.d.ts
@@ -0,0 +1,11 @@
+import { Engine } from "../../../Execution/Engine.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { AsyncNode } from "../../../Nodes/AsyncNode.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class Delay extends AsyncNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: Graph);
+    private timeoutPending;
+    triggered(engine: Engine, triggeringSocketName: string, finished: () => void): void;
+    dispose(): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanNodes.d.ts
new file mode 100644
index 0000000..ad0ac28
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanNodes.d.ts
@@ -0,0 +1,8 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const And: NodeDescription;
+export declare const Or: NodeDescription;
+export declare const Not: NodeDescription;
+export declare const ToFloat: NodeDescription;
+export declare const Equal: NodeDescription;
+export declare const toInteger: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanValue.d.ts
new file mode 100644
index 0000000..d901e75
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/BooleanValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from "../../../Values/ValueType.js";
+export declare const BooleanValue: ValueType<boolean, boolean>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatNodes.d.ts
new file mode 100644
index 0000000..cec11af
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatNodes.d.ts
@@ -0,0 +1,44 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Multiply: NodeDescription;
+export declare const Divide: NodeDescription;
+export declare const Modulus: NodeDescription;
+export declare const Power: NodeDescription;
+export declare const SquareRoot: NodeDescription;
+export declare const E: NodeDescription;
+export declare const Exp: NodeDescription;
+export declare const Ln: NodeDescription;
+export declare const Log2: NodeDescription;
+export declare const Log10: NodeDescription;
+export declare const PI: NodeDescription;
+export declare const Sin: NodeDescription;
+export declare const Asin: NodeDescription;
+export declare const Cos: NodeDescription;
+export declare const Acos: NodeDescription;
+export declare const Tan: NodeDescription;
+export declare const RadiansToDegrees: NodeDescription;
+export declare const DegreesToRadians: NodeDescription;
+export declare const Atan: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const ToFloat: NodeDescription;
+export declare const Min: NodeDescription;
+export declare const Max: NodeDescription;
+export declare const Clamp: NodeDescription;
+export declare const Abs: NodeDescription;
+export declare const Sign: NodeDescription;
+export declare const Floor: NodeDescription;
+export declare const Ceil: NodeDescription;
+export declare const Round: NodeDescription;
+export declare const Trunc: NodeDescription;
+export declare const Random: NodeDescription;
+export declare const Equal: NodeDescription;
+export declare const EqualTolerance: NodeDescription;
+export declare const GreaterThan: NodeDescription;
+export declare const GreaterThanOrEqual: NodeDescription;
+export declare const LessThan: NodeDescription;
+export declare const LessThanOrEqual: NodeDescription;
+export declare const IsNaN: NodeDescription;
+export declare const IsInf: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatValue.d.ts
new file mode 100644
index 0000000..0842d40
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/FloatValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from "../../../Values/ValueType.js";
+export declare const FloatValue: ValueType<number, number>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerNodes.d.ts
new file mode 100644
index 0000000..78d080a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerNodes.d.ts
@@ -0,0 +1,20 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Multiply: NodeDescription;
+export declare const Divide: NodeDescription;
+export declare const Modulus: NodeDescription;
+export declare const ToFloat: NodeDescription;
+export declare const Min: NodeDescription;
+export declare const Max: NodeDescription;
+export declare const Clamp: NodeDescription;
+export declare const Abs: NodeDescription;
+export declare const Sign: NodeDescription;
+export declare const Equal: NodeDescription;
+export declare const GreaterThan: NodeDescription;
+export declare const GreaterThanOrEqual: NodeDescription;
+export declare const LessThan: NodeDescription;
+export declare const LessThanOrEqual: NodeDescription;
+export declare const toBoolean: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerValue.d.ts
new file mode 100644
index 0000000..81c2e60
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/IntegerValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from "../../../Values/ValueType.js";
+export declare const IntegerValue: ValueType<bigint, string | number>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringNodes.d.ts
new file mode 100644
index 0000000..e107a93
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringNodes.d.ts
@@ -0,0 +1,6 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Concat: NodeDescription;
+export declare const Includes: NodeDescription;
+export declare const Length: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringValue.d.ts
new file mode 100644
index 0000000..90f27c7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Values/StringValue.d.ts
@@ -0,0 +1,2 @@
+import { ValueType } from "../../../Values/ValueType.js";
+export declare const StringValue: ValueType<string, string>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableGet.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableGet.d.ts
new file mode 100644
index 0000000..eb61477
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableGet.d.ts
@@ -0,0 +1,8 @@
+import { Graph } from "../../../Graphs/Graph.js";
+import { ImmediateNode } from "../../../Nodes/ImmediateNode.js";
+import { NodeConfiguration } from "../../../Nodes/Node.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class VariableGet extends ImmediateNode {
+    static Description: NodeDescription2;
+    constructor(description: NodeDescription, graph: Graph, configuration: NodeConfiguration);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableSet.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableSet.d.ts
new file mode 100644
index 0000000..588f4b5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/Variables/VariableSet.d.ts
@@ -0,0 +1,12 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeConfiguration } from "../../../Nodes/Node.js";
+import { NodeDescription, NodeDescription2 } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class VariableSet extends FlowNode {
+    static Description: NodeDescription2;
+    static GetDescription(graph: Graph, variableId: string): NodeDescription;
+    private readonly variable;
+    constructor(description: NodeDescription, graph: Graph, configuration: NodeConfiguration);
+    triggered(fiber: Fiber, triggeredSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/registerCoreProfile.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/registerCoreProfile.d.ts
new file mode 100644
index 0000000..dea19e9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Core/registerCoreProfile.d.ts
@@ -0,0 +1,4 @@
+import { Registry } from "../../Registry.js";
+import { ILifecycleEventEmitter } from "./Abstractions/ILifecycleEventEmitter.js";
+import { ILogger } from "./Abstractions/ILogger.js";
+export declare function registerCoreProfile(registry: Registry, logger?: ILogger, lifecycleEventEmitter?: ILifecycleEventEmitter): Registry;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/Drivers/DummyScene.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/Drivers/DummyScene.d.ts
new file mode 100644
index 0000000..cd9e697
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/Drivers/DummyScene.d.ts
@@ -0,0 +1,10 @@
+import { EventEmitter } from "../../../../Events/EventEmitter.js";
+import { IScene } from "../IScene.js";
+export declare class DummyScene implements IScene {
+    onSceneChanged: EventEmitter<void>;
+    private valueRegistry;
+    constructor();
+    getProperty(jsonPath: string, valueTypeName: string): any;
+    setProperty(): void;
+    addOnClickedListener(jsonPath: string, callback: (jsonPath: string) => void): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/IScene.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/IScene.d.ts
new file mode 100644
index 0000000..640dc38
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Abstractions/IScene.d.ts
@@ -0,0 +1,5 @@
+export interface IScene {
+    getProperty(jsonPath: string, valueTypeName: string): any;
+    setProperty(jsonPath: string, valueTypeName: string, value: any): void;
+    addOnClickedListener(jsonPath: string, callback: (jsonPath: string) => void): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Actions/SetSceneProperty.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Actions/SetSceneProperty.d.ts
new file mode 100644
index 0000000..c0c408d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Actions/SetSceneProperty.d.ts
@@ -0,0 +1,12 @@
+import { Fiber } from "../../../Execution/Fiber.js";
+import { Graph } from "../../../Graphs/Graph.js";
+import { FlowNode } from "../../../Nodes/FlowNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { IScene } from "../Abstractions/IScene.js";
+export declare class SetSceneProperty extends FlowNode {
+    readonly valueTypeName: string;
+    private readonly scene;
+    static GetDescriptions(scene: IScene, ...valueTypeNames: string[]): NodeDescription[];
+    constructor(description: NodeDescription, graph: Graph, valueTypeName: string, scene: IScene);
+    triggered(fiber: Fiber, triggeringSocketName: string): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Events/OnSceneNodeClick.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Events/OnSceneNodeClick.d.ts
new file mode 100644
index 0000000..ce5f090
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Events/OnSceneNodeClick.d.ts
@@ -0,0 +1,7 @@
+import { Graph } from "../../../Graphs/Graph.js";
+import { EventNode } from "../../../Nodes/EventNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class OnSceneNodeClick extends EventNode {
+    static Description: NodeDescription;
+    constructor(description: NodeDescription, graph: Graph);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Logic/VecElements.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Logic/VecElements.d.ts
new file mode 100644
index 0000000..ede722a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Logic/VecElements.d.ts
@@ -0,0 +1,6 @@
+import { Graph } from "../../../Graphs/Graph.js";
+import { ImmediateNode } from "../../../Nodes/ImmediateNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare class VecElements<T> extends ImmediateNode {
+    constructor(description: NodeDescription, graph: Graph, valueTypeName: string, elementNames: string[] | undefined, toArray: (value: T, array: number[], offset: number) => void);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Queries/GetSceneProperty.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Queries/GetSceneProperty.d.ts
new file mode 100644
index 0000000..db251b5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Queries/GetSceneProperty.d.ts
@@ -0,0 +1,10 @@
+import { Graph } from "../../../Graphs/Graph.js";
+import { ImmediateNode } from "../../../Nodes/ImmediateNode.js";
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+import { IScene } from "../Abstractions/IScene.js";
+export declare class GetSceneProperty extends ImmediateNode {
+    readonly valueTypeName: string;
+    private readonly scene;
+    static GetDescriptions(scene: IScene, ...valueTypeNames: string[]): NodeDescription[];
+    constructor(description: NodeDescription, graph: Graph, valueTypeName: string, scene: IScene);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorNodes.d.ts
new file mode 100644
index 0000000..ed0800a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorNodes.d.ts
@@ -0,0 +1,14 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const HslToColor: NodeDescription;
+export declare const ColorToHsl: NodeDescription;
+export declare const HexToColor: NodeDescription;
+export declare const ColorToHex: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorValue.d.ts
new file mode 100644
index 0000000..935632b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/ColorValue.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec3, Vec3JSON } from "./Internal/Vec3.js";
+export declare const ColorValue: ValueType<Vec3, Vec3JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerNodes.d.ts
new file mode 100644
index 0000000..bf882d9
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerNodes.d.ts
@@ -0,0 +1,13 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const Mat3ToEuler: NodeDescription;
+export declare const Mat4ToEuler: NodeDescription;
+export declare const QuatToEuler: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerValue.d.ts
new file mode 100644
index 0000000..4ead211
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/EulerValue.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec3, Vec3JSON } from "./Internal/Vec3.js";
+export declare const EulerValue: ValueType<Vec3, Vec3JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat3.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat3.d.ts
new file mode 100644
index 0000000..70ff7df
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat3.d.ts
@@ -0,0 +1,37 @@
+import { Mat4 } from "./Mat4.js";
+import { Vec2 } from "./Vec2.js";
+import { Vec3 } from "./Vec3.js";
+import { Vec4 } from "./Vec4.js";
+export type Mat3JSON = number[];
+export declare class Mat3 {
+    elements: number[];
+    constructor(elements?: number[]);
+    clone(result?: Mat3): Mat3;
+    set(elements: number[]): this;
+}
+export declare function mat3SetColumn3(m: Mat3, columnIndex: number, column: Vec3, result?: Mat3): Mat3;
+export declare function mat3SetRow3(m: Mat3, rowIndex: number, row: Vec3, result?: Mat3): Mat3;
+export declare function column3ToMat3(a: Vec3, b: Vec3, c: Vec3, result?: Mat3): Mat3;
+export declare function mat3Equals(a: Mat3, b: Mat3, tolerance?: number): boolean;
+export declare function mat3Add(a: Mat3, b: Mat3, result?: Mat3): Mat3;
+export declare function mat3Subtract(a: Mat3, b: Mat3, result?: Mat3): Mat3;
+export declare function mat3MultiplyByScalar(a: Mat3, b: number, result?: Mat3): Mat3;
+export declare function mat3Negate(a: Mat3, result?: Mat3): Mat3;
+export declare function mat3Multiply(a: Mat3, b: Mat3, result?: Mat3): Mat3;
+export declare function mat3Determinant(m: Mat3): number;
+export declare function mat3Transpose(m: Mat3, result?: Mat3): Mat3;
+export declare function mat3Inverse(m: Mat3, result?: Mat3): Mat3;
+export declare function mat3Mix(a: Mat3, b: Mat3, t: number, result?: Mat3): Mat3;
+export declare function mat3FromArray(array: Float32Array | number[], offset?: number, result?: Mat3): Mat3;
+export declare function mat3ToArray(a: Mat3, array: Float32Array | number[], offset?: number): void;
+export declare function mat3ToString(a: Mat3): string;
+export declare function mat3Parse(text: string, result?: Mat3): Mat3;
+export declare function eulerToMat3(euler: Vec3, result?: Mat3): Mat3;
+export declare function quatToMat3(q: Vec4, result?: Mat3): Mat3;
+export declare function scale2ToMat3(s: Vec2, result?: Mat3): Mat3;
+export declare function mat3ToScale2(m: Mat4, result?: Vec2): Vec2;
+export declare function translation2ToMat3(t: Vec2, result?: Mat3): Mat3;
+export declare function mat3ToTranslation2(m: Mat3, result?: Vec2): Vec2;
+export declare function scale3ToMat3(s: Vec3, result?: Mat3): Mat3;
+export declare function mat3ToScale3(m: Mat4, result?: Vec3): Vec3;
+export declare function mat4ToMat3(a: Mat4, result?: Mat3): Mat3;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat4.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat4.d.ts
new file mode 100644
index 0000000..5443440
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Mat4.d.ts
@@ -0,0 +1,47 @@
+import { Mat3 } from "./Mat3.js";
+import { Vec2 } from "./Vec2.js";
+import { Vec3 } from "./Vec3.js";
+import { Vec4 } from "./Vec4.js";
+export type Mat4JSON = number[];
+export declare class Mat4 {
+    elements: number[];
+    constructor(elements?: number[]);
+    clone(result?: Mat4): Mat4;
+    set(elements: number[]): this;
+}
+export declare function mat4SetColumn4(m: Mat4, columnIndex: bigint, column: Vec4, result?: Mat4): Mat4;
+export declare function mat4SetRow4(m: Mat4, rowIndex: bigint, row: Vec4, result?: Mat4): Mat4;
+export declare function column4ToMat4(a: Vec4, b: Vec4, c: Vec4, d: Vec4, result?: Mat4): Mat4;
+export declare function mat4Equals(a: Mat4, b: Mat4, tolerance?: number): boolean;
+export declare function mat4Add(a: Mat4, b: Mat4, result?: Mat4): Mat4;
+export declare function mat4Subtract(a: Mat4, b: Mat4, result?: Mat4): Mat4;
+export declare function mat4MultiplyByScalar(a: Mat4, b: number, result?: Mat4): Mat4;
+export declare function mat4Negate(a: Mat4, result?: Mat4): Mat4;
+export declare function mat4Multiply(a: Mat4, b: Mat4, result?: Mat4): Mat4;
+export declare function mat4Determinant(m: Mat4): number;
+export declare function mat4Adjoint(m: Mat4, result?: Mat4): Mat4;
+export declare function mat4Transpose(m: Mat4, result?: Mat4): Mat4;
+export declare function mat4Inverse(m: Mat4, result?: Mat4): Mat4;
+export declare function mat4Mix(a: Mat4, b: Mat4, t: number, result?: Mat4): Mat4;
+export declare function mat4FromArray(array: Float32Array | number[], offset?: number, result?: Mat4): Mat4;
+export declare function mat4ToArray(a: Mat4, array: Float32Array | number[], offset?: number): void;
+export declare function mat4ToString(a: Mat4): string;
+export declare function mat4Parse(text: string, result?: Mat4): Mat4;
+export declare function mat3ToMat4(a: Mat3, result?: Mat4): Mat4;
+export declare function eulerToMat4(e: Vec3, result?: Mat4): Mat4;
+export declare function quatToMat4(q: Vec4, result?: Mat4): Mat4;
+export declare function scale3ToMat4(s: Vec3, result?: Mat4): Mat4;
+export declare function mat4ToScale3(m: Mat4, result?: Vec3): Vec3;
+export declare function translation3ToMat4(t: Vec3, result?: Mat4): Mat4;
+export declare function mat4ToTranslation3(m: Mat4, result?: Vec3): Vec3;
+export declare function mat4Translate(m: Mat4, t: Vec3, result?: Mat4): Mat4;
+export declare function mat4Scale(m: Mat4, s: Vec3, result?: Mat4): Mat4;
+export declare function mat4RotateByQuat(m: Mat4, q: Vec4, result?: Mat4): Mat4;
+export declare function mat4RotateByEuler(m: Mat4, e: Vec3, result?: Mat4): Mat4;
+export declare function mat4TransformPoint3(m: Mat4, v: Vec4, result?: Vec3): Vec3;
+export declare function mat4TransformNormal3(v: Vec3, m: Mat4, result?: Vec3): Vec3;
+export declare function mat4Perspective(left: number, right: number, top: number, bottom: number, near: number, far: number, result?: Mat4): Mat4;
+export declare function mat4PerspectiveFov(verticalFov: number, near: number, far: number, zoom: number, aspectRatio: number, result?: Mat4): Mat4;
+export declare function mat4Orthogonal(left: number, right: number, top: number, bottom: number, near: number, far: number, result?: Mat4): Mat4;
+export declare function mat4OrthogonalSimple(height: number, center: Vec2, near: number, far: number, zoom: number, aspectRatio?: number, result?: Mat4): Mat4;
+export declare function mat4LookAt(eye: Vec3, target: Vec3, up: Vec3, result?: Mat4): Mat4;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec2.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec2.d.ts
new file mode 100644
index 0000000..97b07ca
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec2.d.ts
@@ -0,0 +1,21 @@
+export type Vec2JSON = number[];
+export declare class Vec2 {
+    x: number;
+    y: number;
+    constructor(x?: number, y?: number);
+    clone(result?: Vec2): Vec2;
+    set(x: number, y: number): this;
+}
+export declare function vec2Equals(a: Vec2, b: Vec2, tolerance?: number): boolean;
+export declare function vec2Add(a: Vec2, b: Vec2, result?: Vec2): Vec2;
+export declare function vec2Subtract(a: Vec2, b: Vec2, result?: Vec2): Vec2;
+export declare function vec2MultiplyByScalar(a: Vec2, b: number, result?: Vec2): Vec2;
+export declare function vec2Negate(a: Vec2, result?: Vec2): Vec2;
+export declare function vec2Length(a: Vec2): number;
+export declare function vec2Normalize(a: Vec2, result?: Vec2): Vec2;
+export declare function vec2Dot(a: Vec2, b: Vec2): number;
+export declare function vec2Mix(a: Vec2, b: Vec2, t: number, result?: Vec2): Vec2;
+export declare function vec2FromArray(array: Float32Array | number[], offset?: number, result?: Vec2): Vec2;
+export declare function vec2ToArray(a: Vec2, array: Float32Array | number[], offset?: number): void;
+export declare function vec2ToString(a: Vec2): string;
+export declare function vec2Parse(text: string, result?: Vec2): Vec2;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec3.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec3.d.ts
new file mode 100644
index 0000000..29804d6
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec3.d.ts
@@ -0,0 +1,33 @@
+import { Mat3 } from "./Mat3.js";
+import { Mat4 } from "./Mat4.js";
+import { Vec4 } from "./Vec4.js";
+export type Vec3JSON = number[];
+export declare class Vec3 {
+    x: number;
+    y: number;
+    z: number;
+    constructor(x?: number, y?: number, z?: number);
+    clone(result?: Vec3): Vec3;
+    set(x: number, y: number, z: number): this;
+}
+export declare function vec3Equals(a: Vec3, b: Vec3, tolerance?: number): boolean;
+export declare function vec3Add(a: Vec3, b: Vec3, result?: Vec3): Vec3;
+export declare function vec3Subtract(a: Vec3, b: Vec3, result?: Vec3): Vec3;
+export declare function vec3MultiplyByScalar(a: Vec3, b: number, result?: Vec3): Vec3;
+export declare function vec3Negate(a: Vec3, result?: Vec3): Vec3;
+export declare function vec3Length(a: Vec3): number;
+export declare function vec3Normalize(a: Vec3, result?: Vec3): Vec3;
+export declare function vec3Dot(a: Vec3, b: Vec3): number;
+export declare function vec3Cross(a: Vec3, b: Vec3, result?: Vec3): Vec3;
+export declare function vec3Mix(a: Vec3, b: Vec3, t: number, result?: Vec3): Vec3;
+export declare function vec3FromArray(array: Float32Array | number[], offset?: number, result?: Vec3): Vec3;
+export declare function vec3ToArray(a: Vec3, array: Float32Array | number[], offset?: number): void;
+export declare function vec3ToString(a: Vec3): string;
+export declare function vec3Parse(text: string, result?: Vec3): Vec3;
+export declare function hslToRGB(hsl: Vec3, result?: Vec3): Vec3;
+export declare function rgbToHSL(rgb: Vec3, result?: Vec3): Vec3;
+export declare function hexToRGB(hex: number, result?: Vec3): Vec3;
+export declare function rgbToHex(rgb: Vec3): number;
+export declare function mat3ToEuler(m: Mat3, result?: Vec3): Vec3;
+export declare function mat4ToEuler(m: Mat4, result?: Vec3): Vec3;
+export declare function quatToEuler(q: Vec4, result?: Vec3): Vec3;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec4.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec4.d.ts
new file mode 100644
index 0000000..bbacfd1
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Internal/Vec4.d.ts
@@ -0,0 +1,37 @@
+import { Mat3 } from "./Mat3.js";
+import { Mat4 } from "./Mat4.js";
+import { Vec3 } from "./Vec3.js";
+export type Vec4JSON = number[];
+export declare class Vec4 {
+    x: number;
+    y: number;
+    z: number;
+    w: number;
+    constructor(x?: number, y?: number, z?: number, w?: number);
+    clone(result?: Vec4): Vec4;
+    set(x: number, y: number, z: number, w: number): this;
+}
+export declare function vec4Equals(a: Vec4, b: Vec4, tolerance?: number): boolean;
+export declare function vec4Add(a: Vec4, b: Vec4, result?: Vec4): Vec4;
+export declare function vec4Subtract(a: Vec4, b: Vec4, result?: Vec4): Vec4;
+export declare function vec4MultiplyByScalar(a: Vec4, b: number, result?: Vec4): Vec4;
+export declare function vec4Negate(a: Vec4, result?: Vec4): Vec4;
+export declare function vec4Length(a: Vec4): number;
+export declare function vec4Normalize(a: Vec4, result?: Vec4): Vec4;
+export declare function vec4Dot(a: Vec4, b: Vec4): number;
+export declare function vec4Mix(a: Vec4, b: Vec4, t: number, result?: Vec4): Vec4;
+export declare function vec4FromArray(array: Float32Array | number[], offset?: number, result?: Vec4): Vec4;
+export declare function vec4ToArray(a: Vec4, array: Float32Array | number[], offset?: number): void;
+export declare function vec4ToString(a: Vec4): string;
+export declare function vec4Parse(text: string, result?: Vec4): Vec4;
+export declare function quatConjugate(a: Vec4, result?: Vec4): Vec4;
+export declare function quatMultiply(a: Vec4, b: Vec4, result?: Vec4): Vec4;
+export declare function quatSlerp(a: Vec4, b: Vec4, t: number, result?: Vec4): Vec4;
+export declare function quatExp(a: Vec4, result?: Vec4): Vec4;
+export declare function quatLn(a: Vec4, result?: Vec4): Vec4;
+export declare function quatPow(a: Vec4, b: number, result?: Vec4): Vec4;
+export declare function eulerToQuat(euler: Vec3, result?: Vec4): Vec4;
+export declare function angleAxisToQuat(angle: number, axis: Vec3, result?: Vec4): Vec4;
+export declare function quatToAngleAxis(q: Vec4, result?: Vec3): [angle: number, axis: Vec3];
+export declare function mat4ToQuat(m: Mat4, result?: Vec4): Vec4;
+export declare function mat3ToQuat(m: Mat3, result?: Vec4): Vec4;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatNodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatNodes.d.ts
new file mode 100644
index 0000000..d9e230a
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatNodes.d.ts
@@ -0,0 +1,19 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Multiply: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Length: NodeDescription;
+export declare const Normalize: NodeDescription;
+export declare const Dot: NodeDescription;
+export declare const Ln: NodeDescription;
+export declare const Exp: NodeDescription;
+export declare const Pow: NodeDescription;
+export declare const Mat3ToQuat: NodeDescription;
+export declare const Mat4ToQuat: NodeDescription;
+export declare const EulerToQuat: NodeDescription;
+export declare const AngleAxisToQuat: NodeDescription;
+export declare const Slerp: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatValue.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatValue.d.ts
new file mode 100644
index 0000000..c5c4e3f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/QuatValue.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec4, Vec4JSON } from "./Internal/Vec4.js";
+export declare const QuatValue: ValueType<Vec4, Vec4JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Nodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Nodes.d.ts
new file mode 100644
index 0000000..7639a38
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Nodes.d.ts
@@ -0,0 +1,13 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Length: NodeDescription;
+export declare const Normalize: NodeDescription;
+export declare const Dot: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Value.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Value.d.ts
new file mode 100644
index 0000000..dc3ac4c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec2Value.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec2, Vec2JSON } from "./Internal/Vec2.js";
+export declare const Vec2Value: ValueType<Vec2, Vec2JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Nodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Nodes.d.ts
new file mode 100644
index 0000000..33162ef
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Nodes.d.ts
@@ -0,0 +1,14 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Length: NodeDescription;
+export declare const Normalize: NodeDescription;
+export declare const Cross: NodeDescription;
+export declare const Dot: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Value.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Value.d.ts
new file mode 100644
index 0000000..560252f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec3Value.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec3, Vec3JSON } from "./Internal/Vec3.js";
+export declare const Vec3Value: ValueType<Vec3, Vec3JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Nodes.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Nodes.d.ts
new file mode 100644
index 0000000..7639a38
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Nodes.d.ts
@@ -0,0 +1,13 @@
+import { NodeDescription } from "../../../Nodes/Registry/NodeDescription.js";
+export declare const Constant: NodeDescription;
+export declare const Create: NodeDescription;
+export declare const Elements: NodeDescription;
+export declare const Add: NodeDescription;
+export declare const Subtract: NodeDescription;
+export declare const Negate: NodeDescription;
+export declare const Scale: NodeDescription;
+export declare const Length: NodeDescription;
+export declare const Normalize: NodeDescription;
+export declare const Dot: NodeDescription;
+export declare const Mix: NodeDescription;
+export declare const Equal: NodeDescription;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Value.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Value.d.ts
new file mode 100644
index 0000000..5be7994
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/Values/Vec4Value.d.ts
@@ -0,0 +1,3 @@
+import { ValueType } from "../../../Values/ValueType.js";
+import { Vec4, Vec4JSON } from "./Internal/Vec4.js";
+export declare const Vec4Value: ValueType<Vec4, Vec4JSON>;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/registerSceneProfile.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/registerSceneProfile.d.ts
new file mode 100644
index 0000000..8461b56
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Profiles/Scene/registerSceneProfile.d.ts
@@ -0,0 +1,3 @@
+import { Registry } from "../../Registry.js";
+import { IScene } from "./Abstractions/IScene.js";
+export declare function registerSceneProfile(registry: Registry, scene?: IScene): Registry;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Registry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Registry.d.ts
new file mode 100644
index 0000000..e0bd90d
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Registry.d.ts
@@ -0,0 +1,6 @@
+import { NodeTypeRegistry } from "./Nodes/Registry/NodeTypeRegistry.js";
+import { ValueTypeRegistry } from "./Values/ValueTypeRegistry.js";
+export declare class Registry {
+    readonly values: ValueTypeRegistry;
+    readonly nodes: NodeTypeRegistry;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Sockets/Socket.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Sockets/Socket.d.ts
new file mode 100644
index 0000000..2a04fcb
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Sockets/Socket.d.ts
@@ -0,0 +1,10 @@
+import { Link } from "../Nodes/Link.js";
+export declare class Socket {
+    readonly valueTypeName: string;
+    readonly name: string;
+    value: any | undefined;
+    readonly label: string | undefined;
+    readonly valueChoices: any[];
+    readonly links: Link[];
+    constructor(valueTypeName: string, name: string, value?: any | undefined, label?: string | undefined, valueChoices?: any[]);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Values/Validation/validateValueRegistry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Values/Validation/validateValueRegistry.d.ts
new file mode 100644
index 0000000..7c8efc4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Values/Validation/validateValueRegistry.d.ts
@@ -0,0 +1,2 @@
+import { Registry } from "../../Registry.js";
+export declare function validateValueRegistry(graphRegistry: Registry): string[];
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueType.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueType.d.ts
new file mode 100644
index 0000000..310d50c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueType.d.ts
@@ -0,0 +1,8 @@
+export declare class ValueType<TValue = any, TJson = any> {
+    readonly name: string;
+    readonly creator: () => TValue;
+    readonly deserialize: (value: TJson) => TValue;
+    readonly serialize: (value: TValue) => TJson;
+    readonly lerp: (start: TValue, end: TValue, t: number) => TValue;
+    constructor(name: string, creator: () => TValue, deserialize: (value: TJson) => TValue, serialize: (value: TValue) => TJson, lerp: (start: TValue, end: TValue, t: number) => TValue);
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueTypeRegistry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueTypeRegistry.d.ts
new file mode 100644
index 0000000..eff82a0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Values/ValueTypeRegistry.d.ts
@@ -0,0 +1,7 @@
+import { ValueType } from "./ValueType.js";
+export declare class ValueTypeRegistry {
+    private readonly valueTypeNameToValueType;
+    register(...valueTypes: Array<ValueType>): void;
+    get(valueTypeName: string): ValueType;
+    getAllNames(): string[];
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/Variables/Variable.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/Variables/Variable.d.ts
new file mode 100644
index 0000000..24c21bd
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/Variables/Variable.d.ts
@@ -0,0 +1,16 @@
+import { EventEmitter } from "../Events/EventEmitter.js";
+import { Metadata } from "../Metadata.js";
+export declare class Variable {
+    readonly id: string;
+    readonly name: string;
+    readonly valueTypeName: string;
+    initialValue: any;
+    private value;
+    label: string;
+    metadata: Metadata;
+    version: number;
+    readonly onChanged: EventEmitter<Variable>;
+    constructor(id: string, name: string, valueTypeName: string, initialValue: any);
+    get(): any;
+    set(newValue: any): void;
+}
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/index.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/index.d.ts
new file mode 100644
index 0000000..f3b9f64
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/index.d.ts
@@ -0,0 +1,95 @@
+export * from "./Diagnostics/Logger.js";
+export * from "./Diagnostics/Assert.js";
+export * from "./Graphs/Graph.js";
+export * from "./Nodes/Node.js";
+export * from "./Nodes/AsyncNode.js";
+export * from "./Nodes/EventNode.js";
+export * from "./Nodes/FlowNode.js";
+export * from "./Nodes/ImmediateNode.js";
+export * from "./Nodes/Link.js";
+export * from "./Values/ValueType.js";
+export * from "./Sockets/Socket.js";
+export * from "./Events/CustomEvent.js";
+export * from "./Events/EventEmitter.js";
+export * from "./Variables/Variable.js";
+export * from "./Nodes/Templates/In4Out1FuncNode.js";
+export * from "./Nodes/Templates/In3Out1FuncNode.js";
+export * from "./Nodes/Templates/In2Out1FuncNode.js";
+export * from "./Nodes/Templates/In1Out1FuncNode.js";
+export * from "./Nodes/Templates/In0Out1FuncNode.js";
+export * from "./Execution/Engine.js";
+export * from "./Execution/Fiber.js";
+export * from "./Graphs/IO/readGraphFromJSON.js";
+export * from "./Graphs/IO/writeGraphToJSON.js";
+export * from "./Graphs/IO/writeNodeSpecsToJSON.js";
+export * from "./Nodes/Registry/NodeCategory.js";
+export * from "./Nodes/Registry/NodeDescription.js";
+export * from "./Nodes/Registry/NodeTypeRegistry.js";
+export * from "./Values/ValueTypeRegistry.js";
+export * from "./Registry.js";
+export * from "./Nodes/Validation/validateNodeRegistry.js";
+export * from "./Values/Validation/validateValueRegistry.js";
+export * from "./validateRegistry.js";
+export * from "./Graphs/Validation/validateGraphAcyclic.js";
+export * from "./Graphs/Validation/validateGraphLinks.js";
+export * from "./Graphs/Validation/validateGraph.js";
+export * from "./Graphs/IO/GraphJSON.js";
+export * from "./Graphs/IO/NodeSpecJSON.js";
+export * from "./Profiles/Core/Abstractions/ILifecycleEventEmitter.js";
+export * from "./Profiles/Core/Abstractions/ILogger.js";
+export * from "./Profiles/Core/Abstractions/Drivers/DefaultLogger.js";
+export * from "./Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js";
+export * from "./Profiles/Core/CustomEvents/OnCustomEvent.js";
+export * from "./Profiles/Core/CustomEvents/TriggerCustomEvent.js";
+export * from "./Profiles/Core/Debug/AssertExpectTrue.js";
+export * from "./Profiles/Core/Debug/DebugLog.js";
+export * from "./Profiles/Core/Flow/Branch.js";
+export * from "./Profiles/Core/Flow/Counter.js";
+export * from "./Profiles/Core/Time/Delay.js";
+export * from "./Profiles/Core/Flow/DoN.js";
+export * from "./Profiles/Core/Flow/DoOnce.js";
+export * from "./Profiles/Core/Flow/Debounce.js";
+export * from "./Profiles/Core/Flow/FlipFlop.js";
+export * from "./Profiles/Core/Flow/ForLoop.js";
+export * from "./Profiles/Core/Flow/Gate.js";
+export * from "./Profiles/Core/Flow/MultieGate.js";
+export * from "./Profiles/Core/Flow/Sequence.js";
+export * from "./Profiles/Core/Flow/Throttle.js";
+export * from "./Profiles/Core/Flow/WaitAll.js";
+export * from "./Profiles/Core/Lifecycle/LifecycleOnEnd.js";
+export * from "./Profiles/Core/Lifecycle/LifecycleOnStart.js";
+export * from "./Profiles/Core/Lifecycle/LifecycleOnTick.js";
+export * as BooleanNodes from "./Profiles/Core/Values/BooleanNodes.js";
+export * from "./Profiles/Core/Values/BooleanValue.js";
+export * as FloatNodes from "./Profiles/Core/Values/FloatNodes.js";
+export * from "./Profiles/Core/Values/FloatValue.js";
+export * as IntegerNodes from "./Profiles/Core/Values/IntegerNodes.js";
+export * from "./Profiles/Core/Values/IntegerValue.js";
+export * as StringNodes from "./Profiles/Core/Values/StringNodes.js";
+export * from "./Profiles/Core/Values/StringValue.js";
+export * from "./Profiles/Core/Variables/VariableSet.js";
+export * from "./Profiles/Core/Variables/VariableGet.js";
+export * from "./Profiles/Core/registerCoreProfile.js";
+export * from "./Profiles/Scene/Abstractions/IScene.js";
+export * from "./Profiles/Scene/Abstractions/Drivers/DummyScene.js";
+export * from "./Profiles/Scene/Actions/SetSceneProperty.js";
+export * from "./Profiles/Scene/Events/OnSceneNodeClick.js";
+export * from "./Profiles/Scene/Logic/VecElements.js";
+export * from "./Profiles/Scene/Queries/GetSceneProperty.js";
+export * from "./Profiles/Scene/Values/Internal/Vec2.js";
+export * from "./Profiles/Scene/Values/Internal/Vec3.js";
+export * from "./Profiles/Scene/Values/Internal/Vec4.js";
+export * as ColorNodes from "./Profiles/Scene/Values/ColorNodes.js";
+export * from "./Profiles/Scene/Values/ColorValue.js";
+export * as EulerNodes from "./Profiles/Scene/Values/EulerNodes.js";
+export * from "./Profiles/Scene/Values/EulerValue.js";
+export * as Vec2Nodes from "./Profiles/Scene/Values/Vec2Nodes.js";
+export * from "./Profiles/Scene/Values/Vec2Value.js";
+export * as Vec3Nodes from "./Profiles/Scene/Values/Vec3Nodes.js";
+export * from "./Profiles/Scene/Values/Vec3Value.js";
+export * as Vec4Nodes from "./Profiles/Scene/Values/Vec4Nodes.js";
+export * from "./Profiles/Scene/Values/Vec4Value.js";
+export * as QuatNodes from "./Profiles/Scene/Values/QuatNodes.js";
+export * from "./Profiles/Scene/Values/QuatValue.js";
+export * from "./Profiles/Scene/registerSceneProfile.js";
+export * from "./parseFloats.js";
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/parseFloats.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/parseFloats.d.ts
new file mode 100644
index 0000000..e3f3cb0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/parseFloats.d.ts
@@ -0,0 +1,3 @@
+export declare function parseSafeFloat(text: string, fallback?: number): number;
+export declare function parseSafeFloats(text: string, fallback?: number): number[];
+export declare function toSafeString(elements: number[]): string;
diff --git a/node_modules/@behave-graph/core/dist/declarations/src/validateRegistry.d.ts b/node_modules/@behave-graph/core/dist/declarations/src/validateRegistry.d.ts
new file mode 100644
index 0000000..b59e564
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/declarations/src/validateRegistry.d.ts
@@ -0,0 +1,2 @@
+import { Registry } from "./Registry.js";
+export declare function validateRegistry(registry: Registry): string[];
diff --git a/node_modules/@behave-graph/core/dist/generateUuid.d.ts b/node_modules/@behave-graph/core/dist/generateUuid.d.ts
new file mode 100644
index 0000000..04682a2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/generateUuid.d.ts
@@ -0,0 +1 @@
+export declare function generateUuid(): string;
diff --git a/node_modules/@behave-graph/core/dist/generateUuid.js b/node_modules/@behave-graph/core/dist/generateUuid.js
new file mode 100644
index 0000000..a54822b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/generateUuid.js
@@ -0,0 +1,20 @@
+/* eslint-disable no-mixed-operators */
+/* eslint-disable no-bitwise */
+// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
+const lut = [];
+for (let i = 0; i < 256; i++) {
+    lut[i] = (i < 16 ? '0' : '') + i.toString(16);
+}
+export function generateUuid() {
+    const d0 = (Math.random() * 0xffffffff) | 0;
+    const d1 = (Math.random() * 0xffffffff) | 0;
+    const d2 = (Math.random() * 0xffffffff) | 0;
+    const d3 = (Math.random() * 0xffffffff) | 0;
+    const uuid = `${lut[d0 & 0xff] +
+        lut[(d0 >> 8) & 0xff] +
+        lut[(d0 >> 16) & 0xff] +
+        lut[(d0 >> 24) & 0xff]}-${lut[d1 & 0xff]}${lut[(d1 >> 8) & 0xff]}-${lut[((d1 >> 16) & 0x0f) | 0x40]}${lut[(d1 >> 24) & 0xff]}-${lut[(d2 & 0x3f) | 0x80]}${lut[(d2 >> 8) & 0xff]}-${lut[(d2 >> 16) & 0xff]}${lut[(d2 >> 24) & 0xff]}${lut[d3 & 0xff]}${lut[(d3 >> 8) & 0xff]}${lut[(d3 >> 16) & 0xff]}${lut[(d3 >> 24) & 0xff]}`;
+    // .toUpperCase() here flattens concatenated strings to save heap memory space.
+    return uuid.toUpperCase();
+}
+//# sourceMappingURL=generateUuid.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/generateUuid.js.map b/node_modules/@behave-graph/core/dist/generateUuid.js.map
new file mode 100644
index 0000000..b1b074c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/generateUuid.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"generateUuid.js","sourceRoot":"","sources":["../src/generateUuid.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,+BAA+B;AAE/B,sGAAsG;AACtG,MAAM,GAAG,GAAa,EAAE,CAAC;AACzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;IAC5B,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;CAC/C;AAED,MAAM,UAAU,YAAY;IAC1B,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;IAC5C,MAAM,IAAI,GAAG,GACX,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC;QACd,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QACrB,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;QACtB,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CACvB,IAAI,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,IACxC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAChC,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAClD,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,IAAI,CACtB,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,GAClE,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,IAAI,CACtB,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;IAErD,+EAA+E;IAC/E,OAAO,IAAI,CAAC,WAAW,EAAE,CAAC;AAC5B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/index.d.ts b/node_modules/@behave-graph/core/dist/index.d.ts
new file mode 100644
index 0000000..c53ac3c
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/index.d.ts
@@ -0,0 +1,78 @@
+export * from './Diagnostics/Logger.js';
+export * from './Diagnostics/Assert.js';
+export * from './parseFloats.js';
+export * from './toCamelCase.js';
+export * from './Easing.js';
+export * from './sleep.js';
+export * from './sequence.js';
+export * from './mathUtilities.js';
+export * from './Graphs/Graph.js';
+export * from './Nodes/Node.js';
+export * from './Nodes/NodeDefinitions.js';
+export * from './Nodes/NodeInstance.js';
+export * from './Nodes/AsyncNode.js';
+export * from './Nodes/EventNode.js';
+export * from './Nodes/FlowNode.js';
+export * from './Nodes/FunctionNode.js';
+export * from './Nodes/Link.js';
+export * from './Values/ValueType.js';
+export * from './Sockets/Socket.js';
+export * from './Events/CustomEvent.js';
+export * from './Events/EventEmitter.js';
+export * from './Values/Variables/Variable.js';
+export * from './Execution/Engine.js';
+export * from './Execution/Fiber.js';
+export * from './Graphs/IO/readGraphFromJSON.js';
+export * from './Graphs/IO/writeGraphToJSON.js';
+export * from './Graphs/IO/writeNodeSpecsToJSON.js';
+export * from './Nodes/Registry/NodeCategory.js';
+export * from './Nodes/Registry/NodeDescription.js';
+export * from './Nodes/Registry/NodeDefinitionsMap.js';
+export * from './Values/ValueTypeMap.js';
+export * from './Registry.js';
+export * from './Nodes/Validation/validateNodeRegistry.js';
+export * from './Values/Validation/validateValueRegistry.js';
+export * from './validateRegistry.js';
+export * from './Graphs/Validation/validateGraphAcyclic.js';
+export * from './Graphs/Validation/validateGraphLinks.js';
+export * from './Graphs/Validation/validateGraph.js';
+export * from './Graphs/IO/GraphJSON.js';
+export * from './Graphs/IO/NodeSpecJSON.js';
+export * from './Profiles/registerSerializersForValueType.js';
+export * from './Profiles/Core/Abstractions/ILifecycleEventEmitter.js';
+export * from './Profiles/Core/Abstractions/ILogger.js';
+export * from './Profiles/Core/Abstractions/Drivers/DefaultLogger.js';
+export * from './Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js';
+export * from './Profiles/Core/CustomEvents/OnCustomEvent.js';
+export * from './Profiles/Core/CustomEvents/TriggerCustomEvent.js';
+export * from './Profiles/Core/Debug/AssertExpectTrue.js';
+export * from './Profiles/Core/Debug/DebugLog.js';
+export * from './Profiles/Core/Flow/Branch.js';
+export * from './Profiles/Core/Flow/Counter.js';
+export * from './Profiles/Core/Time/Delay.js';
+export * from './Profiles/Core/Flow/DoN.js';
+export * from './Profiles/Core/Flow/DoOnce.js';
+export * from './Profiles/Core/Flow/Debounce.js';
+export * from './Profiles/Core/Flow/FlipFlop.js';
+export * from './Profiles/Core/Flow/ForLoop.js';
+export * from './Profiles/Core/Flow/Gate.js';
+export * from './Profiles/Core/Flow/MultiGate.js';
+export * from './Profiles/Core/Flow/Sequence.js';
+export * from './Profiles/Core/Flow/Throttle.js';
+export * from './Profiles/Core/Flow/WaitAll.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnEnd.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnStart.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnTick.js';
+export * as BooleanNodes from './Profiles/Core/Values/BooleanNodes.js';
+export * from './Profiles/Core/Values/BooleanValue.js';
+export * as FloatNodes from './Profiles/Core/Values/FloatNodes.js';
+export * from './Profiles/Core/Values/FloatValue.js';
+export * as IntegerNodes from './Profiles/Core/Values/IntegerNodes.js';
+export * from './Profiles/Core/Values/IntegerValue.js';
+export * as StringNodes from './Profiles/Core/Values/StringNodes.js';
+export * from './Profiles/Core/Values/StringValue.js';
+export * from './Profiles/Core/Variables/VariableSet.js';
+export * from './Profiles/Core/Variables/VariableGet.js';
+export * from './Profiles/Core/registerCoreProfile.js';
+export * from './parseFloats.js';
+export * from './memo.js';
diff --git a/node_modules/@behave-graph/core/dist/index.js b/node_modules/@behave-graph/core/dist/index.js
new file mode 100644
index 0000000..c9605a5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/index.js
@@ -0,0 +1,86 @@
+export * from './Diagnostics/Logger.js';
+export * from './Diagnostics/Assert.js';
+export * from './parseFloats.js';
+export * from './toCamelCase.js';
+export * from './Easing.js';
+export * from './sleep.js';
+export * from './sequence.js';
+export * from './mathUtilities.js';
+// main data model
+export * from './Graphs/Graph.js';
+export * from './Nodes/Node.js';
+export * from './Nodes/NodeDefinitions.js';
+export * from './Nodes/NodeInstance.js';
+export * from './Nodes/AsyncNode.js';
+export * from './Nodes/EventNode.js';
+export * from './Nodes/FlowNode.js';
+export * from './Nodes/FunctionNode.js';
+export * from './Nodes/Link.js';
+export * from './Values/ValueType.js';
+export * from './Sockets/Socket.js';
+export * from './Events/CustomEvent.js';
+export * from './Events/EventEmitter.js';
+export * from './Values/Variables/Variable.js';
+// loading & execution
+export * from './Execution/Engine.js';
+export * from './Execution/Fiber.js';
+export * from './Graphs/IO/readGraphFromJSON.js';
+export * from './Graphs/IO/writeGraphToJSON.js';
+export * from './Graphs/IO/writeNodeSpecsToJSON.js';
+// registry
+export * from './Nodes/Registry/NodeCategory.js';
+export * from './Nodes/Registry/NodeDescription.js';
+export * from './Nodes/Registry/NodeDefinitionsMap.js';
+export * from './Values/ValueTypeMap.js';
+export * from './Registry.js';
+// registry validation
+export * from './Nodes/Validation/validateNodeRegistry.js';
+export * from './Values/Validation/validateValueRegistry.js';
+export * from './validateRegistry.js';
+// graph validation
+export * from './Graphs/Validation/validateGraphAcyclic.js';
+export * from './Graphs/Validation/validateGraphLinks.js';
+export * from './Graphs/Validation/validateGraph.js';
+// json types
+export * from './Graphs/IO/GraphJSON.js';
+export * from './Graphs/IO/NodeSpecJSON.js';
+export * from './Profiles/registerSerializersForValueType.js';
+// core profile
+export * from './Profiles/Core/Abstractions/ILifecycleEventEmitter.js';
+export * from './Profiles/Core/Abstractions/ILogger.js';
+export * from './Profiles/Core/Abstractions/Drivers/DefaultLogger.js';
+export * from './Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js';
+export * from './Profiles/Core/CustomEvents/OnCustomEvent.js';
+export * from './Profiles/Core/CustomEvents/TriggerCustomEvent.js';
+export * from './Profiles/Core/Debug/AssertExpectTrue.js';
+export * from './Profiles/Core/Debug/DebugLog.js';
+export * from './Profiles/Core/Flow/Branch.js';
+export * from './Profiles/Core/Flow/Counter.js';
+export * from './Profiles/Core/Time/Delay.js';
+export * from './Profiles/Core/Flow/DoN.js';
+export * from './Profiles/Core/Flow/DoOnce.js';
+export * from './Profiles/Core/Flow/Debounce.js';
+export * from './Profiles/Core/Flow/FlipFlop.js';
+export * from './Profiles/Core/Flow/ForLoop.js';
+export * from './Profiles/Core/Flow/Gate.js';
+export * from './Profiles/Core/Flow/MultiGate.js';
+export * from './Profiles/Core/Flow/Sequence.js';
+export * from './Profiles/Core/Flow/Throttle.js';
+export * from './Profiles/Core/Flow/WaitAll.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnEnd.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnStart.js';
+export * from './Profiles/Core/Lifecycle/LifecycleOnTick.js';
+export * as BooleanNodes from './Profiles/Core/Values/BooleanNodes.js';
+export * from './Profiles/Core/Values/BooleanValue.js';
+export * as FloatNodes from './Profiles/Core/Values/FloatNodes.js';
+export * from './Profiles/Core/Values/FloatValue.js';
+export * as IntegerNodes from './Profiles/Core/Values/IntegerNodes.js';
+export * from './Profiles/Core/Values/IntegerValue.js';
+export * as StringNodes from './Profiles/Core/Values/StringNodes.js';
+export * from './Profiles/Core/Values/StringValue.js';
+export * from './Profiles/Core/Variables/VariableSet.js';
+export * from './Profiles/Core/Variables/VariableGet.js';
+export * from './Profiles/Core/registerCoreProfile.js';
+export * from './parseFloats.js';
+export * from './memo.js';
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/index.js.map b/node_modules/@behave-graph/core/dist/index.js.map
new file mode 100644
index 0000000..54f8af4
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,cAAc,yBAAyB,CAAC;AACxC,cAAc,yBAAyB,CAAC;AAExC,cAAc,kBAAkB,CAAC;AACjC,cAAc,kBAAkB,CAAC;AACjC,cAAc,aAAa,CAAC;AAC5B,cAAc,YAAY,CAAC;AAC3B,cAAc,eAAe,CAAC;AAC9B,cAAc,oBAAoB,CAAC;AAEnC,kBAAkB;AAClB,cAAc,mBAAmB,CAAC;AAClC,cAAc,iBAAiB,CAAC;AAChC,cAAc,4BAA4B,CAAC;AAC3C,cAAc,yBAAyB,CAAC;AACxC,cAAc,sBAAsB,CAAC;AACrC,cAAc,sBAAsB,CAAC;AACrC,cAAc,qBAAqB,CAAC;AACpC,cAAc,yBAAyB,CAAC;AACxC,cAAc,iBAAiB,CAAC;AAChC,cAAc,uBAAuB,CAAC;AACtC,cAAc,qBAAqB,CAAC;AACpC,cAAc,yBAAyB,CAAC;AACxC,cAAc,0BAA0B,CAAC;AACzC,cAAc,gCAAgC,CAAC;AAE/C,sBAAsB;AACtB,cAAc,uBAAuB,CAAC;AACtC,cAAc,sBAAsB,CAAC;AACrC,cAAc,kCAAkC,CAAC;AACjD,cAAc,iCAAiC,CAAC;AAChD,cAAc,qCAAqC,CAAC;AAEpD,WAAW;AACX,cAAc,kCAAkC,CAAC;AACjD,cAAc,qCAAqC,CAAC;AACpD,cAAc,wCAAwC,CAAC;AACvD,cAAc,0BAA0B,CAAC;AACzC,cAAc,eAAe,CAAC;AAE9B,sBAAsB;AACtB,cAAc,4CAA4C,CAAC;AAC3D,cAAc,8CAA8C,CAAC;AAC7D,cAAc,uBAAuB,CAAC;AAEtC,mBAAmB;AACnB,cAAc,6CAA6C,CAAC;AAC5D,cAAc,2CAA2C,CAAC;AAC1D,cAAc,sCAAsC,CAAC;AAErD,aAAa;AACb,cAAc,0BAA0B,CAAC;AACzC,cAAc,6BAA6B,CAAC;AAE5C,cAAc,+CAA+C,CAAC;AAE9D,eAAe;AACf,cAAc,wDAAwD,CAAC;AACvE,cAAc,yCAAyC,CAAC;AACxD,cAAc,uDAAuD,CAAC;AACtE,cAAc,qEAAqE,CAAC;AACpF,cAAc,+CAA+C,CAAC;AAC9D,cAAc,oDAAoD,CAAC;AACnE,cAAc,2CAA2C,CAAC;AAC1D,cAAc,mCAAmC,CAAC;AAClD,cAAc,gCAAgC,CAAC;AAC/C,cAAc,iCAAiC,CAAC;AAChD,cAAc,+BAA+B,CAAC;AAC9C,cAAc,6BAA6B,CAAC;AAC5C,cAAc,gCAAgC,CAAC;AAC/C,cAAc,kCAAkC,CAAC;AACjD,cAAc,kCAAkC,CAAC;AACjD,cAAc,iCAAiC,CAAC;AAChD,cAAc,8BAA8B,CAAC;AAC7C,cAAc,mCAAmC,CAAC;AAClD,cAAc,kCAAkC,CAAC;AACjD,cAAc,kCAAkC,CAAC;AACjD,cAAc,iCAAiC,CAAC;AAChD,cAAc,6CAA6C,CAAC;AAC5D,cAAc,+CAA+C,CAAC;AAC9D,cAAc,8CAA8C,CAAC;AAC7D,OAAO,KAAK,YAAY,MAAM,wCAAwC,CAAC;AACvE,cAAc,wCAAwC,CAAC;AACvD,OAAO,KAAK,UAAU,MAAM,sCAAsC,CAAC;AACnE,cAAc,sCAAsC,CAAC;AACrD,OAAO,KAAK,YAAY,MAAM,wCAAwC,CAAC;AACvE,cAAc,wCAAwC,CAAC;AACvD,OAAO,KAAK,WAAW,MAAM,uCAAuC,CAAC;AACrE,cAAc,uCAAuC,CAAC;AACtD,cAAc,0CAA0C,CAAC;AACzD,cAAc,0CAA0C,CAAC;AACzD,cAAc,wCAAwC,CAAC;AAEvD,cAAc,kBAAkB,CAAC;AACjC,cAAc,WAAW,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/mathUtilities.d.ts b/node_modules/@behave-graph/core/dist/mathUtilities.d.ts
new file mode 100644
index 0000000..5fe7084
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/mathUtilities.d.ts
@@ -0,0 +1,6 @@
+export declare const EPSILON = 0.000001;
+export declare function equalsTolerance(a: number, b: number, tolerance?: number): boolean;
+export declare function equalsAutoTolerance(a: number, b: number): boolean;
+export declare function degreesToRadians(a: number): number;
+export declare function radiansToDegrees(a: number): number;
+export declare function clamp(a: number, min: number, max: number): number;
diff --git a/node_modules/@behave-graph/core/dist/mathUtilities.js b/node_modules/@behave-graph/core/dist/mathUtilities.js
new file mode 100644
index 0000000..3dfc9b5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/mathUtilities.js
@@ -0,0 +1,18 @@
+export const EPSILON = 0.000001; // chosen from gl-matrix
+export function equalsTolerance(a, b, tolerance = EPSILON) {
+    return Math.abs(a - b) < tolerance;
+}
+// taken from gl-matrix
+export function equalsAutoTolerance(a, b) {
+    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
+}
+export function degreesToRadians(a) {
+    return a * (Math.PI / 180);
+}
+export function radiansToDegrees(a) {
+    return a * (180 / Math.PI);
+}
+export function clamp(a, min, max) {
+    return a < min ? min : a > max ? max : a;
+}
+//# sourceMappingURL=mathUtilities.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/mathUtilities.js.map b/node_modules/@behave-graph/core/dist/mathUtilities.js.map
new file mode 100644
index 0000000..6e9ca27
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/mathUtilities.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"mathUtilities.js","sourceRoot":"","sources":["../src/mathUtilities.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,wBAAwB;AAEzD,MAAM,UAAU,eAAe,CAC7B,CAAS,EACT,CAAS,EACT,YAAoB,OAAO;IAE3B,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;AACrC,CAAC;AAED,uBAAuB;AACvB,MAAM,UAAU,mBAAmB,CAAC,CAAS,EAAE,CAAS;IACtD,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5E,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,CAAS;IACxC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,CAAS;IACxC,OAAO,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,KAAK,CAAC,CAAS,EAAE,GAAW,EAAE,GAAW;IACvD,OAAO,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3C,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/memo.d.ts b/node_modules/@behave-graph/core/dist/memo.d.ts
new file mode 100644
index 0000000..c56b77f
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/memo.d.ts
@@ -0,0 +1,2 @@
+export declare function memo<T>(func: () => T): () => T;
+export declare function asyncMemo<T>(func: () => Promise<T>): () => Promise<T>;
diff --git a/node_modules/@behave-graph/core/dist/memo.js b/node_modules/@behave-graph/core/dist/memo.js
new file mode 100644
index 0000000..d91d3dc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/memo.js
@@ -0,0 +1,19 @@
+export function memo(func) {
+    let cache;
+    return () => {
+        if (cache === undefined) {
+            cache = func();
+        }
+        return cache;
+    };
+}
+export function asyncMemo(func) {
+    let cache;
+    return async () => {
+        if (cache === undefined) {
+            cache = await func();
+        }
+        return cache;
+    };
+}
+//# sourceMappingURL=memo.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/memo.js.map b/node_modules/@behave-graph/core/dist/memo.js.map
new file mode 100644
index 0000000..f1f8d7b
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/memo.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"memo.js","sourceRoot":"","sources":["../src/memo.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,IAAI,CAAI,IAAa;IACnC,IAAI,KAAoB,CAAC;IACzB,OAAO,GAAM,EAAE;QACb,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,KAAK,GAAG,IAAI,EAAE,CAAC;SAChB;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,SAAS,CAAI,IAAsB;IACjD,IAAI,KAAoB,CAAC;IACzB,OAAO,KAAK,IAAgB,EAAE;QAC5B,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,KAAK,GAAG,MAAM,IAAI,EAAE,CAAC;SACtB;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;AACJ,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/parseFloats.d.ts b/node_modules/@behave-graph/core/dist/parseFloats.d.ts
new file mode 100644
index 0000000..e3f3cb0
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/parseFloats.d.ts
@@ -0,0 +1,3 @@
+export declare function parseSafeFloat(text: string, fallback?: number): number;
+export declare function parseSafeFloats(text: string, fallback?: number): number[];
+export declare function toSafeString(elements: number[]): string;
diff --git a/node_modules/@behave-graph/core/dist/parseFloats.js b/node_modules/@behave-graph/core/dist/parseFloats.js
new file mode 100644
index 0000000..2287ffe
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/parseFloats.js
@@ -0,0 +1,19 @@
+const cSeparator = /[^\d+.-]+/;
+export function parseSafeFloat(text, fallback = 0) {
+    try {
+        return Number.parseFloat(text);
+    }
+    catch {
+        return fallback;
+    }
+}
+export function parseSafeFloats(text, fallback = 0) {
+    return text
+        .split(cSeparator)
+        .filter(Boolean)
+        .map((value) => parseSafeFloat(value, fallback));
+}
+export function toSafeString(elements) {
+    return `[${elements.join(',')}]`;
+}
+//# sourceMappingURL=parseFloats.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/parseFloats.js.map b/node_modules/@behave-graph/core/dist/parseFloats.js.map
new file mode 100644
index 0000000..d7d8680
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/parseFloats.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"parseFloats.js","sourceRoot":"","sources":["../src/parseFloats.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,GAAG,WAAW,CAAC;AAE/B,MAAM,UAAU,cAAc,CAAC,IAAY,EAAE,QAAQ,GAAG,CAAC;IACvD,IAAI;QACF,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KAChC;IAAC,MAAM;QACN,OAAO,QAAQ,CAAC;KACjB;AACH,CAAC;AACD,MAAM,UAAU,eAAe,CAAC,IAAY,EAAE,QAAQ,GAAG,CAAC;IACxD,OAAO,IAAI;SACR,KAAK,CAAC,UAAU,CAAC;SACjB,MAAM,CAAC,OAAO,CAAC;SACf,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;AACrD,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,QAAkB;IAC7C,OAAO,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;AACnC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/sequence.d.ts b/node_modules/@behave-graph/core/dist/sequence.d.ts
new file mode 100644
index 0000000..3220461
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sequence.d.ts
@@ -0,0 +1 @@
+export declare function sequence(start: number, end: number, step?: number): Generator<number, void, unknown>;
diff --git a/node_modules/@behave-graph/core/dist/sequence.js b/node_modules/@behave-graph/core/dist/sequence.js
new file mode 100644
index 0000000..3cce857
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sequence.js
@@ -0,0 +1,10 @@
+//stackoverflow.com/a/54335525
+export function* sequence(start, end, step = 1) {
+    let state = start;
+    while (state < end) {
+        yield state;
+        state += step;
+    }
+    return;
+}
+//# sourceMappingURL=sequence.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/sequence.js.map b/node_modules/@behave-graph/core/dist/sequence.js.map
new file mode 100644
index 0000000..29e2415
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sequence.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"sequence.js","sourceRoot":"","sources":["../src/sequence.ts"],"names":[],"mappings":"AAAA,8BAA8B;AAC9B,MAAM,SAAS,CAAC,CAAC,QAAQ,CAAC,KAAa,EAAE,GAAW,EAAE,IAAI,GAAG,CAAC;IAC5D,IAAI,KAAK,GAAG,KAAK,CAAC;IAClB,OAAO,KAAK,GAAG,GAAG,EAAE;QAClB,MAAM,KAAK,CAAC;QACZ,KAAK,IAAI,IAAI,CAAC;KACf;IACD,OAAO;AACT,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/sleep.d.ts b/node_modules/@behave-graph/core/dist/sleep.d.ts
new file mode 100644
index 0000000..a44a6c5
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sleep.d.ts
@@ -0,0 +1 @@
+export declare function sleep(durationInSeconds: number): Promise<unknown>;
diff --git a/node_modules/@behave-graph/core/dist/sleep.js b/node_modules/@behave-graph/core/dist/sleep.js
new file mode 100644
index 0000000..16bb5b2
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sleep.js
@@ -0,0 +1,5 @@
+/* eslint-disable no-promise-executor-return */
+export function sleep(durationInSeconds) {
+    return new Promise((resolve) => setTimeout(resolve, Math.round(durationInSeconds * 1000)));
+}
+//# sourceMappingURL=sleep.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/sleep.js.map b/node_modules/@behave-graph/core/dist/sleep.js.map
new file mode 100644
index 0000000..18702bc
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/sleep.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"sleep.js","sourceRoot":"","sources":["../src/sleep.ts"],"names":[],"mappings":"AAAA,+CAA+C;AAC/C,MAAM,UAAU,KAAK,CAAC,iBAAyB;IAC7C,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAC7B,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,iBAAiB,GAAG,IAAI,CAAC,CAAC,CAC1D,CAAC;AACJ,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/toCamelCase.d.ts b/node_modules/@behave-graph/core/dist/toCamelCase.d.ts
new file mode 100644
index 0000000..d01ab4e
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/toCamelCase.d.ts
@@ -0,0 +1 @@
+export declare function toCamelCase(text: string): string;
diff --git a/node_modules/@behave-graph/core/dist/toCamelCase.js b/node_modules/@behave-graph/core/dist/toCamelCase.js
new file mode 100644
index 0000000..f72b037
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/toCamelCase.js
@@ -0,0 +1,7 @@
+export function toCamelCase(text) {
+    if (text.length > 0) {
+        return text.slice(0, 1).toLocaleUpperCase() + text.slice(1);
+    }
+    return text;
+}
+//# sourceMappingURL=toCamelCase.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/toCamelCase.js.map b/node_modules/@behave-graph/core/dist/toCamelCase.js.map
new file mode 100644
index 0000000..7bca674
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/toCamelCase.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"toCamelCase.js","sourceRoot":"","sources":["../src/toCamelCase.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,WAAW,CAAC,IAAY;IACtC,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,iBAAiB,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;KAC7D;IACD,OAAO,IAAI,CAAC;AACd,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/tsconfig.tsbuildinfo b/node_modules/@behave-graph/core/dist/tsconfig.tsbuildinfo
new file mode 100644
index 0000000..d013997
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/tsconfig.tsbuildinfo
@@ -0,0 +1 @@
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.dom.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../node_modules/typescript/lib/lib.decorators.d.ts","../../../node_modules/typescript/lib/lib.decorators.legacy.d.ts","../src/Easing.ts","../src/Metadata.ts","../src/Diagnostics/Assert.ts","../src/Events/EventEmitter.ts","../src/sleep.ts","../src/Execution/resolveSocketValue.ts","../src/Execution/Fiber.ts","../src/Execution/Engine.ts","../src/Nodes/NodeSockets.ts","../src/Nodes/Registry/NodeCategory.ts","../src/Nodes/Registry/NodeDescription.ts","../src/Nodes/Node.ts","../src/Nodes/NodeInstance.ts","../src/Nodes/Link.ts","../src/Sockets/Socket.ts","../src/Events/CustomEvent.ts","../src/Diagnostics/Logger.ts","../src/parseFloats.ts","../src/toCamelCase.ts","../src/sequence.ts","../src/mathUtilities.ts","../src/Nodes/AsyncNode.ts","../src/Nodes/EventNode.ts","../src/Nodes/FlowNode.ts","../src/Nodes/FunctionNode.ts","../src/Values/ValueType.ts","../src/Values/Variables/Variable.ts","../src/Values/ValueTypeMap.ts","../src/Graphs/IO/GraphJSON.ts","../src/Graphs/IO/readGraphFromJSON.ts","../src/Graphs/IO/writeGraphToJSON.ts","../src/Graphs/IO/NodeSpecJSON.ts","../src/Graphs/IO/writeNodeSpecsToJSON.ts","../src/Nodes/Validation/validateNodeRegistry.ts","../src/Values/Validation/validateValueRegistry.ts","../src/validateRegistry.ts","../src/Graphs/Validation/validateGraphAcyclic.ts","../src/Graphs/Validation/validateGraphLinks.ts","../src/Graphs/Validation/validateGraph.ts","../src/Profiles/registerSerializersForValueType.ts","../src/Profiles/Core/Abstractions/ILifecycleEventEmitter.ts","../src/Profiles/Core/Abstractions/ILogger.ts","../src/Profiles/Core/Abstractions/Drivers/DefaultLogger.ts","../src/Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.ts","../src/Profiles/Core/CustomEvents/OnCustomEvent.ts","../src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts","../src/Profiles/Core/Debug/AssertExpectTrue.ts","../src/Profiles/Core/Debug/DebugLog.ts","../src/Profiles/Core/Flow/Branch.ts","../src/Profiles/Core/Flow/Counter.ts","../src/Profiles/Core/Time/Delay.ts","../src/Profiles/Core/Flow/DoN.ts","../src/Profiles/Core/Flow/DoOnce.ts","../src/Profiles/Core/Flow/Debounce.ts","../src/Profiles/Core/Flow/FlipFlop.ts","../src/Profiles/Core/Flow/ForLoop.ts","../src/Profiles/Core/Flow/Gate.ts","../src/Profiles/Core/Flow/MultiGate.ts","../src/Profiles/Core/Flow/Sequence.ts","../src/Profiles/Core/Flow/Throttle.ts","../src/Profiles/Core/Flow/WaitAll.ts","../src/Profiles/Core/Lifecycle/LifecycleOnEnd.ts","../src/Profiles/Core/Lifecycle/LifecycleOnStart.ts","../src/Profiles/Core/Lifecycle/LifecycleOnTick.ts","../src/Profiles/Core/Values/BooleanNodes.ts","../src/Profiles/Core/Values/BooleanValue.ts","../src/Profiles/Core/Values/FloatNodes.ts","../src/Profiles/Core/Values/FloatValue.ts","../src/Profiles/Core/Values/IntegerNodes.ts","../src/Profiles/Core/Values/IntegerValue.ts","../src/Profiles/Core/Values/StringNodes.ts","../src/Profiles/Core/Values/StringValue.ts","../src/Profiles/Core/Variables/VariableSet.ts","../src/Profiles/Core/Variables/VariableGet.ts","../src/memo.ts","../src/Profiles/Core/Flow/SwitchOnInteger.ts","../src/Profiles/Core/Flow/SwitchOnString.ts","../src/Profiles/Core/Logic/Easing.ts","../src/Profiles/Core/Time/TimeNodes.ts","../src/Profiles/Core/registerCoreProfile.ts","../src/index.ts","../src/Graphs/Graph.ts","../src/Nodes/nodeFactory.ts","../src/Nodes/NodeDefinitions.ts","../src/Nodes/Registry/NodeDefinitionsMap.ts","../src/Registry.ts","../src/generateUuid.ts","../src/Nodes/testUtils.ts","../src/Nodes/Registry/DependenciesRegistry.ts","../../../node_modules/@types/aria-query/index.d.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/d3-array/index.d.ts","../../../node_modules/@types/d3-selection/index.d.ts","../../../node_modules/@types/d3-axis/index.d.ts","../../../node_modules/@types/d3-brush/index.d.ts","../../../node_modules/@types/d3-chord/index.d.ts","../../../node_modules/@types/d3-color/index.d.ts","../../../node_modules/@types/geojson/index.d.ts","../../../node_modules/@types/d3-contour/index.d.ts","../../../node_modules/@types/d3-delaunay/index.d.ts","../../../node_modules/@types/d3-dispatch/index.d.ts","../../../node_modules/@types/d3-drag/index.d.ts","../../../node_modules/@types/d3-dsv/index.d.ts","../../../node_modules/@types/d3-ease/index.d.ts","../../../node_modules/@types/d3-fetch/index.d.ts","../../../node_modules/@types/d3-force/index.d.ts","../../../node_modules/@types/d3-format/index.d.ts","../../../node_modules/@types/d3-geo/index.d.ts","../../../node_modules/@types/d3-hierarchy/index.d.ts","../../../node_modules/@types/d3-interpolate/index.d.ts","../../../node_modules/@types/d3-path/index.d.ts","../../../node_modules/@types/d3-polygon/index.d.ts","../../../node_modules/@types/d3-quadtree/index.d.ts","../../../node_modules/@types/d3-random/index.d.ts","../../../node_modules/@types/d3-time/index.d.ts","../../../node_modules/@types/d3-scale/index.d.ts","../../../node_modules/@types/d3-scale-chromatic/index.d.ts","../../../node_modules/@types/d3-shape/index.d.ts","../../../node_modules/@types/d3-time-format/index.d.ts","../../../node_modules/@types/d3-timer/index.d.ts","../../../node_modules/@types/d3-transition/index.d.ts","../../../node_modules/@types/d3-zoom/index.d.ts","../../../node_modules/@types/d3/index.d.ts","../../../node_modules/@types/draco3d/index.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/readline/promises.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@types/glob/node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/glob/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/ci-info/index.d.ts","../../../node_modules/@types/is-ci/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/@jest/expect-utils/build/index.d.ts","../../../node_modules/jest-matcher-utils/node_modules/chalk/index.d.ts","../../../node_modules/@sinclair/typebox/typebox.d.ts","../../../node_modules/@jest/schemas/build/index.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/expect/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/minimist/index.d.ts","../../../node_modules/@types/normalize-package-data/index.d.ts","../../../node_modules/@types/offscreencanvas/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/prop-types/index.d.ts","../../../node_modules/@types/react/ts5.0/global.d.ts","../../../node_modules/csstype/index.d.ts","../../../node_modules/@types/scheduler/tracing.d.ts","../../../node_modules/@types/react/ts5.0/index.d.ts","../../../node_modules/@types/react-dom/index.d.ts","../../../node_modules/@types/scheduler/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/stats.js/index.d.ts","../../../node_modules/@types/testing-library__jest-dom/matchers.d.ts","../../../node_modules/@types/testing-library__jest-dom/index.d.ts","../../../node_modules/@types/three/src/constants.d.ts","../../../node_modules/@types/three/src/Three.Legacy.d.ts","../../../node_modules/@types/three/src/math/Interpolant.d.ts","../../../node_modules/@types/three/src/math/interpolants/DiscreteInterpolant.d.ts","../../../node_modules/@types/three/src/math/interpolants/LinearInterpolant.d.ts","../../../node_modules/@types/three/src/math/interpolants/CubicInterpolant.d.ts","../../../node_modules/@types/three/src/animation/KeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/VectorKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/StringKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/QuaternionKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/NumberKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/ColorKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/tracks/BooleanKeyframeTrack.d.ts","../../../node_modules/@types/three/src/animation/PropertyMixer.d.ts","../../../node_modules/@types/three/src/animation/PropertyBinding.d.ts","../../../node_modules/@types/three/src/math/Matrix3.d.ts","../../../node_modules/@types/three/src/core/BufferAttribute.d.ts","../../../node_modules/@types/three/src/core/InterleavedBuffer.d.ts","../../../node_modules/@types/three/src/core/InterleavedBufferAttribute.d.ts","../../../node_modules/@types/three/src/math/Quaternion.d.ts","../../../node_modules/@types/three/src/math/Matrix4.d.ts","../../../node_modules/@types/three/src/math/Euler.d.ts","../../../node_modules/@types/three/src/core/Layers.d.ts","../../../node_modules/@types/three/src/math/ColorManagement.d.ts","../../../node_modules/@types/three/src/math/Color.d.ts","../../../node_modules/@types/three/src/scenes/Fog.d.ts","../../../node_modules/@types/three/src/math/Vector2.d.ts","../../../node_modules/@types/three/src/math/Vector4.d.ts","../../../node_modules/@types/three/src/math/Triangle.d.ts","../../../node_modules/@types/three/src/math/Box3.d.ts","../../../node_modules/@types/three/src/math/Sphere.d.ts","../../../node_modules/@types/three/src/math/Line3.d.ts","../../../node_modules/@types/three/src/math/Plane.d.ts","../../../node_modules/@types/three/src/core/EventDispatcher.d.ts","../../../node_modules/@types/three/src/renderers/shaders/UniformsLib.d.ts","../../../node_modules/@types/three/src/renderers/shaders/ShaderLib.d.ts","../../../node_modules/@types/three/src/materials/Material.d.ts","../../../node_modules/@types/three/src/textures/Source.d.ts","../../../node_modules/@types/three/src/textures/Texture.d.ts","../../../node_modules/@types/three/src/scenes/Scene.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLCapabilities.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLExtensions.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLShader.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLState.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLProperties.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLUtils.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLTextures.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLUniforms.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLProgram.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLInfo.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLObjects.d.ts","../../../node_modules/@types/three/src/textures/DepthTexture.d.ts","../../../node_modules/@types/three/src/renderers/WebGLRenderTarget.d.ts","../../../node_modules/@types/three/src/lights/LightShadow.d.ts","../../../node_modules/@types/three/src/lights/Light.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLShadowMap.d.ts","../../../node_modules/@types/three/src/objects/Group.d.ts","../../../node_modules/@types/three/src/core/GLBufferAttribute.d.ts","../../../node_modules/@types/three/src/core/BufferGeometry.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLRenderLists.d.ts","../../../node_modules/@types/three/src/renderers/WebGLMultipleRenderTargets.d.ts","../../../node_modules/@types/webxr/index.d.ts","../../../node_modules/@types/three/src/cameras/PerspectiveCamera.d.ts","../../../node_modules/@types/three/src/cameras/ArrayCamera.d.ts","../../../node_modules/@types/three/src/renderers/webxr/WebXRController.d.ts","../../../node_modules/@types/three/src/renderers/webxr/WebXRManager.d.ts","../../../node_modules/@types/three/src/textures/types.d.ts","../../../node_modules/@types/three/src/textures/Data3DTexture.d.ts","../../../node_modules/@types/three/src/textures/DataArrayTexture.d.ts","../../../node_modules/@types/three/src/renderers/WebGLRenderer.d.ts","../../../node_modules/@types/three/src/math/Ray.d.ts","../../../node_modules/@types/three/src/core/Raycaster.d.ts","../../../node_modules/@types/three/src/core/Object3D.d.ts","../../../node_modules/@types/three/src/cameras/Camera.d.ts","../../../node_modules/@types/three/src/math/Spherical.d.ts","../../../node_modules/@types/three/src/math/Cylindrical.d.ts","../../../node_modules/@types/three/src/math/Vector3.d.ts","../../../node_modules/@types/three/src/objects/Bone.d.ts","../../../node_modules/@types/three/src/animation/AnimationClip.d.ts","../../../node_modules/@types/three/src/animation/AnimationUtils.d.ts","../../../node_modules/@types/three/src/animation/AnimationObjectGroup.d.ts","../../../node_modules/@types/three/src/animation/AnimationAction.d.ts","../../../node_modules/@types/three/src/animation/AnimationMixer.d.ts","../../../node_modules/@types/three/src/audio/AudioContext.d.ts","../../../node_modules/@types/three/src/audio/AudioListener.d.ts","../../../node_modules/@types/three/src/audio/Audio.d.ts","../../../node_modules/@types/three/src/audio/PositionalAudio.d.ts","../../../node_modules/@types/three/src/audio/AudioAnalyser.d.ts","../../../node_modules/@types/three/src/cameras/StereoCamera.d.ts","../../../node_modules/@types/three/src/cameras/OrthographicCamera.d.ts","../../../node_modules/@types/three/src/textures/CubeTexture.d.ts","../../../node_modules/@types/three/src/renderers/WebGLCubeRenderTarget.d.ts","../../../node_modules/@types/three/src/cameras/CubeCamera.d.ts","../../../node_modules/@types/three/src/core/Uniform.d.ts","../../../node_modules/@types/three/src/core/UniformsGroup.d.ts","../../../node_modules/@types/three/src/core/InstancedBufferGeometry.d.ts","../../../node_modules/@types/three/src/core/InstancedInterleavedBuffer.d.ts","../../../node_modules/@types/three/src/core/InstancedBufferAttribute.d.ts","../../../node_modules/@types/three/src/core/Clock.d.ts","../../../node_modules/@types/three/src/extras/core/Curve.d.ts","../../../node_modules/@types/three/src/extras/curves/EllipseCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/ArcCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/CatmullRomCurve3.d.ts","../../../node_modules/@types/three/src/extras/curves/CubicBezierCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/CubicBezierCurve3.d.ts","../../../node_modules/@types/three/src/extras/curves/LineCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/LineCurve3.d.ts","../../../node_modules/@types/three/src/extras/curves/QuadraticBezierCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/QuadraticBezierCurve3.d.ts","../../../node_modules/@types/three/src/extras/curves/SplineCurve.d.ts","../../../node_modules/@types/three/src/extras/curves/Curves.d.ts","../../../node_modules/@types/three/src/extras/core/CurvePath.d.ts","../../../node_modules/@types/three/src/extras/core/Path.d.ts","../../../node_modules/@types/three/src/extras/core/Shape.d.ts","../../../node_modules/@types/three/src/extras/core/ShapePath.d.ts","../../../node_modules/@types/three/src/extras/core/Interpolations.d.ts","../../../node_modules/@types/three/src/extras/DataUtils.d.ts","../../../node_modules/@types/three/src/extras/ImageUtils.d.ts","../../../node_modules/@types/three/src/extras/ShapeUtils.d.ts","../../../node_modules/@types/three/src/extras/PMREMGenerator.d.ts","../../../node_modules/@types/three/src/geometries/BoxGeometry.d.ts","../../../node_modules/@types/three/src/geometries/CapsuleGeometry.d.ts","../../../node_modules/@types/three/src/geometries/CircleGeometry.d.ts","../../../node_modules/@types/three/src/geometries/CylinderGeometry.d.ts","../../../node_modules/@types/three/src/geometries/ConeGeometry.d.ts","../../../node_modules/@types/three/src/geometries/PolyhedronGeometry.d.ts","../../../node_modules/@types/three/src/geometries/DodecahedronGeometry.d.ts","../../../node_modules/@types/three/src/geometries/EdgesGeometry.d.ts","../../../node_modules/@types/three/src/geometries/ExtrudeGeometry.d.ts","../../../node_modules/@types/three/src/geometries/IcosahedronGeometry.d.ts","../../../node_modules/@types/three/src/geometries/LatheGeometry.d.ts","../../../node_modules/@types/three/src/geometries/OctahedronGeometry.d.ts","../../../node_modules/@types/three/src/geometries/PlaneGeometry.d.ts","../../../node_modules/@types/three/src/geometries/RingGeometry.d.ts","../../../node_modules/@types/three/src/geometries/ShapeGeometry.d.ts","../../../node_modules/@types/three/src/geometries/SphereGeometry.d.ts","../../../node_modules/@types/three/src/geometries/TetrahedronGeometry.d.ts","../../../node_modules/@types/three/src/geometries/TorusGeometry.d.ts","../../../node_modules/@types/three/src/geometries/TorusKnotGeometry.d.ts","../../../node_modules/@types/three/src/geometries/TubeGeometry.d.ts","../../../node_modules/@types/three/src/geometries/WireframeGeometry.d.ts","../../../node_modules/@types/three/src/geometries/Geometries.d.ts","../../../node_modules/@types/three/src/objects/Line.d.ts","../../../node_modules/@types/three/src/objects/LineSegments.d.ts","../../../node_modules/@types/three/src/helpers/SpotLightHelper.d.ts","../../../node_modules/@types/three/src/helpers/SkeletonHelper.d.ts","../../../node_modules/@types/three/src/lights/PointLightShadow.d.ts","../../../node_modules/@types/three/src/lights/PointLight.d.ts","../../../node_modules/@types/three/src/helpers/PointLightHelper.d.ts","../../../node_modules/@types/three/src/lights/HemisphereLight.d.ts","../../../node_modules/@types/three/src/materials/MeshBasicMaterial.d.ts","../../../node_modules/@types/three/src/helpers/HemisphereLightHelper.d.ts","../../../node_modules/@types/three/src/helpers/GridHelper.d.ts","../../../node_modules/@types/three/src/helpers/PolarGridHelper.d.ts","../../../node_modules/@types/three/src/lights/DirectionalLightShadow.d.ts","../../../node_modules/@types/three/src/lights/DirectionalLight.d.ts","../../../node_modules/@types/three/src/helpers/DirectionalLightHelper.d.ts","../../../node_modules/@types/three/src/helpers/CameraHelper.d.ts","../../../node_modules/@types/three/src/helpers/BoxHelper.d.ts","../../../node_modules/@types/three/src/helpers/Box3Helper.d.ts","../../../node_modules/@types/three/src/helpers/PlaneHelper.d.ts","../../../node_modules/@types/three/src/objects/Mesh.d.ts","../../../node_modules/@types/three/src/helpers/ArrowHelper.d.ts","../../../node_modules/@types/three/src/helpers/AxesHelper.d.ts","../../../node_modules/@types/three/src/lights/SpotLightShadow.d.ts","../../../node_modules/@types/three/src/lights/SpotLight.d.ts","../../../node_modules/@types/three/src/lights/RectAreaLight.d.ts","../../../node_modules/@types/three/src/lights/AmbientLight.d.ts","../../../node_modules/@types/three/src/math/SphericalHarmonics3.d.ts","../../../node_modules/@types/three/src/lights/LightProbe.d.ts","../../../node_modules/@types/three/src/lights/AmbientLightProbe.d.ts","../../../node_modules/@types/three/src/lights/HemisphereLightProbe.d.ts","../../../node_modules/@types/three/src/loaders/Loader.d.ts","../../../node_modules/@types/three/src/loaders/LoadingManager.d.ts","../../../node_modules/@types/three/src/loaders/AnimationLoader.d.ts","../../../node_modules/@types/three/src/textures/CompressedTexture.d.ts","../../../node_modules/@types/three/src/loaders/CompressedTextureLoader.d.ts","../../../node_modules/@types/three/src/textures/DataTexture.d.ts","../../../node_modules/@types/three/src/loaders/DataTextureLoader.d.ts","../../../node_modules/@types/three/src/loaders/CubeTextureLoader.d.ts","../../../node_modules/@types/three/src/loaders/TextureLoader.d.ts","../../../node_modules/@types/three/src/loaders/ObjectLoader.d.ts","../../../node_modules/@types/three/src/loaders/MaterialLoader.d.ts","../../../node_modules/@types/three/src/loaders/BufferGeometryLoader.d.ts","../../../node_modules/@types/three/src/loaders/ImageLoader.d.ts","../../../node_modules/@types/three/src/loaders/ImageBitmapLoader.d.ts","../../../node_modules/@types/three/src/loaders/FileLoader.d.ts","../../../node_modules/@types/three/src/loaders/LoaderUtils.d.ts","../../../node_modules/@types/three/src/loaders/Cache.d.ts","../../../node_modules/@types/three/src/loaders/AudioLoader.d.ts","../../../node_modules/@types/three/src/materials/ShadowMaterial.d.ts","../../../node_modules/@types/three/src/materials/SpriteMaterial.d.ts","../../../node_modules/@types/three/src/materials/ShaderMaterial.d.ts","../../../node_modules/@types/three/src/materials/RawShaderMaterial.d.ts","../../../node_modules/@types/three/src/materials/PointsMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshStandardMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshPhysicalMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshPhongMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshToonMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshNormalMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshLambertMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshDepthMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshDistanceMaterial.d.ts","../../../node_modules/@types/three/src/materials/MeshMatcapMaterial.d.ts","../../../node_modules/@types/three/src/materials/LineBasicMaterial.d.ts","../../../node_modules/@types/three/src/materials/LineDashedMaterial.d.ts","../../../node_modules/@types/three/src/materials/Materials.d.ts","../../../node_modules/@types/three/src/math/interpolants/QuaternionLinearInterpolant.d.ts","../../../node_modules/@types/three/src/objects/Sprite.d.ts","../../../node_modules/@types/three/src/math/Frustum.d.ts","../../../node_modules/@types/three/src/math/Box2.d.ts","../../../node_modules/@types/three/src/math/MathUtils.d.ts","../../../node_modules/@types/three/src/objects/LOD.d.ts","../../../node_modules/@types/three/src/objects/InstancedMesh.d.ts","../../../node_modules/@types/three/src/objects/Skeleton.d.ts","../../../node_modules/@types/three/src/objects/SkinnedMesh.d.ts","../../../node_modules/@types/three/src/objects/LineLoop.d.ts","../../../node_modules/@types/three/src/objects/Points.d.ts","../../../node_modules/@types/three/src/renderers/WebGL1Renderer.d.ts","../../../node_modules/@types/three/src/renderers/WebGL3DRenderTarget.d.ts","../../../node_modules/@types/three/src/renderers/WebGLArrayRenderTarget.d.ts","../../../node_modules/@types/three/src/renderers/shaders/UniformsUtils.d.ts","../../../node_modules/@types/three/src/renderers/shaders/ShaderChunk.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLBufferRenderer.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLClipping.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLCubeUVMaps.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLAttributes.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLGeometries.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLIndexedBufferRenderer.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLLights.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLCubeMaps.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLBindingStates.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLPrograms.d.ts","../../../node_modules/@types/three/src/renderers/webgl/WebGLUniformsGroups.d.ts","../../../node_modules/@types/three/src/scenes/FogExp2.d.ts","../../../node_modules/@types/three/src/textures/VideoTexture.d.ts","../../../node_modules/@types/three/src/textures/CompressedArrayTexture.d.ts","../../../node_modules/@types/three/src/textures/CanvasTexture.d.ts","../../../node_modules/@types/three/src/textures/FramebufferTexture.d.ts","../../../node_modules/@types/three/src/Three.d.ts","../../../node_modules/@types/three/index.d.ts","../../../node_modules/@types/uuid/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"6a6b471e7e43e15ef6f8fe617a22ce4ecb0e34efa6c3dfcfe7cebd392bcca9d2","affectsGlobalScope":true,"impliedFormat":1},{"version":"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","impliedFormat":1},{"version":"dc48272d7c333ccf58034c0026162576b7d50ea0e69c3b9292f803fc20720fd5","impliedFormat":1},{"version":"27147504487dc1159369da4f4da8a26406364624fa9bc3db632f7d94a5bae2c3","impliedFormat":1},{"version":"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","impliedFormat":1},{"version":"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","impliedFormat":1},{"version":"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4","impliedFormat":1},{"version":"fcd3ecc9f764f06f4d5c467677f4f117f6abf49dee6716283aa204ff1162498b","affectsGlobalScope":true,"impliedFormat":1},{"version":"9a60b92bca4c1257db03b349d58e63e4868cfc0d1c8d0ba60c2dbc63f4e6c9f6","affectsGlobalScope":true,"impliedFormat":1},{"version":"f296963760430fb65b4e5d91f0ed770a91c6e77455bacf8fa23a1501654ede0e","affectsGlobalScope":true,"impliedFormat":1},{"version":"5114a95689b63f96b957e00216bc04baf9e1a1782aa4d8ee7e5e9acbf768e301","affectsGlobalScope":true,"impliedFormat":1},{"version":"4443e68b35f3332f753eacc66a04ac1d2053b8b035a0e0ac1d455392b5e243b3","affectsGlobalScope":true,"impliedFormat":1},{"version":"ab22100fdd0d24cfc2cc59d0a00fc8cf449830d9c4030dc54390a46bd562e929","affectsGlobalScope":true,"impliedFormat":1},{"version":"f7bd636ae3a4623c503359ada74510c4005df5b36de7f23e1db8a5c543fd176b","affectsGlobalScope":true,"impliedFormat":1},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true,"impliedFormat":1},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true,"impliedFormat":1},{"version":"0c20f4d2358eb679e4ae8a4432bdd96c857a2960fd6800b21ec4008ec59d60ea","affectsGlobalScope":true,"impliedFormat":1},{"version":"36ae84ccc0633f7c0787bc6108386c8b773e95d3b052d9464a99cd9b8795fbec","affectsGlobalScope":true,"impliedFormat":1},{"version":"82d0d8e269b9eeac02c3bd1c9e884e85d483fcb2cd168bccd6bc54df663da031","affectsGlobalScope":true,"impliedFormat":1},{"version":"b8deab98702588840be73d67f02412a2d45a417a3c097b2e96f7f3a42ac483d1","affectsGlobalScope":true,"impliedFormat":1},{"version":"4738f2420687fd85629c9efb470793bb753709c2379e5f85bc1815d875ceadcd","affectsGlobalScope":true,"impliedFormat":1},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true,"impliedFormat":1},{"version":"376d554d042fb409cb55b5cbaf0b2b4b7e669619493c5d18d5fa8bd67273f82a","affectsGlobalScope":true,"impliedFormat":1},{"version":"9fc46429fbe091ac5ad2608c657201eb68b6f1b8341bd6d670047d32ed0a88fa","affectsGlobalScope":true,"impliedFormat":1},{"version":"61c37c1de663cf4171e1192466e52c7a382afa58da01b1dc75058f032ddf0839","affectsGlobalScope":true,"impliedFormat":1},{"version":"c4138a3dd7cd6cf1f363ca0f905554e8d81b45844feea17786cdf1626cb8ea06","affectsGlobalScope":true,"impliedFormat":1},{"version":"6ff3e2452b055d8f0ec026511c6582b55d935675af67cdb67dd1dc671e8065df","affectsGlobalScope":true,"impliedFormat":1},{"version":"03de17b810f426a2f47396b0b99b53a82c1b60e9cba7a7edda47f9bb077882f4","affectsGlobalScope":true,"impliedFormat":1},{"version":"8184c6ddf48f0c98429326b428478ecc6143c27f79b79e85740f17e6feb090f1","affectsGlobalScope":true,"impliedFormat":1},{"version":"261c4d2cf86ac5a89ad3fb3fafed74cbb6f2f7c1d139b0540933df567d64a6ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"6af1425e9973f4924fca986636ac19a0cf9909a7e0d9d3009c349e6244e957b6","affectsGlobalScope":true,"impliedFormat":1},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true,"impliedFormat":1},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true,"impliedFormat":1},{"version":"15a630d6817718a2ddd7088c4f83e4673fde19fa992d2eae2cf51132a302a5d3","affectsGlobalScope":true,"impliedFormat":1},{"version":"b7e9f95a7387e3f66be0ed6db43600c49cec33a3900437ce2fd350d9b7cb16f2","affectsGlobalScope":true,"impliedFormat":1},{"version":"01e0ee7e1f661acedb08b51f8a9b7d7f959e9cdb6441360f06522cc3aea1bf2e","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac17a97f816d53d9dd79b0d235e1c0ed54a8cc6a0677e9a3d61efb480b2a3e4e","affectsGlobalScope":true,"impliedFormat":1},{"version":"bf14a426dbbf1022d11bd08d6b8e709a2e9d246f0c6c1032f3b2edb9a902adbe","affectsGlobalScope":true,"impliedFormat":1},{"version":"ec0104fee478075cb5171e5f4e3f23add8e02d845ae0165bfa3f1099241fa2aa","affectsGlobalScope":true,"impliedFormat":1},{"version":"2b72d528b2e2fe3c57889ca7baef5e13a56c957b946906d03767c642f386bbc3","affectsGlobalScope":true,"impliedFormat":1},{"version":"9cc66b0513ad41cb5f5372cca86ef83a0d37d1c1017580b7dace3ea5661836df","affectsGlobalScope":true,"impliedFormat":1},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true,"impliedFormat":1},{"version":"307c8b7ebbd7f23a92b73a4c6c0a697beca05b06b036c23a34553e5fe65e4fdc","affectsGlobalScope":true,"impliedFormat":1},{"version":"189c0703923150aa30673fa3de411346d727cc44a11c75d05d7cf9ef095daa22","affectsGlobalScope":true,"impliedFormat":1},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true,"impliedFormat":1},{"version":"0ed0c1b83ddd369cc971af1367ce4b6b9faa6618ba3337760891acad0173214f","signature":"6055f679dba55251e5e18411eee5c0d6e276870c4965d5d7742641eb336c4b9f","impliedFormat":99},{"version":"2940e713c3ff77c06ad9ec3f6ac52ecbc190d00bbe784e3e35e93cce4a4cf023","signature":"0363e366ab52157a03de5ce63ac4139d78a8e15f6dfb86f1c33cb40e335b9ea1","impliedFormat":99},{"version":"75abc243ddc4f01a643c72ec066dea5654f1eaf4869a7152fa8070cfdfad6632","signature":"47e49ef0a1ff0104658e56d9e53ff19c159789314e7b1748decd6cab9e985a23","impliedFormat":99},{"version":"acfb1cb0dd644a640aa913da95c1e86b382d57b28a237477766aae50c60d45bd","signature":"fc95fc5f478a54ec501fe9b017366256c89f5f7893baf1d9adc659b6dabcb725","impliedFormat":99},{"version":"751d33e02ba2939a59f825f128af5e5411c1754879fa7ec360c598ef1aeb8b7d","signature":"3979852a6b1017e4e81c551504c000ef55fe8d2e62221b472689adfb4b889ae6","impliedFormat":99},{"version":"f969815db74cd8bfd4b05cfc8ad0a2acfcca6f6d2ebf79ead018afaf1b3337e5","signature":"f473a6c877f7e25807fe72cb7f61cb756584c8bd33ef83fa5217215af71a8c47","impliedFormat":99},{"version":"a52e348d166d6fb6db24fb4794a799bf66d8a0512a422b57c150c00a33c28305","signature":"9fb77d7d73a6d554553eba29bcec9ee79c619d529cdff06167b55e523cb21a5f","impliedFormat":99},{"version":"1a0f17b89fb7504752f6c915ea7e807f4cb48f3bee81e291df9e41084f503965","signature":"c006727c6fb1d1449ec2e476045e5b8ee1541369a5757faf9fdd569e8dcc9f64","impliedFormat":99},{"version":"6df95e9c2bf60b595394788a097dc56a34b13c99c7a7474390d44652c1fa0b60","signature":"7ce2565023c43fec4d925120701b07cb6235afe88c208530aec546a8d5c77026","impliedFormat":99},{"version":"9078f0ab5ae006c23c83df078c5c0691c4f3be732388bf3cd8e7f213870148d7","signature":"011be651e623fa7559f116e09dab7614fc691590a2e11e71b448562cd1760199","impliedFormat":99},{"version":"21a64f325d6fde1ccba40b9b8eae191799c581f67f637b7dfb1355dc98460315","signature":"bd34631d5994b8f9e8ef5765c6207ce78fecd9b02d235c425a761a10b438d791","impliedFormat":99},{"version":"f9300771e6ba9da09f8284b8779ac08a2f6a2aba6da5b90ced7e0ef425e2a87a","signature":"9256eb9698300ce695c284e6efc71a58a563fcd2661d456dc37ddbaa697ab591","impliedFormat":99},{"version":"0f36e32885097c3c17f4fe2593618d6ea827c9cb67170faff784408f5f4ddd83","signature":"c71c77a9fa0191f8b6899b4029ec593f45d9530f9fb7320f2d4ea4441c1e87b4","impliedFormat":99},{"version":"ac6befbef54806515510ec6dc2ed066e81a21c310b0844239be82fc19cab456f","signature":"b3743de1cfbc3c199e726d301c885c49de9a719b11c9d1772fdb2efbd98aecb1","impliedFormat":99},{"version":"a0c52279086a27360a13ac8f60671987252e39b5758f4ac15f94da3545613b56","signature":"c9e0372fc8e65b83dfd1a6c681d7f4e9e49e64ab2e036fa4f866eb2994ab7676","impliedFormat":99},{"version":"22591911df6c67ce3e2c81b137ef6ba65fd564d7ca1a134fcf30f96d4b4d62ad","signature":"f6e78b17026bd0c1042befada612fbea4a99f76887996a25bdf8314efb1f585c","impliedFormat":99},{"version":"022cd11f5eb5e0a6fed82700b1c9b13b7f394cf46145d7783730aa38cc058e12","signature":"e2eac8eed9b898c9fffc7df5eb128a6aade7b34e50279a5af78f22b15de0039a","impliedFormat":99},{"version":"a8731d8305de46c55379aa58965a9614d852742bf9d33f1972c4e3699255261b","signature":"836a3868995d8fcc2f16b47eb65dabbde0fee17c63dbf43efa18de1aa5759618","impliedFormat":99},{"version":"828efb876872889be4b130694260da3e2b6a766799b238cc946c8c975679c005","signature":"33628ad4ca34bd93e6a2ccf57826f40b05b2770c4150ce068160da99e4857508","impliedFormat":99},{"version":"a505cad078b7b6f4e4021451ded75298de3c46a6b4be4f23f8f8f124b025dd51","signature":"2a757d8225dfb1ddfd448ea61268206b10a183417169874b3c41c54f135938c2","impliedFormat":99},{"version":"9f0a3ce5737afaf2d171339f6317fcb8253b7e41b6e4d90a6b6989b8ecc19f27","signature":"116d3e78d489bc3ff42f0b9cddb9e3cfe8464eda4a5e0136df11a4524c21bbda","impliedFormat":99},{"version":"5cd5941b3ab59de0751b311fb1cca5b38b058d3c864ff1b62049c1061fe09293","signature":"1bbad23a5ab7d25606b6e77aac7c33a270d80ee6433df594cd4e66da318d21de","impliedFormat":99},{"version":"36d89e63b0a4f90b3b5140ea00f14499bc471495dcaad63adde303009a226d85","signature":"fee9076a50b53c1cca3ed754639578292775916634c4998aae434e3fa72f39a6","impliedFormat":99},{"version":"5d7c23eba0070e89402c44bfd5db48b3f5168deed6f89f6a07f826d09a4fef1a","signature":"4df5be4a7d2b80f13eeee9ddfb024688925de23298303cc2b26aae6389547788","impliedFormat":99},{"version":"0db785c76c1a4636c57ab9e232f7ca37a6ef5631578c1a4fdcf3fecc53860331","signature":"6688ce222bf1ea4d0a57ca7ee8f99f234299a4afa524cfde730110c04fb097e9","impliedFormat":99},{"version":"5acfd7eb1a84346b19c2dbf9d089c3fd983a7a848b3acae59e654359d7a7c131","signature":"b501b36580d4f920e5bc20ef719eaff982d1d38309c8ac8055ec76e8e70160ec","impliedFormat":99},{"version":"ec44a3b826ce2cd959f7874dfdec0e7eb80c4c7da0ce29534ccb5d702fe3343a","signature":"e7722307cea950c0cfafca9f4cf20572c29b6ecfb9002ce11d8f3ef7ab2f10ab","impliedFormat":99},{"version":"92fb962f6882dc4bce8b21b6b4acd92888f32809d9556685d43370ba23acc9b6","signature":"139487c3004a67c90d42e0e507759552cf9107f7559d592f891de133e85a04ec","impliedFormat":99},{"version":"4f7e219d98619990c35ea42a1e7f05f6b5409a8224c46a7c2c4c4bcfbdfe5401","signature":"c24fe81e2f51d619d0d7e2f38ddd825f4b062c7bf9fc9aacd97920462bf3740e","impliedFormat":99},{"version":"1dcdf686d12bb02893879f9b6dc4d4788afaa5f64a2bb349cc90f5de24bdb1d9","signature":"3d546c149b8900d5bcbad1e3e4bfdb3688ae0394a8341d25a66d941453b4684f","impliedFormat":99},{"version":"94d285ed3e42080bd8817d1f8b6c6f5669f384d8e51ea8c54018540fbdc87a84","signature":"278ad7d9f5cbaeaf91e198dc62ec0fcc0d538459c8ba9374e9089ec07c61f5ee","impliedFormat":99},{"version":"d5cdb4c090b35755ae98e9f32fd9ae15d54ee091e00fab38c94f6bf4f595efca","signature":"e8e87e00326f4f091a2e90fcc9e87208e43cda6410f3ca73454e0506c4e9fae4","impliedFormat":99},{"version":"67fce170688f0bb98b976ebe71acb601a38f2caf159ab4b027f5f72fbfaef8fb","signature":"8c6c3bf03f45316013ca50bf9f1156710667e4e49691dcf48c31f4ee88ec94e6","impliedFormat":99},{"version":"d0c6b1629156fe9e13de97c6d75234145cb807c96a5aad12d0e245a0551388fd","signature":"ca255bf70d0c940ee79c09cb21ee67faab9e171d6b3d38a209a4078325b59e69","impliedFormat":99},{"version":"b77ae9df1925614e79bf08471ddf6ce98b61ee4eaaa43a07ceb5a6bcafcbbdba","signature":"0c2ce1c0ddd75acdbe5e28979b61444d700325e03d425f2af985f1ab6508e091","impliedFormat":99},{"version":"4174df22ffb12d8287f38b4423cf42aeaa1a5a37fe7a75f2b57b84989a1aa4b6","signature":"8d14eb32b9de4e544e08ee40eb35794e934e70771e1f56b9b5f9c541913f2d27","impliedFormat":99},{"version":"9689fb2bb8f953326378c940427a38829d0c9ef939610a455db74adb45515ff4","signature":"48fddb5dff6363e1f0d778e54b7ffbb8a0fabed0f225da34177400b1c6f84d5e","impliedFormat":99},{"version":"84f1e20fbaf952ba5dd913dbed35119c4a25da3bd9b5198aa1ffa445cc397819","signature":"a7c4f44616d42740d5eeacf8ab14fcb7357b3f14c5c1a9ef03bca90dee3fc9a6","impliedFormat":99},{"version":"485f655238071ebacd9123c5f2d19c4b2611e7957e142bf58619cb7233d90524","signature":"840a0265deef2c3bf0e712b0b832de9c5ffdc12ba392da7b24afe11faa650b1e","impliedFormat":99},{"version":"1df2831649650ee49962f55763002410a358d34203ddc74f573a4b743f566023","signature":"792f694c7c887eac146012939619b8745cb8f25f11f33b542f41bc2f600fe39d","impliedFormat":99},{"version":"afda9be5fc0956d06d5d2f037f5cec7ade1c21f8812509fff5a448da8d59c964","signature":"713ee3e5979c822cd2aa57e0a4414ddc416fe957459dc4010caa078a8e3cad80","impliedFormat":99},{"version":"acfd4e6948c96ebbd2fc3a5dccce678ae36193a21fe3e1d080c5635a84db6621","signature":"85ec9ab1bddd86b101aef127bf690ecb3ff14d6fd77300d3255809bf19b99d6e","impliedFormat":99},{"version":"f06c011986568d562eaebb5afabcb2ff6aadaaeab12b45bfa1727feaf269909a","signature":"af254b8e4a76718693f8d23780e4487238d7c55f7b0946862c569fe131e20395","impliedFormat":99},{"version":"35ddabb6368eb8974687bc604578f0cb7fc26bdd7368fd32a936fb20cae1a88b","signature":"2d258453269fc1ebc598ed0813a9a24efb525f2642684319c22a61b736f5d9dd","impliedFormat":99},{"version":"7cb96965fbf57e7fdb9b493875649781b463bb967204cccaaf0dd691feed071b","signature":"a2718ed50d0b39b7f17e8d00aea43067a4570be0a848a7b5cc1dfe5a94929e02","impliedFormat":99},{"version":"c67082de37a76b4720ff9fe7d026a37669ce67c2b2d4062bb0dadf8330998b34","signature":"297a4523cb4d031e11ecde3d396795eb86c2169aa3887092a7e535eed1e71ba7","impliedFormat":99},{"version":"036f50e8e9fc926a74c035ff70acd7684114b405d1b20bc0679da28f08c62052","signature":"9d08f166dca861b2d9eaf6864f47e41bd9fcdbd34fd202918ebaad5c4c66e88f","impliedFormat":99},{"version":"cfebfcb663a04c9b9285970754c2cb19b2825e8d4121908b3c5eb7805dab6e53","signature":"68062b8ec8df9718422a18e22c9251c8d8869b113ced7850aad9fbde26f43fe1","impliedFormat":99},{"version":"5045cf75f32e4528d97fa17974b0d2dda1c64e767c357ae97d00d379a3025513","signature":"f6b2b3434bd826bd05a039c995a2dc9b0f4abe227bf155598cf080a608889639","impliedFormat":99},{"version":"e3381b911b34c253c55ef6cc02404234820a76bae6bd59fe0c756602061374bb","signature":"75dac44c6ba392de81273544340c39ee09741e9f02f7690dac19c324a826a8a6","impliedFormat":99},{"version":"7cdebcf584db804b9604e072ac3032e1b92b3037bd5f09af82b40a2309516a15","signature":"03e6686126bf67074081504ecb14f00620802899f01b2cb824378fbccee879d8","impliedFormat":99},{"version":"2c046e1c0dc5c6f28d2b41483c54c7cb3af18d51cba0e84e7f322bd6c36f86c2","signature":"1ed99be157f205ad0c4a4cf3e9de2e5cf61dc93d1ac0397107e6bd6c63cb5815","impliedFormat":99},{"version":"85e013c601a4ff6e2dcac67b6c7590c2631ddfeebe72f7ec51120124bfafe1c9","signature":"261a836bef91b3b2f94ddeacdd9f9f32abacd51420e45ee64e2fc2bba2e5af6b","impliedFormat":99},{"version":"cfe3149c73fb23918fb5d4894e49ef3071c528afa7583eaab3fcb072db5f0f1d","signature":"8426c6bbad50113a1786a7eba103321c1040ee19532a0ba11dd1a6d835da4507","impliedFormat":99},{"version":"cb1ceec921fd9f5ab99fd9e5bfabbdae6992a18997f7be97dbe457a28f610138","signature":"f183774e3cd6c9c59c7b317c9171025f34ec322f01e19b0f3fd12ebad74e6de5","impliedFormat":99},{"version":"ee53e6c349392c3fa8a3df9454a8d45f828504e455a05a767f2d8b3eeb105cd5","signature":"07ed26b7834bf83551413d8b7cb12b395fd533c6cb2b3209592aea96488719e0","impliedFormat":99},{"version":"67f08129afcb2400149bfa9a9f56c776fc34d821403d0d7cd565b61872d7929f","signature":"ab5d3ac1d63cc89ce333ae7aaaa66befdb01472ad68c5ca63c6f4a1a60ff2d00","impliedFormat":99},{"version":"77ed2a9b0d4a165e99b37f47134036fe57ecd531df3a667385887e7af7814c7d","signature":"473881e04d4a326d60d306ffe3440ee01133c8d1ce5d77dbee1353249d422db2","impliedFormat":99},{"version":"c92fe8cac4501922cadc297f97aeba73a275b427e491d28b86be39cf48d7a379","signature":"cbb50d63740fdd5b7f8b3d0107646c521286d12a5d401547c9c149870210042b","impliedFormat":99},{"version":"c4f1dbf918618940690cae33639adaf2c0ce91f3955e21f8ec80179779ec09ca","signature":"4c03b732905adae5bd76bc22c4a7d3746dbb278f7d3f1a1192f333867ea0e497","impliedFormat":99},{"version":"47fdf3dc24da0750066385f5d4516958c40e4b41909a677a00099abfc62f9a9c","signature":"8abcd7207b1cad72476a458e29cf11f69041f2035dca36a0f9782ae5d052933b","impliedFormat":99},{"version":"796f5cf7123ef6cce5175fa07b00d19a5d6c69bd3edc90da46216a40ff332655","signature":"74c380bfdbd6484637a8291535d4c1a6546d69bfe0d1dc17f1c1eca473bba637","impliedFormat":99},{"version":"51e8243b21f2460d808183e0a0baf198c63a577edc91fde31acd498e71ae10ca","signature":"7b9051507f6d3b0c8631db42e46e933d5f2cafacb1e21f67f0a89c77178811d2","impliedFormat":99},{"version":"5e900114905127ffde9027d4437fcebe1a23ca455fca02382792238f6b78c062","signature":"06dbbe071a8780af71b255abfa693215cfc9dcad340f4e4811fa23d02be1ed2f","impliedFormat":99},{"version":"b403a39232f615c49d7f9e919bb276817517e3bc26fc489cef80845bed17eda7","signature":"e2fa1692a66fdeb467e2e59a70eb9dcb274a5ec109c0a7b0aae0176a9aec5dd3","impliedFormat":99},{"version":"fe8ad6541f7283e79bf8ac956a87f65162fdeeae255a25c5c409754f1e16ff87","signature":"c87f56e076a2954a0b51e2014321e51dbed05e6a3bbd21badf56557974a4f600","impliedFormat":99},{"version":"1fb5217a0e7525329727562e97745337f4b26a9f3d2b42ea0f480711aa68cdf1","signature":"3d63645938089e1ac1a217f9b7fc0bf676447d51c3ce514fed8b502721e04f31","impliedFormat":99},{"version":"5803a00500f94002f6ea2a63f0fe26b50a70bed3382d7ba0f64d9156b84cf660","signature":"581c0996d7ba99a6c9ddf30d01794cc8986aed8788d47d27390e1907b73a7ab9","impliedFormat":99},{"version":"f1621b993f3b1d88be0218d8bcdf78e6f0b4217a97c0ebba17f9e028071488fb","signature":"a041fbbb7ff53f633b797f2fcd57c53fe4c227029460b223e43ca9d80b11866e","impliedFormat":99},{"version":"5562986a476367be46d1bffc641ae6e2fc47f11a5dfd3b3e96c690e482e8f703","signature":"cda2926b13e5f6f54a74eb4d36637d1a965660630d82ea883e1fb9122cb1350f","impliedFormat":99},{"version":"936d7706f6518a4b8634f3f5d1da43fd68c8c1e276ff1945e500e0fa47520d3b","signature":"e346353348673d6ee1ef5f75774ea509df950b6eae510ff6f5b1a56654dfa3ab","impliedFormat":99},{"version":"ba3914221d4fb14cf34fb6c37e91de1b6a6f81489dd461b21edd6a93fae13ba0","signature":"5d260d88a487d376a3045fb2d60d0f13b37b0f43c73045fb7cbb3374bfc8a6ff","impliedFormat":99},{"version":"2903bb43c78582990f7f8638e7058b8a5d1ec6c7647d5158e5ab3d92c0f736b4","signature":"2f54210e83e412d1e04b0bd267709f4400e7f629c131e9dd67a96137bf450b54","impliedFormat":99},{"version":"0b26592263a25e9a187fa06c6b2e1575cdba95ec7a6064716e985457fb9da18c","signature":"802569677d4ef745e650622081698871360b710a0911e0b464e4fcc6c71a8488","impliedFormat":99},{"version":"9dc26fd9ef0865bd51aa8e6e16a712d94d1b97d493220ceda378ae8d332b73a3","signature":"0fab5f30529f24d8b07f933debf0750279f383ef438a0688e2524b967eb01362","impliedFormat":99},{"version":"3ab8e92099a9509eb97675e550b55539dfc3db9823fc1cf50f8c1c27673f7010","signature":"618b2941d2f21cf16103b2c64ec895124da9963655ab4a5a0efaa1d038ac7897","impliedFormat":99},{"version":"297c55a28c2d4ebb369794b7f7b9791e9e3a844b1e6a73d7ed7cc536528822ba","signature":"2e81ea73d2e2387235a22997c763b48949505c8df0a08ea0159008d0f489d7d7","impliedFormat":99},{"version":"41087fb7faab93c8c3176046d326267b596ad12ec86a462a0395c70817850678","signature":"004f72c8d8c6c7534fea140e8e1234bbe13f1d8ce34eefbdde5c18855e119a59","impliedFormat":99},{"version":"be1e13635d730a1a49d94ec9c93bdbfa656045b7a786479d433a7991ebc173a1","signature":"d8152f11a2cd1ddf1d078b508ff6dea43b5e3d33a7df6b0f6b31236c2fb17a97","impliedFormat":99},{"version":"6897ed7f5db20a79bbe2582c221b4bebf6282797719f49d67170c80457a7a6c7","signature":"bff2b38eb23df5688cddacd71f0eb8f7c6e52fafd4c78d50497ebff8e14e8851","impliedFormat":99},{"version":"2bc95957289d2f1eae5b138feb78c8ec146914e49b6042d7738184fee7d5574f","signature":"6a984037b087e4829411c2350c32c2c1968ceda5e7c221925328288751918c30","impliedFormat":99},{"version":"f9abc0d8a738e48654647980728e6e3090f1df75f264bf0b7341ffac1efa6279","signature":"a957ed9d9242fa2b607304a54fb3c69ce1feea92ecc6bfb631c752e045d6e494","impliedFormat":99},{"version":"e210a26379b14cf11c19eabf6b19421042662438b2a1851d5f6cd18357247a74","signature":"d89a7c65ce8356421100e3db98ea7b72bc486543310c3dcbdf282b78fb6dbc48","impliedFormat":99},{"version":"5b2ebd183e07984129d8bff59d5da4a2a9723e196ca7ab5a9d4f9b90079dc73f","signature":"3844d78131e57e78e4338b9243f7c1f3399614e2497b5924c65bda1e99517791","impliedFormat":99},{"version":"0dbd2502343d292d460f8a3a83fe4f9cf07a9306acab1274312fdc71456d881f","signature":"0cbbb6ea4545e865653f0b9be40d9d493440e55d57614919b89bd68681addd1f","impliedFormat":99},{"version":"b573c8fdf9add874691dd31bd4b9be599674734c884a0e8d0eee85f3d5d064d8","signature":"2892852110c1be4325c8188fb2c441e77babad60ab6e30d3e5f06cde0eac90c9","impliedFormat":99},{"version":"7330858be0cb97572668483fd95f52dea6aed930cdf9575ca1418b326d958c98","signature":"49269390ba2c553a14871ddb334d463e059954db6e06448c8ed27b9f5cbd7a9c","impliedFormat":99},{"version":"20e5849616e1d5c5acbec83256c126cb71353b73d3eeea279260e825985ad04c","signature":"2e0333f214cc661e8a7fbefeb914bf38cb7c161db601fe1940a217de2ade8ea3","impliedFormat":99},{"version":"528426129373c3ddb9d9e8d60849e18524bb15d2242df284a59bd555c3dab686","signature":"49aa489a2a9557fe02a1e8e138682f6bd755c606e556aee50ddc462732d4cc21","impliedFormat":99},{"version":"21522c0f405e58c8dd89cd97eb3d1aa9865ba017fde102d01f86ab50b44e5610","impliedFormat":1},{"version":"ac65f04c2df0218cb8e54f012745cbfcc3c0e67c1f6b1e557d88842bbb72e2db","impliedFormat":1},{"version":"cc957354aa3c94c9961ebf46282cfde1e81d107fc5785a61f62c67f1dd3ac2eb","impliedFormat":1},{"version":"a2e86df4db576d80704e25293cec6f20fc6101a11f4747440e2eef58fb3c860c","impliedFormat":1},{"version":"93de1c6dab503f053efe8d304cb522bb3a89feab8c98f307a674a4fae04773e9","impliedFormat":1},{"version":"6704f0b54df85640baaeebd86c9d4a1dbb661d5a4d57a75bc84162f562f6531d","impliedFormat":1},{"version":"9d255af1b09c6697089d3c9bf438292a298d8b7a95c68793c9aae80afc9e5ca7","impliedFormat":1},{"version":"4fa5c6721346cafc445797831da394916f173d79a8343ac8bbf183d06042e869","impliedFormat":1},{"version":"a8c897d63ae6e779bbc4f4753a386389dfc3a45ceec6b6672f55b072d822d302","impliedFormat":1},{"version":"8fddb452bfcb60c598245e997aa9c9dce14b85a4c2e02489a50d97ab49e9b622","impliedFormat":1},{"version":"25d505ffc43befd205d780441b0a16e752ec1028f383a55cadd41841d1c7f153","impliedFormat":1},{"version":"39cb5be3f5302e759253b89f11bd3e885930b5649b840f4d5a81a763a5dd6c40","impliedFormat":1},{"version":"8a460dcdabe873ab0a85e421a7f339ad74445f60917bf67deed7d15d836b0247","impliedFormat":1},{"version":"a3b6c93a9838b8c94c6998e85646d6f2d07c20ecfe1e235dba62158b29451391","impliedFormat":1},{"version":"8f2d349c69976569d4c32e0e4e66598c9688159cac28cde38bbe0039dd1cadfa","impliedFormat":1},{"version":"6adc0305186bd1f72ca64adbd054b8e5e71f93b1d0623e90ebabf153541c06c0","impliedFormat":1},{"version":"c85a93f216df4ebb6dfea7ad46c8d6161a0f1948a20967ba0c85f0fff3f9edcd","impliedFormat":1},{"version":"0df330f74158aee4ce076b0bb15eb53fab95f615d26ccbd6ec6f5c4273110047","impliedFormat":1},{"version":"7b2ff705f3c3358807afce85ef146b7f7cdc882a79442630b034ec24d6a3906e","impliedFormat":1},{"version":"344ac2d6764eaa6b23b2e8e736c9bf0ae06a53479c6a1371d3d89ac964022692","impliedFormat":1},{"version":"e5907221fa3198e26f294ad77bf8f2996990b40484fe6781b65e099b1fe57933","impliedFormat":1},{"version":"ada362e162ad90df10c921c845546d911a6ad648a641a6945bf08c3ef1a09a17","impliedFormat":1},{"version":"f156602a8527c97f898fc96a33b7e025eed27870c2a63842c0c9ed506d7203ea","impliedFormat":1},{"version":"a8c34714c5da0bb0d2f74d31a44c9fb8b3b87efe6d8a0891182f9f6077723e69","impliedFormat":1},{"version":"4b51be04eb5bd9b929448380b3ced483ef1f6c3bbfaf7d3425bdbfa3b8eab11f","impliedFormat":1},{"version":"c24944ff5879b91478b153cf16802b9c6a10cfa3b7d85855813a08431ec2d36a","impliedFormat":1},{"version":"f1ba7a42f644ba5a281dd41b4bfc813d1f4a59e9c99227315cf778284d1e0b22","impliedFormat":1},{"version":"7adc301a699032ffd6d57e9ce97b2507e2ad652771cda558cb7ebb49a06e7696","impliedFormat":1},{"version":"f6319ead2de997fe24e6acc3594942d6819a4570f40e42cb979f5b078f3da1ca","impliedFormat":1},{"version":"4d3ae1585844151755e9d76cc41d82a6770b150559cb318c5366c869d487e01f","impliedFormat":1},{"version":"589cbf58df97db61280be456952054f5d54070e87a2c371303844a4bb288d8fa","impliedFormat":1},{"version":"c4e910182d6de2fcb3922631733faafdecd593370248adc1013be93352a8cc78","impliedFormat":1},{"version":"6bbf574c575a0491388f32aaa69c648140f24637b1d98ea6f3c97074c339f9e9","impliedFormat":1},{"version":"07104ffff8802481908f08b4a220e399cc692d5edcfaaa7e6632156fc267be35","affectsGlobalScope":true,"impliedFormat":1},{"version":"3e135eeb6a6be4b07c1d2a170c105dde5f8b5c705f9be4e0f01166259724f125","impliedFormat":1},{"version":"f6c30cfb96957bb21586996d7c5d5861c236417f31b5f790055624c7df07e944","impliedFormat":1},{"version":"be04184c354d4b7207e68298ea4e0539cd3e55889778f3bad120c71593ad408e","impliedFormat":1},{"version":"37cf86c0651242b9b8c1b0bf89228a7be8ae40db6f3aac0b9e1de75bc7ddd5cb","impliedFormat":1},{"version":"32e5beeefac1493f9dbf2498eb4de6b5ef69a411eb1b9321cdf25a6f37086361","impliedFormat":1},{"version":"bf507af4c8ffdea5ee0c23988e32959955b19d724b75f94c60b323907539bb02","impliedFormat":1},{"version":"ba8691cf6bea9d53e6bf6cbc22af964a9633a21793981a1be3dce65e7a714d8b","impliedFormat":1},{"version":"a69c09dbea52352f479d3e7ac949fde3d17b195abe90b045d619f747b38d6d1a","impliedFormat":1},{"version":"bce910d9164785c9f0d4dcea4be359f5f92130c7c7833dea6138ab1db310a1f9","affectsGlobalScope":true,"impliedFormat":1},{"version":"7d2e3fea24c712c99c03ad8f556abedbfe105f87f1be10b95dbd409d24bc05a3","impliedFormat":1},{"version":"7c387a02bf156d8d45667134d32518ac3ca1b99ca50ca9deff2c1a03eb6d1a81","affectsGlobalScope":true,"impliedFormat":1},{"version":"3719525a8f6ab731e3dfd585d9f87df55ec7d50d461df84f74eb4d68bb165244","impliedFormat":1},{"version":"f993522fd7d01ae1ead930091fe35130b8415720d6c2123dc2a7e8eb11bb3cba","impliedFormat":1},{"version":"d5135ad93b33adcce80b18f8065087934cdc1730d63db58562edcf017e1aad9b","affectsGlobalScope":true,"impliedFormat":1},{"version":"82408ed3e959ddc60d3e9904481b5a8dc16469928257af22a3f7d1a3bc7fd8c4","impliedFormat":1},{"version":"b787b5b54349a24f07d089b612a9fb8ff024dbbe991ff52ea2b188a6b1230644","impliedFormat":1},{"version":"bb9c4ffa5e6290c6980b63c815cdd1625876dadb2efaf77edbe82984be93e55e","impliedFormat":1},{"version":"1cdcfc1f624d6c08aa12c73935f6e13f095919cd99edf95752951796eb225729","impliedFormat":1},{"version":"df6d4b6ba1e64f682091862faa30104e93891f9e7202d006bf5e7a88ab4a0dbe","impliedFormat":1},{"version":"14b5aa23c5d0ae1907bc696ac7b6915d88f7d85799cc0dc2dcf98fbce2c5a67c","impliedFormat":1},{"version":"5c439dafdc09abe4d6c260a96b822fa0ba5be7203c71a63ab1f1423cd9e838ea","impliedFormat":1},{"version":"6b526a5ec4a401ca7c26cfe6a48e641d8f30af76673bad3b06a1b4504594a960","affectsGlobalScope":true,"impliedFormat":1},{"version":"c2fcbd6fad600e96fee8c5df1a62e908d477f5b47a9374b2bab7e74f52cfcc92","affectsGlobalScope":true,"impliedFormat":1},{"version":"5e3f2470ce8038c4005ff1baff18a69848383f431d6817d453e70d66e037f4a2","impliedFormat":1},{"version":"cc68e79b99f80e4dfd01967ec96be69efb0ff5bd7f779d9a2cc09dfe590ffd28","impliedFormat":1},{"version":"91d3d8f536f22dcaeeace0fc6f3544d3562e266a27cf3a2fe280b8051af5d006","impliedFormat":1},{"version":"9503113febdd737095465792cc074d541902c82c0aea3922f940de18784812ad","impliedFormat":1},{"version":"8d3c583a07e0c37e876908c2d5da575019f689df8d9fa4c081d99119d53dba22","impliedFormat":1},{"version":"2c828a5405191d006115ab34e191b8474bc6c86ffdc401d1a9864b1b6e088a58","impliedFormat":1},{"version":"e630e5528e899219ae319e83bef54bf3bcb91b01d76861ecf881e8e614b167f0","affectsGlobalScope":true,"impliedFormat":1},{"version":"bcebb922784739bdb34c18ee51095d25a92b560c78ccd2eaacd6bd00f7443d83","impliedFormat":1},{"version":"7ee6ed878c4528215c82b664fe0cfe80e8b4da6c0d4cc80869367868774db8b1","impliedFormat":1},{"version":"b0973c3cbcdc59b37bf477731d468696ecaf442593ec51bab497a613a580fe30","impliedFormat":1},{"version":"4989e92ba5b69b182d2caaea6295af52b7dc73a4f7a2e336a676722884e7139d","affectsGlobalScope":true,"impliedFormat":1},{"version":"0715e4cd28ad471b2a93f3e552ff51a3ae423417a01a10aa1d3bc7c6b95059d6","affectsGlobalScope":true,"impliedFormat":1},{"version":"5153a2fd150e46ce57bb3f8db1318d33f6ad3261ed70ceeff92281c0608c74a3","impliedFormat":1},{"version":"210d54cd652ec0fec8c8916e4af59bb341065576ecda039842f9ffb2e908507c","impliedFormat":1},{"version":"36b03690b628eab08703d63f04eaa89c5df202e5f1edf3989f13ad389cd2c091","impliedFormat":1},{"version":"0effadd232a20498b11308058e334d3339cc5bf8c4c858393e38d9d4c0013dcf","impliedFormat":1},{"version":"25846d43937c672bab7e8195f3d881f93495df712ee901860effc109918938cc","impliedFormat":1},{"version":"ff1bad1849903b15fba47f3c29bdec5f97324874c93933a89b2bca28a23977fb","impliedFormat":1},{"version":"1b952304137851e45bc009785de89ada562d9376177c97e37702e39e60c2f1ff","impliedFormat":1},{"version":"69ee23dd0d215b09907ad30d23f88b7790c93329d1faf31d7835552a10cf7cbf","impliedFormat":1},{"version":"44b8b584a338b190a59f4f6929d072431950c7bd92ec2694821c11bce180c8a5","impliedFormat":1},{"version":"23b89798789dffbd437c0c423f5d02d11f9736aea73d6abf16db4f812ff36eda","impliedFormat":1},{"version":"d9b4afd96c3c0ff70e90d05ef022e582b102e665e9029d34940472dc3058360e","affectsGlobalScope":true,"impliedFormat":1},{"version":"3c4ba1dd9b12ffa284b565063108f2f031d150ea15b8fafbdc17f5d2a07251f3","affectsGlobalScope":true,"impliedFormat":1},{"version":"e10177274a35a9d07c825615340b2fcde2f610f53f3fb40269fd196b4288dda6","impliedFormat":1},{"version":"1422cd9e705adcc09088fda85a900c2b70e3ad36ea85846f68bd1a884cdf4e2b","impliedFormat":1},{"version":"3c13ef48634e7b5012fcf7e8fce7496352c2d779a7201389ca96a2a81ee4314d","impliedFormat":1},{"version":"5d0a25ec910fa36595f85a67ac992d7a53dd4064a1ba6aea1c9f14ab73a023f2","impliedFormat":1},{"version":"22d7b95cb63dead43834ae20ee492c9c8b6d90db3957d21665199f0efb1d3e26","affectsGlobalScope":true,"impliedFormat":1},{"version":"a9fc1469744055a3435f203123246b96c094e7ff8c4e1c3863829d9b705b7a34","affectsGlobalScope":true,"impliedFormat":1},{"version":"868831cab82b65dfe1d68180e898af1f2101e89ba9b754d1db6fb8cc2fac1921","impliedFormat":1},{"version":"0fe8985a28f82c450a04a6edf1279d7181c0893f37da7d2a27f8efd4fd5edb03","impliedFormat":1},{"version":"e59a892d87e72733e2a9ca21611b9beb52977be2696c7ba4b216cbbb9a48f5aa","impliedFormat":1},{"version":"52120bb7e4583612225bdf08e7c12559548170f11e660d33a33623bae9bbdbba","affectsGlobalScope":true,"impliedFormat":1},{"version":"8a300fa9b698845a1f9c41ecbe2c5966634582a8e2020d51abcace9b55aa959e","impliedFormat":1},{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true,"impliedFormat":1},{"version":"d5be4343a9ace4611f04a6fffd91ceba91265fa15bfb0149306e0a6963e1a015","impliedFormat":1},{"version":"963d59066dd6742da1918a6213a209bcc205b8ee53b1876ee2b4e6d80f97c85e","impliedFormat":1},{"version":"9c5c92b7fb8c38ff1b46df69701f2d1ea8e2d6468e3cd8f73d8af5e6f7864576","impliedFormat":1},{"version":"bf88ef4208a770ca39a844b182b3695df536326ea566893fdc5b8418702a331e","impliedFormat":1},{"version":"6a61697f65beb341884485c695894ee1876a45c1a7190d76cb4a57a679c9d5b8","impliedFormat":1},{"version":"a3e5b8b86e7bd38d9afdc294875c4445c535319e288d3a13c1e2e41f9af934f2","impliedFormat":1},{"version":"8b06ac3faeacb8484d84ddb44571d8f410697f98d7bfa86c0fda60373a9f5215","impliedFormat":1},{"version":"7eb06594824ada538b1d8b48c3925a83e7db792f47a081a62cf3e5c4e23cf0ee","impliedFormat":1},{"version":"f5638f7c2f12a9a1a57b5c41b3c1ea7db3876c003bab68e6a57afd6bcc169af0","impliedFormat":1},{"version":"6c1e688f95fcaf53b1e41c0fdadf2c1cfc96fa924eaf7f9fdb60f96deb0a4986","impliedFormat":1},{"version":"0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","impliedFormat":1},{"version":"c085e9aa62d1ae1375794c1fb927a445fa105fed891a7e24edbb1c3300f7384a","impliedFormat":1},{"version":"f315e1e65a1f80992f0509e84e4ae2df15ecd9ef73df975f7c98813b71e4c8da","impliedFormat":1},{"version":"5b9586e9b0b6322e5bfbd2c29bd3b8e21ab9d871f82346cb71020e3d84bae73e","impliedFormat":1},{"version":"3e70a7e67c2cb16f8cd49097360c0309fe9d1e3210ff9222e9dac1f8df9d4fb6","impliedFormat":1},{"version":"ab68d2a3e3e8767c3fba8f80de099a1cfc18c0de79e42cb02ae66e22dfe14a66","impliedFormat":1},{"version":"6d969939c4a63f70f2aa49e88da6f64b655c8e6799612807bef41ccff6ea0da9","impliedFormat":1},{"version":"b2fdcc3836d425833af10e536ae5491c34e218bc71870f12a401720f874b6ce4","affectsGlobalScope":true,"impliedFormat":1},{"version":"dca41e86e89dfb2e85e6935260250f02eb6683b86c2fa16bec729ddd1bcd9b4b","impliedFormat":1},{"version":"96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","impliedFormat":1},{"version":"8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","impliedFormat":1},{"version":"209e814e8e71aec74f69686a9506dd7610b97ab59dcee9446266446f72a76d05","impliedFormat":1},{"version":"6fa0008bf91a4cc9c8963bace4bba0bd6865cbfa29c3e3ccc461155660fb113a","impliedFormat":1},{"version":"86cc8969b76067ccf25e02c62b7df6ccdb419481fbce594b5ae9da21e9015e39","affectsGlobalScope":true,"impliedFormat":1},{"version":"2b8264b2fefd7367e0f20e2c04eed5d3038831fe00f5efbc110ff0131aab899b","impliedFormat":1},{"version":"d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","impliedFormat":1},{"version":"6a386ff939f180ae8ef064699d8b7b6e62bc2731a62d7fbf5e02589383838dea","impliedFormat":1},{"version":"549df62b64a71004aee17685b445a8289013daf96246ce4d9b087d13d7a27a61","affectsGlobalScope":true,"impliedFormat":1},{"version":"4c68749a564a6facdf675416d75789ee5a557afda8960e0803cf6711fa569288","impliedFormat":1},{"version":"f5a8b384f182b3851cec3596ccc96cb7464f8d3469f48c74bf2befb782a19de5","impliedFormat":1},{"version":"95ec4d99b8c532a1cdd22f20f8f027e84a34944e854f281af0f72095da4595db","affectsGlobalScope":true,"impliedFormat":1},{"version":"a95b76aef31395752eb5cb7b386be2e287fdc32dfdf7bdbbb666e333133b1ef7","impliedFormat":1},{"version":"7ccce4adb23a87a044c257685613126b47160f6975b224cea5f6af36c7f37514","impliedFormat":1},{"version":"2b93035328f7778d200252681c1d86285d501ed424825a18f81e4c3028aa51d9","impliedFormat":1},{"version":"2ac9c8332c5f8510b8bdd571f8271e0f39b0577714d5e95c1e79a12b2616f069","impliedFormat":1},{"version":"42c21aa963e7b86fa00801d96e88b36803188018d5ad91db2a9101bccd40b3ff","impliedFormat":1},{"version":"d31eb848cdebb4c55b4893b335a7c0cca95ad66dee13cbb7d0893810c0a9c301","impliedFormat":1},{"version":"b9f96255e1048ed2ea33ec553122716f0e57fc1c3ad778e9aa15f5b46547bd23","impliedFormat":1},{"version":"7a9e0a564fee396cacf706523b5aeed96e04c6b871a8bebefad78499fbffc5bc","impliedFormat":1},{"version":"906c751ef5822ec0dadcea2f0e9db64a33fb4ee926cc9f7efa38afe5d5371b2a","impliedFormat":1},{"version":"5387c049e9702f2d2d7ece1a74836a14b47fbebe9bbeb19f94c580a37c855351","impliedFormat":1},{"version":"c68391fb9efad5d99ff332c65b1606248c4e4a9f1dd9a087204242b56c7126d6","impliedFormat":1},{"version":"e9cf02252d3a0ced987d24845dcb1f11c1be5541f17e5daa44c6de2d18138d0c","impliedFormat":1},{"version":"e8b02b879754d85f48489294f99147aeccc352c760d95a6fe2b6e49cd400b2fe","impliedFormat":1},{"version":"9f6908ab3d8a86c68b86e38578afc7095114e66b2fc36a2a96e9252aac3998e0","impliedFormat":1},{"version":"0eedb2344442b143ddcd788f87096961cd8572b64f10b4afc3356aa0460171c6","impliedFormat":1},{"version":"71405cc70f183d029cc5018375f6c35117ffdaf11846c35ebf85ee3956b1b2a6","impliedFormat":1},{"version":"c68baff4d8ba346130e9753cefe2e487a16731bf17e05fdacc81e8c9a26aae9d","impliedFormat":1},{"version":"2cd15528d8bb5d0453aa339b4b52e0696e8b07e790c153831c642c3dea5ac8af","impliedFormat":1},{"version":"479d622e66283ffa9883fbc33e441f7fc928b2277ff30aacbec7b7761b4e9579","impliedFormat":1},{"version":"ade307876dc5ca267ca308d09e737b611505e015c535863f22420a11fffc1c54","impliedFormat":1},{"version":"f8cdefa3e0dee639eccbe9794b46f90291e5fd3989fcba60d2f08fde56179fb9","impliedFormat":1},{"version":"86c5a62f99aac7053976e317dbe9acb2eaf903aaf3d2e5bb1cafe5c2df7b37a8","impliedFormat":1},{"version":"2b300954ce01a8343866f737656e13243e86e5baef51bd0631b21dcef1f6e954","impliedFormat":1},{"version":"a2d409a9ffd872d6b9d78ead00baa116bbc73cfa959fce9a2f29d3227876b2a1","impliedFormat":1},{"version":"b288936f560cd71f4a6002953290de9ff8dfbfbf37f5a9391be5c83322324898","impliedFormat":1},{"version":"61178a781ef82e0ff54f9430397e71e8f365fc1e3725e0e5346f2de7b0d50dfa","impliedFormat":1},{"version":"6a6ccb37feb3aad32d9be026a3337db195979cd5727a616fc0f557e974101a54","impliedFormat":1},{"version":"c649ea79205c029a02272ef55b7ab14ada0903db26144d2205021f24727ac7a3","impliedFormat":1},{"version":"38e2b02897c6357bbcff729ef84c736727b45cc152abe95a7567caccdfad2a1d","impliedFormat":1},{"version":"d6610ea7e0b1a7686dba062a1e5544dd7d34140f4545305b7c6afaebfb348341","impliedFormat":1},{"version":"3dee35db743bdba2c8d19aece7ac049bde6fa587e195d86547c882784e6ba34c","impliedFormat":1},{"version":"b15e55c5fa977c2f25ca0b1db52cfa2d1fd4bf0baf90a8b90d4a7678ca462ff1","impliedFormat":1},{"version":"f41d30972724714763a2698ae949fbc463afb203b5fa7c4ad7e4de0871129a17","impliedFormat":1},{"version":"843dd7b6a7c6269fd43827303f5cbe65c1fecabc30b4670a50d5a15d57daeeb9","impliedFormat":1},{"version":"f06d8b8567ee9fd799bf7f806efe93b67683ef24f4dea5b23ef12edff4434d9d","impliedFormat":1},{"version":"6017384f697ff38bc3ef6a546df5b230c3c31329db84cbfe686c83bec011e2b2","impliedFormat":1},{"version":"e1a5b30d9248549ca0c0bb1d653bafae20c64c4aa5928cc4cd3017b55c2177b0","impliedFormat":1},{"version":"a593632d5878f17295bd53e1c77f27bf4c15212822f764a2bfc1702f4b413fa0","impliedFormat":1},{"version":"a868a534ba1c2ca9060b8a13b0ffbbbf78b4be7b0ff80d8c75b02773f7192c29","impliedFormat":1},{"version":"da7545aba8f54a50fde23e2ede00158dc8112560d934cee58098dfb03aae9b9d","impliedFormat":1},{"version":"34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","impliedFormat":1},{"version":"a1a261624efb3a00ff346b13580f70f3463b8cdcc58b60f5793ff11785d52cab","impliedFormat":1},{"version":"b0d10e46cfe3f6c476b69af02eaa38e4ccc7430221ce3109ae84bb9fb8282298","impliedFormat":1},{"version":"983586a2ed8fb862c6043d43589450aba5ff7bd1ee446b74ae9f9c76aa4cd679","affectsGlobalScope":true,"impliedFormat":1},{"version":"3f36c0c7508302f3dca3dc5ab0a66d822b2222f70c24bb1796ddb5c9d1168a05","impliedFormat":1},{"version":"b23d5b89c465872587e130f427b39458b8e3ad16385f98446e9e86151ba6eb15","affectsGlobalScope":true,"impliedFormat":1},{"version":"e3025aa7075df904c6367cb7500dcab913f992ced228e63695e3c6020a6a723d","impliedFormat":1},{"version":"8e609bb71c20b858c77f0e9f90bb1319db8477b13f9f965f1a1e18524bf50881","impliedFormat":1},{"version":"4ba733d1a5ff0a0779b714468b13c9089f0d877e6fbd0147fac7c3af54c89fe0","impliedFormat":1},{"version":"a39e9304639454356f4a1fe20741899de0c3163e1f040d0e0acfdc8532f779e3","impliedFormat":1},{"version":"3bf8a15acc2dbde99020f0ebe9d16ceba9e6220e41e034003fc8f835b47642af","impliedFormat":1},{"version":"eae4d78e9a2660a6af2a638ac809a81d2bba1b90ec36620b2035a65cf296646b","impliedFormat":1},{"version":"68d8546d461fe71b175a1f7216f57b6ee6be3533571f609898db9318fba7687c","impliedFormat":1},{"version":"281bd81717fb987d20b6c2121b8c927656879aa6320c00f32e08c659ec694603","impliedFormat":1},{"version":"dc267fdfa6f73868b0f3b5ec6fa90c75ebae60c9bd31623d3d6982007d90eaa2","impliedFormat":1},{"version":"1d389be758802f6fdd2129376d9c9dab398fa4463b78fbc616b840cf6bd7464a","impliedFormat":1},{"version":"9b22f00244f5b354c18f714ba98c6a1bbeb0d6b7e185f23e65d4a63b783925ce","impliedFormat":1},{"version":"fe921464aa5c2f4bb0e00eb5cd76fa7a8ec4eaff3add9c998130b53baba20650","impliedFormat":1},{"version":"18e7a3eaa52539d3358de42db0ccaaec0d0021a2097e40007ade3364442d44b2","impliedFormat":1},{"version":"4c136da3b1dce49c12eac152699c6b4bc64fa93d6c7224a43c816f7e51b00930","impliedFormat":1},{"version":"bfac6d6a4817bf56d574b1f32b174f655e05ce45c5ddf6d17c9b592660f10935","impliedFormat":1},{"version":"569d1ba16a424e1c779310b8af02cad1bb07f96130d2fabc35b0ed23cd01e79d","impliedFormat":1},{"version":"e22f139c9920c4bae02ceb2f99d658edd6e3913dc84c3b6fd07c89331f93ddcc","impliedFormat":1},{"version":"1c9e8fa9b807559953d3fa66654968ef0ad342d3ad22fb56c9c51d5f2ac8e1b5","impliedFormat":1},{"version":"8c20a47a1f745993dd1c43ea9ba2d0a72b226f4400cd9b9acbba86641e2f07a1","impliedFormat":1},{"version":"c2d4a7c4de3afa5c89b92cbe2ce6cccd177a7663ccaa94723505fc9498e8d6c4","impliedFormat":1},{"version":"418728880845307b1f5ce97a2f2f20e3d9f116886dfbed928b047377c661fe55","impliedFormat":1},{"version":"4df21704b570661aa78e79cf10ba04643c621abe566c0883baf7692736069636","impliedFormat":1},{"version":"ae046314c0651da4a01e9e48ddf370ce9d22ad21f48962f25a12c1c09de9b01a","impliedFormat":1},{"version":"1256387b52b07d006bdcc8566b4df12f426a507ccf6f77ad65d00d1a336d051b","impliedFormat":1},{"version":"6c52f9e0b26208b9cc8f9a451e165765a396e0debf1dc4a35e96a70b5130605a","impliedFormat":1},{"version":"a8ac7abacd9392643c55555c510425cd38e2ff2b37a7ac4e4b4d80d826c028e4","impliedFormat":1},{"version":"e6dab2f00f6bd3168905a16b7a82a75f2ae11cf3dba8e54e25aa5b3e6b83b8de","impliedFormat":1},{"version":"030b5aba86fdbc5d46ffb2c024d7764791848520332a03b662dd26962e1125ad","impliedFormat":1},{"version":"e5001f7b7c702d28224039373992e1aabf31ade390ee18abab2fd4c3255687fb","impliedFormat":1},{"version":"9fe0c8e9580b8d4c539883d078abafe9652f5498e37b94e5ac861fd63d00fa66","impliedFormat":1},{"version":"8e9c191443e616c30bd47669cc59e4946b5fc23ff03c42c4578a48396688d526","impliedFormat":1},{"version":"0d040d689a5b08f47143fae77e8447caead3fc54c18b0213d99679e7f304e660","impliedFormat":1},{"version":"ce121685c395e6b4ab7f9eb524a7c7f3232b4387f625974658c3fd0cbd9b3b9f","impliedFormat":1},{"version":"1fb84af39dff732e482eab1516f2f5790ba46558398929f65fb4abd465ab4dd4","impliedFormat":1},{"version":"33a165db76e5473238c2f499732a0ebfeb2b1265186a3be93ed2d942fab33d0b","impliedFormat":1},{"version":"166c027b2bfc241c7540aaf3832fdee69018185a3f8a5c8e52baba6fdbcfbd20","impliedFormat":1},{"version":"5047058ece643d335ca144518a096dfc8ecc2f62a91724e9f393e8d004cf7ca9","impliedFormat":1},{"version":"4f453c20a8caa94344aa0b256bdb0b25f9ae6f34fd0abf41452e4e1813cc7aab","impliedFormat":1},{"version":"2f36dba57c3bac94153f88b112ee501aa4c7a91f0cdb50424053546258a75d21","impliedFormat":1},{"version":"d535c0d1ced69a280e7f1035073ca87728e758dc17f67ec98609d4ac94c0ba2d","impliedFormat":1},{"version":"1029494adeee9517e69000187f295df605c580be882ebe3d2f7974eefdd205fe","impliedFormat":1},{"version":"fc3596b10eb99c07fccec7b04b9404d36bea341b9f486173aff1e234aceaccff","impliedFormat":1},{"version":"b71e7f69e72d51d44ad171e6e93aedc2c33c339dab5fa2656e7b1ee5ba19b2ad","impliedFormat":1},{"version":"3755d34ddf0835f31833c825aaf3c996d22d96dfc6db6d04b55e8c29213bac0a","impliedFormat":1},{"version":"281eb8e4ddd65b6733cf1f175dd1af1bb2595bbcea7c12324f028079ba78fdf9","impliedFormat":1},{"version":"f6490f3be2f1d4feb0420f260398b375c20c2294c4022f8733e8efd9f84b10d8","impliedFormat":1},{"version":"e0fdf687219271c3031ae25cd8d3e9fe7c16ce46453ce775292887f486c2aa16","impliedFormat":1},{"version":"f17592fc258a847bb7d38ab25799eabce4865f24fcb441cc69a6a6277a48e6a7","impliedFormat":1},{"version":"512d2b3f264aac071278060d3e4f019508b8a504283708a0fc503198f244c363","impliedFormat":1},{"version":"5f477e9897e29f47b860b52218d645178362d3ebd17c990df9f36b0c52d0e6ff","impliedFormat":1},{"version":"0df7497ada3a4f6459420803ecf7e555f1ad1e7bd43c1e17bdafbc34e19d7162","impliedFormat":1},{"version":"0bcf482b1b2d29f025859f6b1088d8189c1c8b051878307bd44f4bee10fd6c68","impliedFormat":1},{"version":"4437d06571d134bb4ae17d62f038bc53e197d54baaebb9a6d831639b04807187","impliedFormat":1},{"version":"d5ef9e45427c9ecff2899621a646abe1e8a6059303506e04cf6d7112459374a3","impliedFormat":1},{"version":"42951afaf8acb50012d9cf6559598f1a14856b2e23d23e0b1fc312becfb669c0","impliedFormat":1},{"version":"10757352393ef1239b2efb42b41aa940ff67d9a40409958e9b9d3a9c7a524a64","impliedFormat":1},{"version":"4cd50064906b1e0af2ef0cdb460e218a52d9def48e912d5faea292d5b735e32d","impliedFormat":1},{"version":"6e16ba58508a87f231264a5e01b0859669229a40d6edea4485ac2032ddf8a7c6","impliedFormat":1},{"version":"5480c80155523c871caff63b2d6c1316aa9fef097e1746ddc90afd7cec5bcf5b","impliedFormat":1},{"version":"d0cb43e1b996459c97f19bd66cebb8cc603ce427d736ff7fcb7e729067834f50","impliedFormat":1},{"version":"39e1e2eecd99c7dafe2416938bc2b2f54c7db6b8c7223943ed279fdcd1e9b761","impliedFormat":1},{"version":"27053301da23739c42d40cfc6978b209231d9de61cc4c6ea49cf3fab3d677063","affectsGlobalScope":true,"impliedFormat":1},{"version":"6d2d4e0c4bb2d7f5d4a024d796ae73195f209769962b35635cb85782b8b031a2","impliedFormat":1},{"version":"336e44075eefc97ff99a57bea6be98c204e24ef35619107e86726e280e5e7602","impliedFormat":1},{"version":"b7473301e977b37b31c78319a676d467a8fb19cae63b9b3f5fa34caedbde7150","impliedFormat":1},{"version":"c9eaed1f52db7eb91d86d26f5f736d3a7952d16971ebc6ea506eb648ace8c208","impliedFormat":1},{"version":"a0a11708cfdff7d18b61419b9468187366f9434f2362dbd479d33b3ff25a25db","impliedFormat":1},{"version":"b4070f50cf741dbe076212cc74fc79e243aecf1375ff62c1efd3c7240baa1a99","impliedFormat":1},{"version":"f3f43542c4dc3045f04c1acc283d813b17de5c4b104a26c5877d62db2f85a8bc","impliedFormat":1},{"version":"b59ad37bdde13372542542bacae7a3ecdf536ad851af1ecd6d448285475d3320","impliedFormat":1},{"version":"b4ec3dcc11e8a52b81878d7aa998218182c36e3222e6c55177172880434823e3","impliedFormat":1},{"version":"2a7d458b0359866a9638952eaa8e9d3b2834e210839edf2bbeea4c2d49e2db2c","impliedFormat":1},{"version":"689bea90fd9829a424a2a80a10034b684937599f6f55ad4c761e52450f7af520","impliedFormat":1},{"version":"47d6b647600a1d5fc547d4e8acc381ff8832899aea429c925602c913de7a6981","impliedFormat":1},{"version":"f4cadee14617809fe2c126a40aae853ca83700eaac4711bcde7e8b87fa349d76","impliedFormat":1},{"version":"63162eaa0e0e77c318006455f7053f006a974ee71206a51efd669fd762b4349c","impliedFormat":1},{"version":"6ccab5ceb7d50d84db4804beccbb86d6291b40ecc4a4f1ca511370c3c7543fa0","impliedFormat":1},{"version":"b012fbdfbef2befbd73bb44710222cbde679597bf59f2a49a423ff76ccf7cfae","impliedFormat":1},{"version":"78b1daa0a8aa1f54530c110600cdcadf70c1238c0d71fd7208c1bd5b31b77db1","impliedFormat":1},{"version":"491e54b4744205c7bded0806effedf8198e87cf3814260fb8a7a902e3eaec3af","impliedFormat":1},{"version":"0e6b3c7f300f6e2587c62783ebf78c74e61e7e85d37591e1e1ecf82cc15adc01","impliedFormat":1},{"version":"139ab16e09553addf17cfb7122108eb39cd406b8009692c4d1d9e3dea96ef83d","impliedFormat":1},{"version":"69f3d18ee459096c5e1426df332673a939b56b8bafeeec0b31b3cab1a9e4dadd","impliedFormat":1},{"version":"b90f14bca14cdbdd60dc83c451aca97e8df63c8eb8a158a9ed84de4bfb4cad76","impliedFormat":1},{"version":"abd7e6019aff624863a7af95103b933db50b3414abcff3b90a36c93fa017c6fc","impliedFormat":1},{"version":"4290786877542f1115da59711fe789b54d3a3575ff18d3c3be38ea8d6568c382","impliedFormat":1},{"version":"927feece65b05a65b2b62489762cd2e1dfacc5067f0c5119aa29b164ecebc092","impliedFormat":1},{"version":"6014f6c45c7ebf8c87fcfce9f3b941fc231da827a3a7f40713cc0e32bbb0a4f1","impliedFormat":1},{"version":"54b8150a098dd89b6341ffdaa48a14f34fce5fb26d7bcd3eec8bcbc8f56e8bf5","impliedFormat":1},{"version":"d391c205df01320dd3ed8a807d2e35fe995e718b22c9b7c98839972abdb75dba","impliedFormat":1},{"version":"37753e13857f51ee8c3f5a5ca2a1f67b65958c0404ff5715a2bc1c7194522d8d","impliedFormat":1},{"version":"b5471fc898333cbf4201bf78076c57f2b92ce03a278aaf0904952c4cb4ed3921","impliedFormat":1},{"version":"26376fd57f41eab392e172ea5d7a5eae04f9d163a28dec20316b519df9071cc7","impliedFormat":1},{"version":"c91b058ab74323c57dda1cbda7eb8cee56272002249a642deebbbd977c4a0baa","impliedFormat":1},{"version":"0de7471bc710301ccc17d27f173083b3f433bfd34a89e5f18bb591e6086e6bbf","impliedFormat":1},{"version":"3cde909e36fa8e49e3832737f5342a8b0d8cc8292be98fd7d486612d1ee036da","impliedFormat":1},{"version":"d727217607538f4c84e08de5c124683cc427dacde8f4728b5fc0c6ee5423adc3","impliedFormat":1},{"version":"2f79ca92fd9e80720cd0ca217fb09473ef8d2cfd35f25d59f741683e3a2e006c","impliedFormat":1},{"version":"6c7f1a4f3d43a47624bdf26e93be7be9fe29cda02de5b53b83f5c7559ae07745","impliedFormat":1},{"version":"8bb8747ec22ead9786ae69c56128cdca751b2bccef392892bf1569da1dd6a231","impliedFormat":1},{"version":"23a1f88a7c2b78e12d38ab11b336b8aecc1bc9ff9cbd3d9ca3fd4210d19446df","impliedFormat":1},{"version":"235457ab8d68a5c6aca2aebadd92cb22dfd69fa106440f8703ac2aee2e1350bc","impliedFormat":1},{"version":"1df4a94a8c0f64e32d4380767467ee14fbf83f8dd2f04b674705f45b904a1d28","impliedFormat":1},{"version":"9b1749197e00cd9bb4e672be70a4f803c3ab31a3de69cd486ece8c10d2f07e9a","impliedFormat":1},{"version":"c6ef0a1c04b3908b831aa7a928121b2faa973f8396528bb6b1c8eb6751f6570c","impliedFormat":1},{"version":"f40765dc1af2c37fa3650cf2c0bc249988ed91738ed4c6795181b9ade7d19ba9","impliedFormat":1},{"version":"15edc57aab1961a4c274c9c5763cfbb2b610e3ce07093c2bb359b79195a1800d","impliedFormat":1},{"version":"d01a649d7d04d92b84a0878647f46d8f2343b98838387171ea37ebffe40b134d","impliedFormat":1},{"version":"e120dc0a5d7b61017663478cb8259d072bfa682d062937605e03b81fc9581d71","impliedFormat":1},{"version":"13a333a298412dd9343f8962fc54d618815602b3a764eea1b7902aa3ecb133d1","impliedFormat":1},{"version":"4998cbff67e76f385d9955674a9f2ac385926e807ed371ed357ccb6f03a4d72e","impliedFormat":1},{"version":"dcc5655f605185d082cb3829767ab40864dcdc2ad727a57c8fb61cdfe6c7f4f3","impliedFormat":1},{"version":"f9b591f21901f2fa8bd244158a176e35ad65d9069982aa122924ba55b78084be","impliedFormat":1},{"version":"19307bfe53b6ab9e80b5e969cf506f36d3ab28c9aeabcf1ca8ea9d768e6aed02","impliedFormat":1},{"version":"23e94d16c84ee5db526d0fa6eb5964f77720fb75a7d02034e4875a793e89ece1","impliedFormat":1},{"version":"a28f24327da93c2de0c0497e68fd2bb0a861056444151f73b8ececab20c0c078","impliedFormat":1},{"version":"4a71560ab2a642402c9d2c8714f7b189a1bb86f6d29b0e99327ac207b33bf14d","impliedFormat":1},{"version":"1e2cd959ad88fc7885cbecbbb58c1ea18dd31f637c5d7bdde544d5df635ce3f1","impliedFormat":1},{"version":"7fdfe7876d7c32130fef2c5b4fb85ce7d9efd876278f534c001ff7a2f54835bc","impliedFormat":1},{"version":"ca4fe406137f589634857582b8704f46596b336933e24f58e86616da618a71ce","impliedFormat":1},{"version":"b8d901e5f877864ce8a2139e8e053d98fd5979bc33747948359a80bcf33a0c60","impliedFormat":1},{"version":"caada226c64e581a8a766b403e4e87ec6bba4bc8ccd3e61a541047718dc2ae63","impliedFormat":1},{"version":"ba770673314c83758c44b62ba6e0ba441c5097e9b89f7a3e33c122930f62bef5","impliedFormat":1},{"version":"16ccd65f4d40ac5a6189f3a704bba3b3164b1c70ee1e0bfc12455683e49d86ba","impliedFormat":1},{"version":"f79abf7391274eea2b64dbc7045ca626bf11882829cd162153ec10d1c97d06d9","impliedFormat":1},{"version":"bad01e250a98bccc23aff9085a698cd8d222d52f32554fe1b9c2f036d67fb972","impliedFormat":1},{"version":"3215b182a1cb5a20f276aed67f78ddac4fa1dc5ba464d4ac674fc591b69da73b","impliedFormat":1},{"version":"c3e3dfbfb154b7de35cd74dd4ffca1df51ac41143431884c27fbd2ff11ab7aff","impliedFormat":1},{"version":"56e606ef187dd21fa0e41d5cc34d6ea893da2fc18de4d740fa41f7cee77ecd2f","impliedFormat":1},{"version":"59c0eb95da8c73b6f1bf4cb502dda5dce97e4b5ebf346f45f32e1190cab08042","impliedFormat":1},{"version":"cfcb37e9fe59c1ec143b42362097ef4c4abcc16cb478cbf39e66fbf1306894b9","impliedFormat":1},{"version":"49478bbc52a582ec618964e6f164c3532dec25c231c91dfca5e36f5c4e0db2bb","impliedFormat":1},{"version":"6d0593b8c9c7dbebe0c1fbc6d942853fb9d99023b0eed30b7a4545f5a6054fdd","impliedFormat":1},{"version":"e42124f81c324cf36bf6b8d682c5d17db4e3e37ac61bb435966c70a4f5f2d227","impliedFormat":1},{"version":"bcc46f3ed5cc2e668fad84dd79f02ea72653a95fd939f16a88b3a80c8f16f890","impliedFormat":1},{"version":"f32dfaaee2cde01df344d0f6957ca0bc36797a769bf22d53b3123215fefa1883","impliedFormat":1},{"version":"4615c3b1cb26656b3956f83b96b37ab683f751f60cb15ebc6ca9b7b03869ca32","impliedFormat":1},{"version":"2d989345f00824f1caaa05a1445ac48350cab4ed665a80a7e08ef42c32a8feb3","impliedFormat":1},{"version":"6c3dbc2b5dca457a941f5c89570c8d9151f33f01a878a2d9e1506f556d4cd9d2","impliedFormat":1},{"version":"0e0e322d7df295213810e63e26d6d48eb8b0df2a502e6409262021c47bae9cef","impliedFormat":1},{"version":"e2f956ebab71f2aa172ff9831942a77efa67e8cda1eca7d93855eb4a08330936","impliedFormat":1},{"version":"a008375f19feda9def1f8a77c9ec6b89de9762da0f441f72ec4dd1d44b9f2e85","impliedFormat":1},{"version":"9b97fa45971375e7f997650d75806a7153d34ec2c1902c7d5b4c6d1ca7d9c067","impliedFormat":1},{"version":"875acb08480f4fc608c1940b36c146ab1edf8abc25f2dcfb442b6b16aacae909","impliedFormat":1},{"version":"a35cbf919de0a92c8cfcaba4303021502613871aaa112ea3c235680c263d24ea","impliedFormat":1},{"version":"d51b3bf709a61517bd041bb8da899f5397add116d64d118def8f99f94bec4f85","impliedFormat":1},{"version":"2dc94689e0f2bb527fb72b04f5d17a01b9c7bdb36d62512c09a8ed539ced68e4","impliedFormat":1},{"version":"d0e92a50226e158bc2e4766bf791bfb233f26e03034bf292a7480140e8ce36e1","impliedFormat":1},{"version":"1170db3760aa51278cb10b33b73202f258fcd19c678041fee3ed48eccef8f431","impliedFormat":1},{"version":"0ab6b8ba859fc7381f99ef2de2e558c019706e62b624f5520e94dd31ded6b39d","impliedFormat":1},{"version":"91fce7a99637d2436db3bdc43c66e5190e2b9af5b9e080e57d6d2cf3e3d6d9e0","impliedFormat":1},{"version":"555641cd5fa620839e449655839930a5070bbd8605ba609093a4a1ca4f8df115","impliedFormat":1},{"version":"c780a1b4a17268aecc562850469db673a7f15130863d587ab9b2408f8fbc7fb8","impliedFormat":1},{"version":"42ca28d11f105d3ebbc49d71ec440badb7a5cfe81bc7705a7324cce2a1c2207a","impliedFormat":1},{"version":"77e2a44a8eccc6f3b6bd505efec45f9cf7941532e14450a8ab12f2da9a3f8bcf","impliedFormat":1},{"version":"daafbe690d2adf660077e8571483732629bc841a7f8bdc4f9e3223e96dfef271","impliedFormat":1},{"version":"5433a2b4d64cd8a2de52efc3e15511ce7a82cf44d0e16f3dce7ece35d9ae4542","impliedFormat":1},{"version":"2ca6c6d87aa9ef8e9108f316a1a26e6d3ef944049a6c48f35e6f6d812bbab486","impliedFormat":1},{"version":"a47f9c95817f11dd32685e2f3d0fe1f359c938c9bcf8bcf4be50ed7844443772","impliedFormat":1},{"version":"53e9a3bf36e8f8dc980e264c875080edc67b05abe984c17475b2d9305c6ad18e","impliedFormat":1},{"version":"b8d9e9127054860fd56515480674256d282eb6aded09c8966e6cabe519afb95b","impliedFormat":1},{"version":"999c971d6c04821c1709f6362d6a2b3ae385303e0656ba9324a83443dd7a9abf","impliedFormat":1},{"version":"df050f9bd85740b65cb06f138d8f041f3b338bfc027cc742a1e82ade4ffc9d5f","impliedFormat":1},{"version":"c9d2136687e090bf392812d9c9055d7a1585ecaf2977657077120d41eae12e9c","impliedFormat":1},{"version":"5d5ca59a2bbdf88ecc174a72e73b59b15c5a55ddd2c629f1023d8983a15121d1","impliedFormat":1},{"version":"804093a665865b3e1d7b4fc513165f001e671813a8ef34486c97a7bd148e1d13","impliedFormat":1},{"version":"b23fe930813b88210843819b0820f139e239fffa2d52d3002b78f179b34dee13","impliedFormat":1},{"version":"f870ffa5022ef591b95a057264fc779beac694bdcc94164768bd978dace0f2f7","impliedFormat":1},{"version":"8350938747a211bf7666131edf2bcf38b464c048aff5a3b64e119fb9b900280c","impliedFormat":1},{"version":"7d6b6f3573f2ba0b10b372f8c238ed321d194d45ef53f341b18e8a69b5564468","impliedFormat":1},{"version":"e0940395ef8e804ba014691aad23c41a62a78347d0baeda28fd7e8eb78663e51","impliedFormat":1},{"version":"12fa3d11e12f97c9fd6187d2d5e21bdcf6ce3d6c8d5361e662d0bf54c959011d","impliedFormat":1},{"version":"8b858ffc4c6bef512cce2f043166ff537bb90a8024cfc15f992ba842cbe150a8","impliedFormat":1},{"version":"e52ad7566b687e35a98b4a202e3ee380ecfd5babfec74f79519a52d70211260e","impliedFormat":1},{"version":"24551b8482b56cba01f5a76871010c9898f87ef22c066b654bc79d6851fb65d8","impliedFormat":1},{"version":"7f42742086e994ec57056658450ef15cde254ddc5c8a8d198c0083bb3690d402","impliedFormat":1},{"version":"0c39a6721f4481d28125672874d12f869db7beeb63efa5ea207a894a06b01990","impliedFormat":1},{"version":"47bbe877735649e7cc257a1689b415bc858a32225ab0a04fcf575208428197b8","impliedFormat":1},{"version":"229d110047a2cad7b9d7a5886e7e7203e4110367569ae1f9eb0256d96a787ce3","impliedFormat":1},{"version":"8689eee4cc74c2addba88c70383cb8a6bd4d640650eb74b5aafc450d945c8263","impliedFormat":1},{"version":"28cf4b88597d75f21d50d3e89cc60914ef1100ca7647c0bca0d44d0e04a83fdc","impliedFormat":1},{"version":"3d7503b70f5f38d06ff18326faff55bc50e7cb63da8effc771e6c0cd64b54e2f","impliedFormat":1},{"version":"3e0528d53eb3f2386d770412b4dcdd508ea8db6d7a32fac07b27e857b200c6bc","impliedFormat":1},{"version":"7efce11f987fd2d555babdcbbf505520c31671ad4ac08b298bc237f62ddd6941","impliedFormat":1},{"version":"5d96064fd7419a9faf2ec2118c273a6245d4933ff18774b39237e3a130ba0ea0","impliedFormat":1},{"version":"94755c3ecfcf813ef35c06e17b0494cea726eff490be46ec7f10b343cd6d6c66","impliedFormat":1},{"version":"59bf56dbda4409f8e87676340c5bfb65cf674442e611a680f9f461c8898c46dd","impliedFormat":1},{"version":"fe605c9e09b87c3032c78e3728f1b06f3402c3377dadde55aa2a31b325c5a977","impliedFormat":1},{"version":"57f2d9377264cf90b169ba4bbbcee8135d1350d8523d60a41d5523cf8456f226","impliedFormat":1},{"version":"8d2a53c59c82a8fac953afd36ca75783f60dcc5dec4740f1a00e8986f1119634","impliedFormat":1},{"version":"a48b6cb2421798862ff30c708f92ae83553efe17bede316c39f379ab330107ac","impliedFormat":1},{"version":"fcbd9775bf202d5e33d564a4ad8526074f8fe32fdaa6c67f8cdfb83967d8dbb1","impliedFormat":1},{"version":"114d87d630298b72d600a0d22b8d16a2a434a1d72ccdd04b169061fe2e1ca35e","impliedFormat":1},{"version":"1b905f84eb4131fdbbaa1df421065c1eabca4eb7c0836a52e3975b9f1a57ca3c","impliedFormat":1},{"version":"10493197e0c4bd32150b76bca5e4a5fa9adf34ce2078c4e713a59f41d14c9eba","impliedFormat":1},{"version":"ddcdec6b83a5b8d6240b63c020573138687e6bff780f17d7a9c86f2923dfc0bc","impliedFormat":1},{"version":"c851605f7ae50ece84e5721384893297ae6e8279de7963599af9cfb98bf2e8b5","impliedFormat":1},{"version":"99a152c7e68f3fe186f3404b5d16d3c11e95ffcd52d040ccd1106be1a69f9846","impliedFormat":1},{"version":"88dd3947d6bcb6677c1bb94ddbba344a72a55e2eaa01ce7a3dd9e2bad6f4e0fc","impliedFormat":1},{"version":"7ff73f6c8e866cf4d94c06eda365b1e24185a070f66d8d14191ae8a53943d1d9","impliedFormat":1},{"version":"ddc52c5b32152d509ab23e251b7fa66ad88a00a5c8c7369c163986fa723dfc82","impliedFormat":1},{"version":"fbae464f654de7497f07a70e88429222c0b6a5fcc785f54809b6774ecba8f88b","impliedFormat":1},{"version":"d6b6e0e63232c8af47d792e17fbe4247ebc0d46845886c5cadb62ba5becab563","impliedFormat":1},{"version":"c67578407a8641630311226f9d1d19ec44848b0dadf68e7f11357cc0fac1c210","impliedFormat":1},{"version":"dc7afce9e5cb152328bf31c166205bf163eb73cfc95455a7dfb3f4cef7d9485c","impliedFormat":1},{"version":"d7065c2df449f17ae78a3a7382deac2e388ada6bc0428c5747a4a80d0718e283","impliedFormat":1},{"version":"355d745d283e4f89bd785542bdba50ae1ab31ca5fa9618f2e221fbe12b9933cc","impliedFormat":1},{"version":"384fddf003645c4e2212b1a9cf7709ac125dc572e0fec9c9378a2bf9ba6369d3","impliedFormat":1},{"version":"9c3ba26ebbbeb429de4ee2155ebf5e78e16a08a380ee8941ad3aef1007228b48","impliedFormat":1},{"version":"6d72d622f589ff41ab26a4cb2adcd01fcb3d271c26b2985ec29c17bcafc82649","impliedFormat":1},{"version":"6c703676e52e268bd57f00eb52f4ea47a8490b103ede7db6259a83e73cfbbc1b","impliedFormat":1},{"version":"c6b0ce58e6fd87a883d690422cbd04b16346cf268acbffc434df6c3f88716c65","impliedFormat":1},{"version":"75ab63a00b9d95de88b22fd571aebe883021de2e8d0d4c8d500bcade3ae7fccc","impliedFormat":1},{"version":"b6d68423ea213d9fb4e8af6f53a5f85a442530fe9e9ea821a0f0c7be1e05f0a2","impliedFormat":1},{"version":"d75ae786d13f08ef60548535386f70142f1ce77626636a0a179490bc03979a24","impliedFormat":1},{"version":"27682b56744e8ef94b9f06c7f7d5ec06e3b62516ac41a8beee1f9fb79c12bc39","impliedFormat":1},{"version":"e5f738eda0b3d9bf85f467b54322078c1d493194f65684b86924af49af2b64db","impliedFormat":1},{"version":"8aff23e637cf75c7a50d7281f9db66fb963fec9b78b51aa0591e2f6a282bbd06","impliedFormat":1},{"version":"6f887e3afb0de4b6a4e79fb8512910736c1cb43909dabded07521a98fb3ab493","impliedFormat":1},{"version":"a5089e4ea15e39b97119424b2bcbddcfa73bc3849977aaa1943577fd7870106a","impliedFormat":1},{"version":"ede92559736e97a8dd65a16b91dad5527cd58bc83a62c748820fa9d24ed537a0","impliedFormat":1},{"version":"2f116129c90b76903dba94aab9a2c3cc74c84a1d7652786ea116b1ea321680b5","impliedFormat":1},{"version":"7549459c665141eb087702b64eb769db454a4958aab4197c04f276cc88125fc3","impliedFormat":1},{"version":"6996398eb3a1f3ee5bc2540f38f716ab941c9ad70fbdfc5a7d7eea87ba6c3cab","impliedFormat":1},{"version":"05df2a8400225e66721e483d0fc12eec6a1118f82a2ab6b7f6cf8c8a4221bc94","impliedFormat":1},{"version":"a57dd6772ffab02f233287ba6a8f769e35906316605e82ed4f023f409319f2c8","impliedFormat":1},{"version":"0208c00978d9231f274a4dc58feac9504389aded2b83c6d87fd5b0a0e78f1b57","impliedFormat":1},{"version":"c0052b367c598946d934581c9156f5bf06846a543bd8f1a419fbbedf0c49db5d","impliedFormat":1},{"version":"2360668f67c85a1ea07864282b797189555b9b9928be94685773ed8381302588","impliedFormat":1},{"version":"59fc39062aec81b871c29e9f246333d14d0c60ce3d5e3a01b3eb6336f69b6473","impliedFormat":1},{"version":"ccc6589b9029f32ed53b59cbe7bc71ce795ce0006a93b7cb2427f573856c74e9","impliedFormat":1},{"version":"821d22def6acf0fb49cdb3e0912881f47c5039f8dd730db1113bef321b9bb4ff","impliedFormat":1},{"version":"6c5c5605ae801d8af7781b57643e379106763ba7c30d7535e42f65e5ed957b58","impliedFormat":1},{"version":"59ab9ba5b9227ffac6bc4c15b52a561b495f26f68cb65019fc01d500794f1f27","impliedFormat":1},{"version":"22d3f6139efdf440fa08f0371380b411fbf24876074cbfc6b322ae8d407fd2bd","impliedFormat":1},{"version":"ddf93cb6c3145c5b99a68c20ff0c4a5b19dad759266b6ace96d0ffa22fedf05e","impliedFormat":1},{"version":"618c9e8880bb1d7f3b158f2f5e2f069a597f5e0eca383b516fea290681665f8d","impliedFormat":1},{"version":"c09ea0c858fc56c6ea39f78b3de5deaaf606aa0d8e2c6b2fc9ac303e650141c6","impliedFormat":1},{"version":"755159123b395e940735a5898d7cb651f9d6c6fcee6acfabed709ae3fe277f37","impliedFormat":1},{"version":"6106c7cec9173e697d396906b7c5cf1890c0fce517e97d2727abf96c3b57ef31","impliedFormat":1},{"version":"ab5a1581b51905807d463f49c9ec6a9dbfa34aa41ebe57080636dc84c3361f37","impliedFormat":1},{"version":"fab58e600970e66547644a44bc9918e3223aa2cbd9e8763cec004b2cfb48827e","impliedFormat":1},{"version":"70e9a18da08294f75bf23e46c7d69e67634c0765d355887b9b41f0d959e1426e","impliedFormat":1},{"version":"e9eb1b173aa166892f3eddab182e49cfe59aa2e14d33aedb6b49d175ed6a3750","impliedFormat":1}],"root":[[46,134]],"options":{"allowSyntheticDefaultImports":true,"declaration":true,"esModuleInterop":true,"module":6,"outDir":"./","skipLibCheck":true,"sourceMap":true,"strict":true,"target":7},"fileIdsList":[[136,221],[221],[221,239],[136,137,138,139,140,221],[136,138,221],[143,171,221],[142,148,221],[153,221],[148,221],[147,221],[165,221],[161,221],[143,160,171,221],[142,143,144,145,146,147,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,221],[191,192,221,228,229],[192,221,228],[221,232],[221,234],[221,235],[221,241,244,304],[175,221],[178,221],[179,184,212,221],[180,191,192,199,209,220,221],[180,181,191,199,221],[182,221],[183,184,192,200,221],[184,209,217,221],[185,187,191,199,221],[186,221],[187,188,221],[191,221],[189,191,221],[191,192,193,209,220,221],[191,192,193,206,209,212,221],[221,225],[187,191,194,199,209,220,221],[191,192,194,195,199,209,217,220,221],[194,196,209,217,220,221],[175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227],[191,197,221],[198,220,221],[187,191,199,209,221],[200,221],[201,221],[178,202,221],[203,219,221,225],[204,221],[205,221],[191,206,207,221],[206,208,221,223],[179,191,209,210,211,212,221],[179,209,211,221],[209,210,221],[212,221],[213,221],[209,221],[191,215,216,221],[215,216,221],[184,199,209,217,221],[218,221],[199,219,221],[179,194,205,220,221],[184,221],[209,221,222],[221,223],[221,224],[179,184,191,193,202,209,220,221,223,225],[209,221,226],[221,258],[221,254,255,256,257],[221,261,300],[221,261,285,300],[221,300],[221,261],[221,261,286,300],[221,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299],[221,286,300],[221,244,245,303],[221,544],[221,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,367,368,369,370,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,415,416,417,418,419,420,421,422,423,424,446,447,448,449,450,451,452,453,454,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,532,533,534,537,538,539,540,541,542,543],[221,305,377,383,387],[221,305,311,381,382],[221,305,338,377,383,385,386],[221,383],[221,305,307,308,309,310],[221,311],[221,305,311],[221,377,388,389],[221,390],[221,377,388],[221,389,390],[221,367],[221,325,377,381,544],[221,344,374,377,396],[221,378],[221,367,378],[221,305,320,325],[221,321,323,324,325,331,334,335,338,362,381],[221,321,363],[221,363],[221,322],[221,305,323],[221,320,321,322,325],[221,320,324,325,326,327,338,341,344,361,363,374,376,378,381,383],[221,327,331,375,377,378,381],[221,305,338,398],[221,305,343],[221,343,344,357,374,395],[221,331,381],[221,331,404],[221,331,416],[221,331,417],[221,329,331,417,418],[221,405],[221,381,404],[221,405,406,407,408,409,410,411,412,413,414],[221,428],[221,430],[221,331,363,381,404,418],[221,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445],[221,331,363],[221,363,418],[221,363,381,404],[221,329,377,381,447,466],[221,329,448],[221,329,334,448],[221,329,377,448],[221,325,329,378,448],[221,325,329,377,447,460],[221,325,329,377,454,455],[221,337,448],[221,325,329,377,452],[221,325,377,382,448,544],[221,325,329,359,377,448],[221,329,359],[221,329,474],[221,329,359,377,381,459],[221,358,394],[221,329,359,381],[221,329,358,377],[221,359,473],[221,325,331,332,357,359,378,544],[221,329,359,451],[221,358,359,367],[221,329,343,359,377,381,469],[221,358,367],[221,383,477,478],[221,477,478],[221,363,400,477,478],[221,477,478,480],[221,395,477,478],[221,477,478,482],[221,478],[221,477],[221,341,343,477,478],[221,341,342,343,363,377,383,400,477,478],[221,343,477,478],[221,329,341,343],[221,509],[221,305,337,338,340,374],[221,341,455,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510],[221,305,329,341,343],[221,305,341,343],[221,341,343,381],[221,305,329,341,343,544],[221,305,329,331,341,343],[221,305,331,341,343],[221,329,331,343,500],[221,497],[221,305,339,341],[221,329,341],[221,331],[221,321,325,333,335,337,377,381],[221,305,320,321,323,328,381],[221,305,329],[221,381],[221,324,325,381],[221,325,334,335,337,377,381,513],[221,325,381],[221,324],[221,320,324,326,381],[221,320,325,334,335,336,381],[221,321,323,325,326,381],[221,325,334,335,337,381],[221,325,334,337,381],[221,321,323,331,332,334,337,381],[221,320,321],[221,320,321,323,324,325,326,329,331,378,379,380],[221,321,324,325,331],[221,307],[221,377],[221,321,325,329,341,363,402,466,544],[221,376,377,378],[221,341,363,376,377],[221,341,363,447],[221,341,363,376,377,381],[221,321,323,341,362,363,377],[221,325,382,482],[221,325,334,335,341,363,381,466,519],[221,331,363,376,377,511],[221,374],[221,357,372],[221,357,373],[221,343,357,374,395],[221,338,343,357],[221,305,332,338,343,356],[221,305,329,331,332,334,341,343,344,345,346,348,349,353,354,357,360,363,364,365,370,372,373,377,378,381],[221,339],[221,320,329,331],[221,399],[221,321,323,345,362],[221,321,341,345,346,353,363,377,531],[221,345,346,354],[221,337,341,349,378],[221,345],[221,321,354,363,377,531],[221,353],[221,345,346],[221,347,352,374],[221,341,344,345,346,353,374,529,535,536],[221,341,344,349,353,361,363,377,378],[221,305,344,345,355,359,374,378],[221,305,332,341,345,346],[221,345,346,348,349,350,354],[221,351,353],[221,345,348,353,354,399],[221,305],[221,361,381],[221,332,338,366,367,368,369],[221,329],[221,329,330],[221,329,330,341,343,377,544],[221,305,480],[221,305,343,371],[221,305,320,331,338,342],[221,547],[178,221,228,237,243],[221,241],[221,238,242],[221,240],[49,126,221],[47,49,60,221],[48,49,50,51,52,58,127,221],[48,51,53,58,59,127,221],[48,53,58,60,221],[47,57,58,60,61,72,73,126,129,131,221],[47,221],[55,74,221],[57,58,59,60,61,62,72,73,74,127,131,221],[74,127,131,221],[56,60,74,77,127,129,131,221],[82,83,127,221],[58,127,221],[127,221],[48,53,56,57,58,60,127,129,221],[48,52,56,57,58,60,127,129,221],[48,54,56,57,58,60,127,129,221],[58,60,221],[54,56,58,60,127,221],[55,56,57,58,60,67,68,69,70,127,128,221],[52,53,54,56,57,60,127,221],[60,221],[129,221],[55,57,58,127,129,221],[127,131,221],[57,58,60,127,129,221],[56,57,127,128,129,221],[62,87,221],[49,86,221],[49,221],[48,53,56,57,60,61,68,127,221],[52,56,57,60,61,69,127,221],[48,129,221],[87,129,221],[53,56,60,67,127,221],[65,129,221],[48,53,56,60,67,127,221],[52,56,60,69,127,221],[48,86,129,221],[46,129,221],[70,221],[71,221],[66,70,221],[63,71,221],[72,129,221],[56,73,85,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,130,131,221],[64,70,73,221],[73,130,221],[59,221],[73,221],[47,49,221],[46,48,49,50,52,53,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,125,127,129,130,131,221],[79,80,131,221],[49,126],[47,49,60],[49,58,127],[53,58,59],[53,60],[47,57,58,61,72,73,129,131],[47],[55,74],[74,127,131],[74,77,131],[127],[53,56,57,58,60,127,129],[52,56,57,58,60,127,129],[56,57,58,60,127,129],[58,60],[56,58,60,127],[55,56,57,58,60,127],[52,53,56,57,60,127],[60],[129],[55,57,58,127,129],[131],[57,58,60,127,129],[56,57,127,129],[87],[49,86],[49],[53,56,57,68,127],[52,56,57,69,127],[126,129],[53,56,67,127],[52,56,69,127],[126],[71],[73,130,131],[73,126],[73,130],[59],[73],[47,49],[46,48,49,50,52,53,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,125,127,129,130,131]],"referencedMap":[[138,1],[136,2],[237,2],[240,3],[239,2],[135,2],[141,4],[137,1],[139,5],[140,1],[142,2],[144,6],[145,6],[146,2],[147,2],[149,7],[150,2],[151,2],[152,6],[153,2],[154,2],[155,8],[156,2],[157,2],[158,9],[159,2],[160,10],[161,2],[162,2],[163,2],[164,2],[167,2],[166,11],[143,2],[168,12],[169,2],[165,2],[170,2],[171,6],[172,13],[173,14],[174,2],[148,2],[230,15],[229,2],[231,16],[233,17],[234,2],[235,18],[236,19],[245,20],[246,2],[247,2],[248,2],[249,2],[175,21],[176,21],[178,22],[179,23],[180,24],[181,25],[182,26],[183,27],[184,28],[185,29],[186,30],[187,31],[188,31],[190,32],[189,33],[191,32],[192,34],[193,35],[177,36],[227,2],[194,37],[195,38],[196,39],[228,40],[197,41],[198,42],[199,43],[200,44],[201,45],[202,46],[203,47],[204,48],[205,49],[206,50],[207,50],[208,51],[209,52],[211,53],[210,54],[212,55],[213,56],[214,57],[215,58],[216,59],[217,60],[218,61],[219,62],[220,63],[221,64],[222,65],[223,66],[224,67],[225,68],[226,69],[250,2],[251,2],[252,2],[253,2],[254,2],[259,70],[255,2],[258,71],[260,2],[257,2],[285,72],[286,73],[261,74],[264,74],[283,72],[284,72],[274,72],[273,75],[271,72],[266,72],[279,72],[277,72],[281,72],[265,72],[278,72],[282,72],[267,72],[268,72],[280,72],[262,72],[269,72],[270,72],[272,72],[276,72],[287,76],[275,72],[263,72],[300,77],[299,2],[294,76],[296,78],[295,76],[288,76],[289,76],[291,76],[293,76],[297,78],[298,78],[290,78],[292,78],[301,2],[302,2],[304,79],[303,2],[545,80],[306,2],[544,81],[386,82],[383,83],[387,84],[385,2],[384,85],[311,86],[319,2],[318,2],[317,87],[316,88],[315,88],[314,88],[313,88],[312,88],[390,89],[392,90],[388,2],[389,91],[391,92],[368,93],[378,94],[397,95],[394,96],[367,96],[393,97],[305,2],[321,98],[363,99],[403,2],[338,2],[362,2],[402,100],[400,101],[401,102],[322,103],[323,104],[327,2],[377,105],[376,106],[398,2],[399,107],[421,2],[422,108],[424,109],[423,2],[404,110],[416,111],[420,2],[417,112],[418,113],[419,114],[406,115],[407,116],[408,111],[409,116],[415,117],[405,111],[410,111],[411,116],[412,111],[413,116],[414,111],[425,101],[426,101],[427,101],[429,118],[428,101],[431,119],[432,101],[433,120],[446,121],[434,119],[435,122],[436,119],[437,101],[430,101],[438,101],[439,123],[440,101],[441,119],[442,101],[443,101],[444,124],[445,101],[467,125],[468,126],[464,127],[463,128],[462,129],[461,130],[457,126],[456,131],[465,132],[453,133],[458,126],[450,134],[449,135],[472,136],[475,137],[460,138],[459,139],[454,140],[476,137],[359,141],[474,142],[358,143],[452,144],[451,145],[471,136],[470,146],[469,147],[479,148],[494,149],[488,150],[493,2],[481,151],[484,152],[483,153],[491,149],[490,149],[489,149],[477,154],[492,2],[478,155],[487,156],[486,157],[485,158],[509,159],[510,160],[341,161],[511,162],[455,163],[506,164],[507,165],[505,166],[508,167],[504,168],[502,167],[501,169],[500,167],[503,167],[499,159],[498,170],[497,171],[495,172],[496,159],[515,173],[334,174],[329,175],[328,176],[380,177],[326,178],[514,179],[307,2],[336,180],[516,181],[320,180],[325,182],[337,183],[324,184],[375,185],[335,186],[379,177],[473,177],[333,187],[331,188],[381,189],[332,190],[310,191],[308,191],[309,191],[512,191],[382,192],[361,192],[518,193],[517,194],[447,195],[521,196],[448,196],[466,197],[522,198],[519,199],[520,200],[513,201],[523,202],[524,203],[525,204],[396,205],[365,206],[357,207],[374,208],[527,2],[340,209],[339,210],[526,211],[531,212],[536,213],[528,214],[345,2],[529,215],[535,202],[530,80],[346,216],[532,217],[533,2],[354,218],[534,219],[355,2],[353,220],[537,221],[349,2],[364,222],[347,2],[360,223],[348,224],[351,225],[352,226],[538,227],[350,228],[369,229],[370,230],[330,231],[539,232],[344,233],[542,108],[541,234],[480,108],[395,108],[372,235],[373,235],[482,235],[356,108],[543,108],[342,2],[343,236],[540,108],[371,2],[546,2],[366,2],[547,2],[548,237],[232,2],[256,2],[244,238],[242,239],[243,240],[238,2],[241,241],[44,2],[45,2],[8,2],[9,2],[11,2],[10,2],[2,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[19,2],[3,2],[4,2],[23,2],[20,2],[21,2],[22,2],[24,2],[25,2],[26,2],[5,2],[27,2],[28,2],[29,2],[30,2],[6,2],[34,2],[31,2],[32,2],[33,2],[35,2],[7,2],[36,2],[41,2],[42,2],[37,2],[38,2],[39,2],[40,2],[1,2],[43,2],[48,2],[62,242],[46,2],[61,243],[49,2],[53,244],[52,245],[51,246],[127,247],[74,248],[77,249],[75,250],[76,251],[78,252],[84,253],[82,254],[83,255],[47,2],[67,256],[68,256],[69,257],[70,258],[59,259],[57,260],[129,261],[58,262],[54,263],[134,2],[55,2],[130,264],[56,265],[79,266],[128,267],[133,268],[88,269],[89,270],[86,271],[87,2],[90,272],[91,273],[92,274],[93,275],[94,264],[95,264],[99,276],[97,264],[98,264],[100,264],[101,264],[102,264],[103,264],[104,264],[121,277],[122,277],[105,278],[106,279],[107,280],[108,280],[109,280],[123,281],[96,276],[124,282],[110,282],[111,283],[112,284],[113,285],[114,282],[115,283],[116,282],[117,283],[119,286],[118,286],[125,287],[85,288],[131,289],[60,290],[80,291],[71,2],[73,283],[72,292],[132,2],[126,293],[66,2],[120,2],[63,2],[65,2],[50,2],[64,2],[81,294]],"exportedModulesMap":[[138,1],[136,2],[237,2],[240,3],[239,2],[135,2],[141,4],[137,1],[139,5],[140,1],[142,2],[144,6],[145,6],[146,2],[147,2],[149,7],[150,2],[151,2],[152,6],[153,2],[154,2],[155,8],[156,2],[157,2],[158,9],[159,2],[160,10],[161,2],[162,2],[163,2],[164,2],[167,2],[166,11],[143,2],[168,12],[169,2],[165,2],[170,2],[171,6],[172,13],[173,14],[174,2],[148,2],[230,15],[229,2],[231,16],[233,17],[234,2],[235,18],[236,19],[245,20],[246,2],[247,2],[248,2],[249,2],[175,21],[176,21],[178,22],[179,23],[180,24],[181,25],[182,26],[183,27],[184,28],[185,29],[186,30],[187,31],[188,31],[190,32],[189,33],[191,32],[192,34],[193,35],[177,36],[227,2],[194,37],[195,38],[196,39],[228,40],[197,41],[198,42],[199,43],[200,44],[201,45],[202,46],[203,47],[204,48],[205,49],[206,50],[207,50],[208,51],[209,52],[211,53],[210,54],[212,55],[213,56],[214,57],[215,58],[216,59],[217,60],[218,61],[219,62],[220,63],[221,64],[222,65],[223,66],[224,67],[225,68],[226,69],[250,2],[251,2],[252,2],[253,2],[254,2],[259,70],[255,2],[258,71],[260,2],[257,2],[285,72],[286,73],[261,74],[264,74],[283,72],[284,72],[274,72],[273,75],[271,72],[266,72],[279,72],[277,72],[281,72],[265,72],[278,72],[282,72],[267,72],[268,72],[280,72],[262,72],[269,72],[270,72],[272,72],[276,72],[287,76],[275,72],[263,72],[300,77],[299,2],[294,76],[296,78],[295,76],[288,76],[289,76],[291,76],[293,76],[297,78],[298,78],[290,78],[292,78],[301,2],[302,2],[304,79],[303,2],[545,80],[306,2],[544,81],[386,82],[383,83],[387,84],[385,2],[384,85],[311,86],[319,2],[318,2],[317,87],[316,88],[315,88],[314,88],[313,88],[312,88],[390,89],[392,90],[388,2],[389,91],[391,92],[368,93],[378,94],[397,95],[394,96],[367,96],[393,97],[305,2],[321,98],[363,99],[403,2],[338,2],[362,2],[402,100],[400,101],[401,102],[322,103],[323,104],[327,2],[377,105],[376,106],[398,2],[399,107],[421,2],[422,108],[424,109],[423,2],[404,110],[416,111],[420,2],[417,112],[418,113],[419,114],[406,115],[407,116],[408,111],[409,116],[415,117],[405,111],[410,111],[411,116],[412,111],[413,116],[414,111],[425,101],[426,101],[427,101],[429,118],[428,101],[431,119],[432,101],[433,120],[446,121],[434,119],[435,122],[436,119],[437,101],[430,101],[438,101],[439,123],[440,101],[441,119],[442,101],[443,101],[444,124],[445,101],[467,125],[468,126],[464,127],[463,128],[462,129],[461,130],[457,126],[456,131],[465,132],[453,133],[458,126],[450,134],[449,135],[472,136],[475,137],[460,138],[459,139],[454,140],[476,137],[359,141],[474,142],[358,143],[452,144],[451,145],[471,136],[470,146],[469,147],[479,148],[494,149],[488,150],[493,2],[481,151],[484,152],[483,153],[491,149],[490,149],[489,149],[477,154],[492,2],[478,155],[487,156],[486,157],[485,158],[509,159],[510,160],[341,161],[511,162],[455,163],[506,164],[507,165],[505,166],[508,167],[504,168],[502,167],[501,169],[500,167],[503,167],[499,159],[498,170],[497,171],[495,172],[496,159],[515,173],[334,174],[329,175],[328,176],[380,177],[326,178],[514,179],[307,2],[336,180],[516,181],[320,180],[325,182],[337,183],[324,184],[375,185],[335,186],[379,177],[473,177],[333,187],[331,188],[381,189],[332,190],[310,191],[308,191],[309,191],[512,191],[382,192],[361,192],[518,193],[517,194],[447,195],[521,196],[448,196],[466,197],[522,198],[519,199],[520,200],[513,201],[523,202],[524,203],[525,204],[396,205],[365,206],[357,207],[374,208],[527,2],[340,209],[339,210],[526,211],[531,212],[536,213],[528,214],[345,2],[529,215],[535,202],[530,80],[346,216],[532,217],[533,2],[354,218],[534,219],[355,2],[353,220],[537,221],[349,2],[364,222],[347,2],[360,223],[348,224],[351,225],[352,226],[538,227],[350,228],[369,229],[370,230],[330,231],[539,232],[344,233],[542,108],[541,234],[480,108],[395,108],[372,235],[373,235],[482,235],[356,108],[543,108],[342,2],[343,236],[540,108],[371,2],[546,2],[366,2],[547,2],[548,237],[232,2],[256,2],[244,238],[242,239],[243,240],[238,2],[241,241],[44,2],[45,2],[8,2],[9,2],[11,2],[10,2],[2,2],[12,2],[13,2],[14,2],[15,2],[16,2],[17,2],[18,2],[19,2],[3,2],[4,2],[23,2],[20,2],[21,2],[22,2],[24,2],[25,2],[26,2],[5,2],[27,2],[28,2],[29,2],[30,2],[6,2],[34,2],[31,2],[32,2],[33,2],[35,2],[7,2],[36,2],[41,2],[42,2],[37,2],[38,2],[39,2],[40,2],[1,2],[43,2],[62,295],[61,296],[53,297],[52,298],[51,299],[127,300],[74,301],[77,302],[75,303],[76,303],[78,304],[84,305],[82,305],[83,305],[67,306],[68,306],[69,307],[70,308],[59,309],[57,310],[129,311],[58,312],[54,313],[130,314],[56,315],[79,316],[128,317],[133,318],[88,319],[89,320],[86,321],[90,322],[91,323],[92,324],[93,324],[94,324],[95,324],[99,325],[97,324],[98,324],[100,324],[101,324],[102,324],[103,324],[104,324],[121,324],[122,324],[105,325],[106,326],[107,324],[108,324],[109,324],[123,324],[96,325],[124,327],[110,327],[111,328],[112,327],[113,328],[114,327],[115,328],[116,327],[117,328],[119,324],[118,324],[125,329],[85,330],[131,331],[60,332],[80,333],[73,328],[72,334],[126,335],[81,316]],"semanticDiagnosticsPerFile":[138,136,237,240,239,135,141,137,139,140,142,144,145,146,147,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,167,166,143,168,169,165,170,171,172,173,174,148,230,229,231,233,234,235,236,245,246,247,248,249,175,176,178,179,180,181,182,183,184,185,186,187,188,190,189,191,192,193,177,227,194,195,196,228,197,198,199,200,201,202,203,204,205,206,207,208,209,211,210,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,250,251,252,253,254,259,255,258,260,257,285,286,261,264,283,284,274,273,271,266,279,277,281,265,278,282,267,268,280,262,269,270,272,276,287,275,263,300,299,294,296,295,288,289,291,293,297,298,290,292,301,302,304,303,545,306,544,386,383,387,385,384,311,319,318,317,316,315,314,313,312,390,392,388,389,391,368,378,397,394,367,393,305,321,363,403,338,362,402,400,401,322,323,327,377,376,398,399,421,422,424,423,404,416,420,417,418,419,406,407,408,409,415,405,410,411,412,413,414,425,426,427,429,428,431,432,433,446,434,435,436,437,430,438,439,440,441,442,443,444,445,467,468,464,463,462,461,457,456,465,453,458,450,449,472,475,460,459,454,476,359,474,358,452,451,471,470,469,479,494,488,493,481,484,483,491,490,489,477,492,478,487,486,485,509,510,341,511,455,506,507,505,508,504,502,501,500,503,499,498,497,495,496,515,334,329,328,380,326,514,307,336,516,320,325,337,324,375,335,379,473,333,331,381,332,310,308,309,512,382,361,518,517,447,521,448,466,522,519,520,513,523,524,525,396,365,357,374,527,340,339,526,531,536,528,345,529,535,530,346,532,533,354,534,355,353,537,349,364,347,360,348,351,352,538,350,369,370,330,539,344,542,541,480,395,372,373,482,356,543,342,343,540,371,546,366,547,548,232,256,244,242,243,238,241,44,45,8,9,11,10,2,12,13,14,15,16,17,18,19,3,4,23,20,21,22,24,25,26,5,27,28,29,30,6,34,31,32,33,35,7,36,41,42,37,38,39,40,1,43,48,62,46,61,49,53,52,51,127,74,77,75,76,78,84,82,83,47,67,68,69,70,59,57,129,58,54,134,55,130,56,79,128,133,88,89,86,87,90,91,92,93,94,95,99,97,98,100,101,102,103,104,121,122,105,106,107,108,109,123,96,124,110,111,112,113,114,115,116,117,119,118,125,85,131,60,80,71,73,72,132,126,66,120,63,65,50,64,81]},"version":"5.0.4"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/validateRegistry.d.ts b/node_modules/@behave-graph/core/dist/validateRegistry.d.ts
new file mode 100644
index 0000000..384a2b7
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/validateRegistry.d.ts
@@ -0,0 +1,2 @@
+import { IRegistry } from './Registry.js';
+export declare function validateRegistry(registry: IRegistry): string[];
diff --git a/node_modules/@behave-graph/core/dist/validateRegistry.js b/node_modules/@behave-graph/core/dist/validateRegistry.js
new file mode 100644
index 0000000..d28f3ff
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/validateRegistry.js
@@ -0,0 +1,8 @@
+import { validateNodeRegistry } from './Nodes/Validation/validateNodeRegistry.js';
+import { validateValueRegistry } from './Values/Validation/validateValueRegistry.js';
+export function validateRegistry(registry) {
+    const errorList = [];
+    errorList.push(...validateValueRegistry(registry.values), ...validateNodeRegistry(registry));
+    return errorList;
+}
+//# sourceMappingURL=validateRegistry.js.map
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/dist/validateRegistry.js.map b/node_modules/@behave-graph/core/dist/validateRegistry.js.map
new file mode 100644
index 0000000..fbf1937
--- /dev/null
+++ b/node_modules/@behave-graph/core/dist/validateRegistry.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"validateRegistry.js","sourceRoot":"","sources":["../src/validateRegistry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,4CAA4C,CAAC;AAElF,OAAO,EAAE,qBAAqB,EAAE,MAAM,8CAA8C,CAAC;AAErF,MAAM,UAAU,gBAAgB,CAAC,QAAmB;IAClD,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,SAAS,CAAC,IAAI,CACZ,GAAG,qBAAqB,CAAC,QAAQ,CAAC,MAAM,CAAC,EACzC,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAClC,CAAC;IACF,OAAO,SAAS,CAAC;AACnB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@behave-graph/core/src/Graphs/IO/readGraphFromJSON.test.ts b/node_modules/@behave-graph/core/src/Graphs/IO/readGraphFromJSON.test.ts
deleted file mode 100644
index 883a040..0000000
--- a/node_modules/@behave-graph/core/src/Graphs/IO/readGraphFromJSON.test.ts
+++ /dev/null
@@ -1,99 +0,0 @@
-import { Logger } from '../../Diagnostics/Logger.js';
-import { ManualLifecycleEventEmitter } from '../../Profiles/Core/Abstractions/Drivers/ManualLifecycleEventEmitter.js';
-import { registerCoreProfile } from '../../Profiles/Core/registerCoreProfile.js';
-import { readGraphFromJSON } from './readGraphFromJSON.js';
-Logger.onWarn.clear();
-
-describe('readGraphFromJSON', () => {
-  const registry = registerCoreProfile({
-    values: {},
-    nodes: {},
-    dependencies: {
-      ILogger: new Logger(),
-      ILifecycleEventEmitter: new ManualLifecycleEventEmitter()
-    }
-  });
-
-  it('throws if node ids are not unique', () => {
-    const json = {
-      variables: [],
-      customEvents: [],
-      nodes: [
-        {
-          type: 'lifecycle/onStart',
-          id: '0'
-        },
-        {
-          type: 'debug/log',
-          id: '0'
-        }
-      ]
-    };
-    expect(() => readGraphFromJSON({ graphJson: json, registry })).toThrow();
-  });
-
-  it("throws if input keys don't match known sockets", () => {
-    const json = {
-      variables: [],
-      customEvents: [],
-      nodes: [
-        {
-          type: 'debug/log',
-          id: '1',
-          parameters: {
-            wrong: { value: 'Hello World!' }
-          }
-        }
-      ]
-    };
-    expect(() => readGraphFromJSON({ graphJson: json, registry })).toThrow();
-  });
-
-  it('throws if input points to non-existent node', () => {
-    const json = {
-      variables: [],
-      customEvents: [],
-      nodes: [
-        {
-          type: 'lifecycle/onStart',
-          id: '0'
-        },
-        {
-          type: 'debug/log',
-          id: '1',
-          parameters: {
-            text: { value: 'Hello World!' }
-          },
-          flows: {
-            flow: { nodeId: '2', socket: 'flow' }
-          }
-        }
-      ]
-    };
-    expect(() => readGraphFromJSON({ graphJson: json, registry })).toThrow();
-  });
-
-  it('throws if input points to non-existent socket', () => {
-    const json = {
-      variables: [],
-      customEvents: [],
-      nodes: [
-        {
-          type: 'lifecycle/onStart',
-          id: '0'
-        },
-        {
-          type: 'debug/log',
-          id: '1',
-          parameters: {
-            text: { value: 'Hello World!' }
-          },
-          flows: {
-            flow: { nodeId: '0', socket: 'text' }
-          }
-        }
-      ]
-    };
-    expect(() => readGraphFromJSON({ graphJson: json, registry })).toThrow();
-  });
-});
diff --git a/node_modules/@behave-graph/core/src/Graphs/IO/writeNodeSpecsToJSON.ts b/node_modules/@behave-graph/core/src/Graphs/IO/writeNodeSpecsToJSON.ts
index 90c3292..054dede 100644
--- a/node_modules/@behave-graph/core/src/Graphs/IO/writeNodeSpecsToJSON.ts
+++ b/node_modules/@behave-graph/core/src/Graphs/IO/writeNodeSpecsToJSON.ts
@@ -1,7 +1,9 @@
 import { NodeCategory } from '../../Nodes/NodeDefinitions.js';
+import { NodeConfigurationDescription } from '../../Nodes/Registry/NodeDescription.js';
 import { IRegistry } from '../../Registry.js';
 import { Choices } from '../../Sockets/Socket.js';
 import { createNode, makeGraphApi } from '../Graph.js';
+import { NodeConfigurationJSON } from './GraphJSON.js';
 import {
   ChoiceJSON,
   InputSocketSpecJSON,
@@ -16,64 +18,96 @@ function toChoices(valueChoices: Choices | undefined): ChoiceJSON | undefined {
   });
 }
 
-export function writeNodeSpecsToJSON(registry: IRegistry): NodeSpecJSON[] {
-  const nodeSpecsJSON: NodeSpecJSON[] = [];
-
-  // const graph = new Graph(registry);
-
+// create JSON specs for a single node based on given configuration
+export function writeNodeSpecToJSON(
+  registry: IRegistry,
+  nodeTypeName: string,
+  configuration: NodeConfigurationJSON
+): NodeSpecJSON {
   const graph = makeGraphApi({
     ...registry,
     customEvents: {},
     variables: {}
   });
 
-  Object.keys(registry.nodes).forEach((nodeTypeName) => {
-    const node = createNode({
-      graph,
-      registry,
-      nodeTypeName
+  const node = createNode({
+    graph,
+    registry,
+    nodeTypeName,
+    nodeConfiguration: configuration
+  });
+  const nodeDefinition: any = registry.nodes[nodeTypeName];
+
+  const nodeSpecJSON: NodeSpecJSON = {
+    type: nodeTypeName,
+    category: node.description.category as NodeCategory,
+    label: node.description.label,
+    inputs: [],
+    outputs: [],
+    configuration: []
+  };
+  if (nodeDefinition.configuration) {
+    Object.entries(
+      nodeDefinition.configuration as NodeConfigurationDescription
+    ).forEach(([configName, configSpec]) => {
+      nodeSpecJSON.configuration.push({
+        name: configName,
+        valueType: configSpec.valueType,
+        defaultValue: configSpec.defaultValue
+      });
     });
+  }
 
-    const nodeSpecJSON: NodeSpecJSON = {
-      type: nodeTypeName,
-      category: node.description.category as NodeCategory,
-      label: node.description.label,
-      inputs: [],
-      outputs: [],
-      configuration: []
+  node.inputs.forEach((inputSocket) => {
+    const valueType =
+      inputSocket.valueTypeName === 'flow'
+        ? undefined
+        : registry.values[inputSocket.valueTypeName];
+
+    let defaultValue = inputSocket.value;
+    if (valueType !== undefined) {
+      defaultValue = valueType.serialize(defaultValue);
+    }
+    if (defaultValue === undefined && valueType !== undefined) {
+      defaultValue = valueType.serialize(valueType.creator());
+    }
+    const socketSpecJSON: InputSocketSpecJSON = {
+      name: inputSocket.name,
+      valueType: inputSocket.valueTypeName,
+      defaultValue,
+      choices: toChoices(inputSocket.valueChoices)
     };
+    nodeSpecJSON.inputs.push(socketSpecJSON);
+  });
 
-    node.inputs.forEach((inputSocket) => {
-      const valueType =
-        inputSocket.valueTypeName === 'flow'
-          ? undefined
-          : registry.values[inputSocket.valueTypeName];
+  node.outputs.forEach((outputSocket) => {
+    const socketSpecJSON: OutputSocketSpecJSON = {
+      name: outputSocket.name,
+      valueType: outputSocket.valueTypeName
+    };
+    nodeSpecJSON.outputs.push(socketSpecJSON);
+  });
 
-      let defaultValue = inputSocket.value;
-      if (valueType !== undefined) {
-        defaultValue = valueType.serialize(defaultValue);
-      }
-      if (defaultValue === undefined && valueType !== undefined) {
-        defaultValue = valueType.serialize(valueType.creator());
-      }
-      const socketSpecJSON: InputSocketSpecJSON = {
-        name: inputSocket.name,
-        valueType: inputSocket.valueTypeName,
-        defaultValue,
-        choices: toChoices(inputSocket.valueChoices)
-      };
-      nodeSpecJSON.inputs.push(socketSpecJSON);
-    });
+  Object.entries(node.description.configuration).forEach(
+    ([configName, configSpec]) => {
+      nodeSpecJSON.configuration.push({
+        name: configName,
+        valueType: configSpec.valueType,
+        defaultValue: configSpec.defaultValue
+      });
+    }
+  );
+  return nodeSpecJSON;
+}
 
-    node.outputs.forEach((outputSocket) => {
-      const socketSpecJSON: OutputSocketSpecJSON = {
-        name: outputSocket.name,
-        valueType: outputSocket.valueTypeName
-      };
-      nodeSpecJSON.outputs.push(socketSpecJSON);
-    });
+// create JSON specs for all nodes with empty configuration
+export function writeDefaultNodeSpecsToJSON(
+  registry: IRegistry
+): NodeSpecJSON[] {
+  const nodeSpecsJSON: NodeSpecJSON[] = [];
 
-    nodeSpecsJSON.push(nodeSpecJSON);
+  Object.keys(registry.nodes).forEach((nodeTypeName) => {
+    nodeSpecsJSON.push(writeNodeSpecToJSON(registry, nodeTypeName, {}));
   });
 
   return nodeSpecsJSON;
diff --git a/node_modules/@behave-graph/core/src/Nodes/EventNode.ts b/node_modules/@behave-graph/core/src/Nodes/EventNode.ts
index 87c6863..033e145 100644
--- a/node_modules/@behave-graph/core/src/Nodes/EventNode.ts
+++ b/node_modules/@behave-graph/core/src/Nodes/EventNode.ts
@@ -94,8 +94,10 @@ export class EventNodeInstance<TEventNodeDef extends IEventNodeDefinition>
       write: this.writeOutput,
       state: this.state,
       outputSocketKeys: this.outputSocketKeys,
-      commit: (outFlowname, fiberCompletedListener) =>
-        engine.commitToNewFiber(this, outFlowname, fiberCompletedListener),
+      commit: (outFlowname, fiberCompletedListener) => {
+        engine.commitToNewFiber(this, outFlowname, fiberCompletedListener);
+        engine.executeAllSync(1);
+      },
       configuration: this.configuration,
       graph: this.graph
     });
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/OnCustomEvent.ts b/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/OnCustomEvent.ts
index 85dea1e..334c547 100644
--- a/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/OnCustomEvent.ts
+++ b/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/OnCustomEvent.ts
@@ -53,6 +53,7 @@ export class OnCustomEvent extends EventNode2 {
       configuration
     });
     this.customEvent = customEvent;
+    graph.customEvents[configuration.customEventId] = customEvent;
   }
   private onCustomEvent:
     | ((parameters: { [parameter: string]: any }) => void)
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts b/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts
index c7c1234..ddd5a74 100644
--- a/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts
+++ b/node_modules/@behave-graph/core/src/Profiles/Core/CustomEvents/TriggerCustomEvent.ts
@@ -54,6 +54,7 @@ export class TriggerCustomEvent extends FlowNode2 {
     });
 
     this.customEvent = customEvent;
+    graph.customEvents[configuration.customEventId] = customEvent;
   }
 
   triggered(fiber: Fiber, triggeringSocketName: string) {
@@ -62,5 +63,6 @@ export class TriggerCustomEvent extends FlowNode2 {
       parameters[parameterSocket.name] = this.readInput(parameterSocket.name);
     });
     this.customEvent.eventEmitter.emit(parameters);
+    fiber.commit(this, 'flow');
   }
 }
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Counter.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Counter.test.ts
deleted file mode 100644
index 9c30480..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Counter.test.ts
+++ /dev/null
@@ -1,82 +0,0 @@
-import {
-  generateTriggerTester,
-  RecordedOutputType,
-  RecordedWritesOrCommits
-} from '../../../Nodes/testUtils.js';
-import { Counter } from './Counter.js';
-
-type RecordedWritesType = RecordedWritesOrCommits<typeof Counter.out>;
-
-describe('Counter', () => {
-  describe('when the flow node is triggered', () => {
-    it('should increase the count then commit to the flow node', () => {
-      // create a flow node tester
-
-      const trigger = generateTriggerTester(Counter);
-
-      // trigger to count 1
-      trigger({
-        triggeringSocketName: 'flow'
-      });
-
-      // trigger to count 2
-      const recordedOutputs = trigger({
-        triggeringSocketName: 'flow'
-      });
-
-      expect(recordedOutputs).toHaveLength(2);
-
-      const expectedOutputs: RecordedWritesType = [
-        {
-          outputType: RecordedOutputType.write,
-          socketName: 'count',
-          value: 2
-        },
-        {
-          outputType: RecordedOutputType.commit,
-          socketName: 'flow'
-        }
-      ];
-
-      expect(recordedOutputs).toEqual(expectedOutputs);
-    });
-  });
-  describe('when the reset node is triggered', () => {
-    it('should reset to 0 but not write to any outputs', () => {
-      const trigger = generateTriggerTester(Counter);
-
-      // trigger first count
-      trigger({
-        triggeringSocketName: 'flow'
-      });
-      // trigger to second count
-      trigger({
-        triggeringSocketName: 'flow'
-      });
-
-      // reset to 0 - should not have a write or commit
-      const resetRecordedOutputs = trigger({
-        triggeringSocketName: 'reset'
-      });
-
-      // make sure there were no recorded outputs
-      expect(resetRecordedOutputs).toHaveLength(0);
-
-      // trigger a counter increment; it should have a write with value one and commit to the flow
-      const outputs = trigger({ triggeringSocketName: 'flow' });
-      const expectedOutputs: RecordedWritesType = [
-        {
-          outputType: RecordedOutputType.write,
-          socketName: 'count',
-          value: 1
-        },
-        {
-          outputType: RecordedOutputType.commit,
-          socketName: 'flow'
-        }
-      ];
-
-      expect(outputs).toEqual(expectedOutputs);
-    });
-  });
-});
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Gate.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Gate.test.ts
deleted file mode 100644
index e2e5df9..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Gate.test.ts
+++ /dev/null
@@ -1,99 +0,0 @@
-import {
-  generateTriggerTester,
-  RecordedOutputType,
-  RecordedWritesOrCommits
-} from '../../../Nodes/testUtils.js';
-import { Gate } from './Gate.js';
-
-type RecordedWritesType = RecordedWritesOrCommits<typeof Gate.out>;
-
-const generateTrigger = () => generateTriggerTester(Gate);
-
-const flowTriggeredOutput: RecordedWritesType = [
-  {
-    outputType: RecordedOutputType.commit,
-    socketName: 'flow'
-  }
-];
-
-describe('Gate', () => {
-  describe('when the `flow` node is triggered', () => {
-    describe('when the gate starts closed', () => {
-      const inputVals = {
-        startClosed: true
-      };
-      it('does nothing', () => {
-        const trigger = generateTrigger();
-        const outputs = trigger({
-          triggeringSocketName: 'flow',
-          inputVals
-        });
-
-        expect(outputs).toHaveLength(0);
-      });
-      describe('when the gate is opened', () => {
-        it('commits to the flow output', () => {
-          const trigger = generateTrigger();
-
-          // initial trigger
-          trigger({
-            triggeringSocketName: 'flow',
-            inputVals
-          });
-
-          trigger({ triggeringSocketName: 'open', inputVals });
-
-          const outputs = trigger({ triggeringSocketName: 'flow', inputVals });
-
-          expect(outputs).toEqual(flowTriggeredOutput);
-        });
-      });
-    });
-    describe('when the gate starts opened (by default)', () => {
-      it('commits to the flow output', () => {
-        const trigger = generateTrigger();
-
-        const outputs = trigger({
-          triggeringSocketName: 'flow'
-        });
-
-        expect(outputs).toHaveLength(1);
-
-        expect(outputs).toEqual(flowTriggeredOutput);
-      });
-      describe('when the gate is closed', () => {
-        it('does nothing', () => {
-          const trigger = generateTrigger();
-
-          trigger({
-            triggeringSocketName: 'flow'
-          });
-
-          // close the gate
-          trigger({ triggeringSocketName: 'close' });
-
-          // triggering shouldn't do anything
-          expect(trigger({ triggeringSocketName: 'flow' })).toHaveLength(0);
-        });
-      });
-    });
-    describe('when the gate is toggled', () => {
-      it('will commit if it should be opened', () => {
-        const trigger = generateTrigger();
-
-        // by default, something should trigger
-        expect(trigger({ triggeringSocketName: 'flow' })).toEqual(
-          flowTriggeredOutput
-        );
-
-        trigger({ triggeringSocketName: 'toggle' });
-        expect(trigger({ triggeringSocketName: 'flow' })).toHaveLength(0);
-
-        trigger({ triggeringSocketName: 'toggle' });
-        expect(trigger({ triggeringSocketName: 'flow' })).toEqual(
-          flowTriggeredOutput
-        );
-      });
-    });
-  });
-});
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.test.ts
deleted file mode 100644
index 0174863..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.test.ts
+++ /dev/null
@@ -1,48 +0,0 @@
-import {
-  generateTriggerTester,
-  RecordedOutputType,
-  RecordedWritesOrCommits
-} from '../../../Nodes/testUtils.js';
-import { Sequence } from './Sequence.js';
-
-type RecordedWritesType = RecordedWritesOrCommits<typeof Sequence.out>;
-
-describe('Sequence', () => {
-  it('it triggeres output flows for each element in sequence when triggered', () => {
-    const nodeConfig = {
-      numOutputs: 5
-    };
-    const trigger = generateTriggerTester(Sequence, nodeConfig);
-
-    const outputs = trigger({
-      triggeringSocketName: 'flow'
-    });
-
-    expect(outputs).toHaveLength(5);
-
-    const expectedOutputs: RecordedWritesType = [
-      {
-        outputType: RecordedOutputType.commit,
-        socketName: '1'
-      },
-      {
-        outputType: RecordedOutputType.commit,
-        socketName: '2'
-      },
-      {
-        outputType: RecordedOutputType.commit,
-        socketName: '3'
-      },
-      {
-        outputType: RecordedOutputType.commit,
-        socketName: '4'
-      },
-      {
-        outputType: RecordedOutputType.commit,
-        socketName: '5'
-      }
-    ];
-
-    expect(outputs).toEqual(expectedOutputs);
-  });
-});
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.ts b/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.ts
index 09ebd94..793406d 100644
--- a/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.ts
+++ b/node_modules/@behave-graph/core/src/Profiles/Core/Flow/Sequence.ts
@@ -10,14 +10,15 @@ export const Sequence = makeFlowNodeDefinition({
   label: 'Sequence',
   configuration: {
     numOutputs: {
-      valueType: 'number'
+      valueType: 'number',
+      defaultValue: 4
     }
   },
   in: {
     flow: 'flow'
   },
   out: (configuration) => {
-    const numOutputs = configuration.numOutputs;
+    const numOutputs = configuration.numOutputs ?? 4;
     const sockets: SocketsList = [];
 
     for (let outputIndex = 1; outputIndex <= numOutputs; outputIndex++) {
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/Values/BooleanConversions.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/Values/BooleanConversions.test.ts
deleted file mode 100644
index 03cce57..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/Values/BooleanConversions.test.ts
+++ /dev/null
@@ -1,57 +0,0 @@
-import { testExec } from '../../../Nodes/testUtils.js';
-import { toInteger } from './BooleanNodes.js';
-import { toBoolean as intToBoolean } from './IntegerNodes.js';
-
-describe('Boolean Conversions', () => {
-  describe('math/toBoolean/integer', () => {
-    it('writes to the output false when the input value is 0', () => {
-      const outputs = testExec({
-        exec: intToBoolean.exec,
-        nodeInputVals: {
-          a: 0n
-        }
-      });
-
-      expect(outputs['result']).toEqual(false);
-    });
-    it('writes to the output true when the input value is non-zero', () => {
-      const outputs = testExec({
-        exec: intToBoolean.exec,
-        // test with value 1
-        nodeInputVals: {
-          a: 1n
-        }
-      });
-      expect(outputs['result']).toEqual(true);
-
-      const secondResult = testExec({
-        exec: intToBoolean.exec,
-        // test with value to 5
-        nodeInputVals: {
-          a: 5n
-        }
-      });
-
-      expect(secondResult['result']).toEqual(true);
-    });
-  });
-
-  describe('math/toInteger/boolean', () => {
-    it('writes to the output 1 when the input value is true', () => {
-      const output = testExec({
-        exec: toInteger.exec,
-        nodeInputVals: {
-          a: true
-        }
-      });
-      expect(output['result']).toEqual(1n);
-    });
-    it('writes to the output 0 when the input value is false', () => {
-      const output = testExec({
-        exec: toInteger.exec,
-        nodeInputVals: { a: false }
-      });
-      expect(output['result']).toEqual(0n);
-    });
-  });
-});
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/readCoreGraphs.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/readCoreGraphs.test.ts
deleted file mode 100644
index c13fadd..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/readCoreGraphs.test.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-import fs from 'fs';
-import path from 'path';
-
-import { Logger } from '../../Diagnostics/Logger.js';
-import { GraphInstance } from '../../Graphs/Graph.js';
-import { GraphJSON } from '../../Graphs/IO/GraphJSON.js';
-import { readGraphFromJSON } from '../../Graphs/IO/readGraphFromJSON.js';
-import { validateGraphAcyclic } from '../../Graphs/Validation/validateGraphAcyclic.js';
-import { validateGraphLinks } from '../../Graphs/Validation/validateGraphLinks.js';
-import { memo } from '../../memo.js';
-import { getCoreNodesMap, getCoreValuesMap } from './registerCoreProfile.js';
-
-const valueTypes = getCoreValuesMap();
-const nodeDefinitions = getCoreNodesMap();
-
-Logger.onWarn.clear();
-
-const exampleMap = memo<Record<string, GraphJSON>>(() => {
-  const result = {} as Record<string, GraphJSON>;
-  // read all *.jsons in the folder '../../graphs/core':
-  const dir = path.join(__dirname, '../../../../../graphs/core');
-  const files = fs.readdirSync(dir);
-  for (const file of files) {
-    if (file.endsWith('.json')) {
-      // get filename
-      const filename = path.parse(file).name;
-      // read the file as a string and then parse it as JSON
-      const data = fs.readFileSync(path.join(dir, file), {
-        encoding: 'utf-8'
-      });
-      const json = JSON.parse(data);
-      // add the parsed JSON to the map
-      result[filename] = json;
-    }
-  }
-  return result;
-})();
-
-describe(`json core graphs`, () => {
-  for (const key in exampleMap) {
-    const exampleJson = exampleMap[key];
-
-    let parsedGraphJson: GraphInstance | undefined;
-    test(`${key}`, () => {
-      expect(() => {
-        parsedGraphJson = readGraphFromJSON({
-          graphJson: exampleJson,
-          registry: {
-            nodes: nodeDefinitions,
-            values: valueTypes,
-            dependencies: {}
-          }
-        });
-      }).not.toThrow();
-      // await fs.writeFile('./examples/test.json', JSON.stringify(writeGraphToJSON(graph), null, ' '), { encoding: 'utf-8' });
-      if (parsedGraphJson !== undefined) {
-        expect(validateGraphLinks(parsedGraphJson.nodes)).toHaveLength(0);
-        expect(validateGraphAcyclic(parsedGraphJson.nodes)).toHaveLength(0);
-      } else {
-        expect(parsedGraphJson).toBeDefined();
-      }
-    });
-  }
-});
diff --git a/node_modules/@behave-graph/core/src/Profiles/Core/registerCoreProfile.test.ts b/node_modules/@behave-graph/core/src/Profiles/Core/registerCoreProfile.test.ts
deleted file mode 100644
index 12de02c..0000000
--- a/node_modules/@behave-graph/core/src/Profiles/Core/registerCoreProfile.test.ts
+++ /dev/null
@@ -1,40 +0,0 @@
-import { validateNodeRegistry } from '../../Nodes/Validation/validateNodeRegistry.js';
-import { validateValueRegistry } from '../../Values/Validation/validateValueRegistry.js';
-import { registerCoreProfile } from './registerCoreProfile.js';
-
-describe('core profile', () => {
-  const registry = registerCoreProfile({
-    values: {},
-    nodes: {},
-    dependencies: {}
-  });
-
-  test('validate node registry', () => {
-    expect(validateNodeRegistry(registry)).toHaveLength(0);
-  });
-  test('validate value registry', () => {
-    expect(validateValueRegistry(registry.values)).toHaveLength(0);
-  });
-
-  const valueTypeNameToExampleValues: { [key: string]: any[] } = {
-    boolean: ['true', 'false', true, false],
-    string: ['hello'],
-    float: [0.9, -0.1, '-999.1', '9e9'],
-    integer: [5, -5, '-999', '9223372036854775807'] // mac int64 value
-  };
-
-  for (const valueTypeName in valueTypeNameToExampleValues) {
-    test(`${valueTypeName} serialization/deserialization`, () => {
-      const valueType = registry.values[valueTypeName];
-      const exampleValues: any[] = valueTypeNameToExampleValues[valueTypeName];
-      exampleValues.forEach((exampleValue: any) => {
-        const deserializedValue = valueType.deserialize(exampleValue);
-        const serializedValue = valueType.serialize(deserializedValue);
-        const redeserializedValue = valueType.deserialize(serializedValue);
-        expect(deserializedValue).toBe(redeserializedValue);
-        const reserializedValue = valueType.serialize(redeserializedValue);
-        expect(serializedValue).toBe(reserializedValue);
-      });
-    });
-  }
-});
